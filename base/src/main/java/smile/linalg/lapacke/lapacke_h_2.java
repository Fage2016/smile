// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class lapacke_h_2 extends lapacke_h_3 {

    lapacke_h_2() {
        // Should not be called directly
    }

    private static class LAPACKE_dggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggqrf$descriptor() {
        return LAPACKE_dggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MethodHandle LAPACKE_dggqrf$handle() {
        return LAPACKE_dggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MemorySegment LAPACKE_dggqrf$address() {
        return LAPACKE_dggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static int LAPACKE_dggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_dggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggqrf$descriptor() {
        return LAPACKE_cggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MethodHandle LAPACKE_cggqrf$handle() {
        return LAPACKE_cggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MemorySegment LAPACKE_cggqrf$address() {
        return LAPACKE_cggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static int LAPACKE_cggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_cggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggqrf$descriptor() {
        return LAPACKE_zggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MethodHandle LAPACKE_zggqrf$handle() {
        return LAPACKE_zggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MemorySegment LAPACKE_zggqrf$address() {
        return LAPACKE_zggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static int LAPACKE_zggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_zggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggrqf$descriptor() {
        return LAPACKE_sggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MethodHandle LAPACKE_sggrqf$handle() {
        return LAPACKE_sggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MemorySegment LAPACKE_sggrqf$address() {
        return LAPACKE_sggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static int LAPACKE_sggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_sggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggrqf$descriptor() {
        return LAPACKE_dggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MethodHandle LAPACKE_dggrqf$handle() {
        return LAPACKE_dggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static MemorySegment LAPACKE_dggrqf$address() {
        return LAPACKE_dggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, double *a, int lda, double *taua, double *b, int ldb, double *taub)
     * }
     */
    public static int LAPACKE_dggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_dggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggrqf$descriptor() {
        return LAPACKE_cggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MethodHandle LAPACKE_cggrqf$handle() {
        return LAPACKE_cggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static MemorySegment LAPACKE_cggrqf$address() {
        return LAPACKE_cggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, _Complex float *a, int lda, _Complex float *taua, _Complex float *b, int ldb, _Complex float *taub)
     * }
     */
    public static int LAPACKE_cggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_cggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggrqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggrqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggrqf$descriptor() {
        return LAPACKE_zggrqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MethodHandle LAPACKE_zggrqf$handle() {
        return LAPACKE_zggrqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static MemorySegment LAPACKE_zggrqf$address() {
        return LAPACKE_zggrqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, _Complex double *a, int lda, _Complex double *taua, _Complex double *b, int ldb, _Complex double *taub)
     * }
     */
    public static int LAPACKE_zggrqf(int matrix_layout, int m, int p, int n, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_zggrqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggrqf", matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, m, p, n, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd$descriptor() {
        return LAPACKE_sggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd$handle() {
        return LAPACKE_sggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd$address() {
        return LAPACKE_sggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd$descriptor() {
        return LAPACKE_dggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd$handle() {
        return LAPACKE_dggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd$address() {
        return LAPACKE_dggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd$descriptor() {
        return LAPACKE_cggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd$handle() {
        return LAPACKE_cggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd$address() {
        return LAPACKE_cggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd$descriptor() {
        return LAPACKE_zggsvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd$handle() {
        return LAPACKE_zggsvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd$address() {
        return LAPACKE_zggsvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvd3$descriptor() {
        return LAPACKE_sggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sggsvd3$handle() {
        return LAPACKE_sggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sggsvd3$address() {
        return LAPACKE_sggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, float *a, int lda, float *b, int ldb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_sggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_sggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvd3$descriptor() {
        return LAPACKE_dggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dggsvd3$handle() {
        return LAPACKE_dggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dggsvd3$address() {
        return LAPACKE_dggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, double *a, int lda, double *b, int ldb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_dggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_dggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvd3$descriptor() {
        return LAPACKE_cggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cggsvd3$handle() {
        return LAPACKE_cggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cggsvd3$address() {
        return LAPACKE_cggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex float *a, int lda, _Complex float *b, int ldb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_cggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_cggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvd3$descriptor() {
        return LAPACKE_zggsvd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zggsvd3$handle() {
        return LAPACKE_zggsvd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zggsvd3$address() {
        return LAPACKE_zggsvd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvd3(int matrix_layout, char jobu, char jobv, char jobq, int m, int n, int p, int *k, int *l, _Complex double *a, int lda, _Complex double *b, int ldb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *iwork)
     * }
     */
    public static int LAPACKE_zggsvd3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int n, int p, MemorySegment k, MemorySegment l, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment iwork) {
        var mh$ = LAPACKE_zggsvd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvd3", matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp$descriptor() {
        return LAPACKE_sggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp$handle() {
        return LAPACKE_sggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp$address() {
        return LAPACKE_sggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp$descriptor() {
        return LAPACKE_dggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp$handle() {
        return LAPACKE_dggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp$address() {
        return LAPACKE_dggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp$descriptor() {
        return LAPACKE_cggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp$handle() {
        return LAPACKE_cggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp$address() {
        return LAPACKE_cggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp$descriptor() {
        return LAPACKE_zggsvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp$handle() {
        return LAPACKE_zggsvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp$address() {
        return LAPACKE_zggsvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zggsvp(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zggsvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggsvp3$descriptor() {
        return LAPACKE_sggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sggsvp3$handle() {
        return LAPACKE_sggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sggsvp3$address() {
        return LAPACKE_sggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, float *a, int lda, float *b, int ldb, float tola, float tolb, int *k, int *l, float *u, int ldu, float *v, int ldv, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggsvp3$descriptor() {
        return LAPACKE_dggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dggsvp3$handle() {
        return LAPACKE_dggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dggsvp3$address() {
        return LAPACKE_dggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, double *a, int lda, double *b, int ldb, double tola, double tolb, int *k, int *l, double *u, int ldu, double *v, int ldv, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggsvp3$descriptor() {
        return LAPACKE_cggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cggsvp3$handle() {
        return LAPACKE_cggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cggsvp3$address() {
        return LAPACKE_cggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, int *k, int *l, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggsvp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggsvp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggsvp3$descriptor() {
        return LAPACKE_zggsvp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zggsvp3$handle() {
        return LAPACKE_zggsvp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zggsvp3$address() {
        return LAPACKE_zggsvp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggsvp3(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, int *k, int *l, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zggsvp3(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment k, MemorySegment l, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zggsvp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggsvp3", matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtcon$descriptor() {
        return LAPACKE_sgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgtcon$handle() {
        return LAPACKE_sgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgtcon$address() {
        return LAPACKE_sgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtcon(char norm, int n, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtcon$descriptor() {
        return LAPACKE_dgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgtcon$handle() {
        return LAPACKE_dgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgtcon$address() {
        return LAPACKE_dgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtcon(char norm, int n, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtcon$descriptor() {
        return LAPACKE_cgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgtcon$handle() {
        return LAPACKE_cgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgtcon$address() {
        return LAPACKE_cgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtcon(char norm, int n, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtcon$descriptor() {
        return LAPACKE_zgtcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgtcon$handle() {
        return LAPACKE_zgtcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgtcon$address() {
        return LAPACKE_zgtcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtcon(char norm, int n, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgtcon(byte norm, int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgtcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtcon", norm, n, dl, d, du, du2, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(norm, n, dl, d, du, du2, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtrfs$descriptor() {
        return LAPACKE_sgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgtrfs$handle() {
        return LAPACKE_sgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgtrfs$address() {
        return LAPACKE_sgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtrfs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *dlf, const float *df, const float *duf, const float *du2, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtrfs$descriptor() {
        return LAPACKE_dgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgtrfs$handle() {
        return LAPACKE_dgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgtrfs$address() {
        return LAPACKE_dgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtrfs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *dlf, const double *df, const double *duf, const double *du2, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtrfs$descriptor() {
        return LAPACKE_cgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgtrfs$handle() {
        return LAPACKE_cgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgtrfs$address() {
        return LAPACKE_cgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *dlf, const _Complex float *df, const _Complex float *duf, const _Complex float *du2, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtrfs$descriptor() {
        return LAPACKE_zgtrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgtrfs$handle() {
        return LAPACKE_zgtrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgtrfs$address() {
        return LAPACKE_zgtrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtrfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *dlf, const _Complex double *df, const _Complex double *duf, const _Complex double *du2, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgtrfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgtrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtrfs", matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsv$descriptor() {
        return LAPACKE_sgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgtsv$handle() {
        return LAPACKE_sgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgtsv$address() {
        return LAPACKE_sgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, float *dl, float *d, float *du, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsv$descriptor() {
        return LAPACKE_dgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgtsv$handle() {
        return LAPACKE_dgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgtsv$address() {
        return LAPACKE_dgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, double *dl, double *d, double *du, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsv$descriptor() {
        return LAPACKE_cgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgtsv$handle() {
        return LAPACKE_cgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgtsv$address() {
        return LAPACKE_cgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsv$descriptor() {
        return LAPACKE_zgtsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgtsv$handle() {
        return LAPACKE_zgtsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgtsv$address() {
        return LAPACKE_zgtsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgtsv(int matrix_layout, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgtsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsv", matrix_layout, n, nrhs, dl, d, du, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, dl, d, du, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgtsvx$descriptor() {
        return LAPACKE_sgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgtsvx$handle() {
        return LAPACKE_sgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgtsvx$address() {
        return LAPACKE_sgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, float *dlf, float *df, float *duf, float *du2, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgtsvx$descriptor() {
        return LAPACKE_dgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgtsvx$handle() {
        return LAPACKE_dgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgtsvx$address() {
        return LAPACKE_dgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, double *dlf, double *df, double *duf, double *du2, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgtsvx$descriptor() {
        return LAPACKE_cgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgtsvx$handle() {
        return LAPACKE_cgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgtsvx$address() {
        return LAPACKE_cgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, _Complex float *dlf, _Complex float *df, _Complex float *duf, _Complex float *du2, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgtsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgtsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgtsvx$descriptor() {
        return LAPACKE_zgtsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgtsvx$handle() {
        return LAPACKE_zgtsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgtsvx$address() {
        return LAPACKE_zgtsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgtsvx(int matrix_layout, char fact, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, _Complex double *dlf, _Complex double *df, _Complex double *duf, _Complex double *du2, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgtsvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment dlf, MemorySegment df, MemorySegment duf, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgtsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgtsvx", matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, dl, d, du, dlf, df, duf, du2, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrf$descriptor() {
        return LAPACKE_sgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgttrf$handle() {
        return LAPACKE_sgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgttrf$address() {
        return LAPACKE_sgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrf(int n, float *dl, float *d, float *du, float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_sgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrf$descriptor() {
        return LAPACKE_dgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgttrf$handle() {
        return LAPACKE_dgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgttrf$address() {
        return LAPACKE_dgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrf(int n, double *dl, double *d, double *du, double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_dgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrf$descriptor() {
        return LAPACKE_cgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgttrf$handle() {
        return LAPACKE_cgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgttrf$address() {
        return LAPACKE_cgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrf(int n, _Complex float *dl, _Complex float *d, _Complex float *du, _Complex float *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_cgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrf$descriptor() {
        return LAPACKE_zgttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgttrf$handle() {
        return LAPACKE_zgttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgttrf$address() {
        return LAPACKE_zgttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrf(int n, _Complex double *dl, _Complex double *d, _Complex double *du, _Complex double *du2, int *ipiv)
     * }
     */
    public static int LAPACKE_zgttrf(int n, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrf", n, dl, d, du, du2, ipiv);
            }
            return (int)mh$.invokeExact(n, dl, d, du, du2, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgttrs$descriptor() {
        return LAPACKE_sgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgttrs$handle() {
        return LAPACKE_sgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgttrs$address() {
        return LAPACKE_sgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgttrs(int matrix_layout, char trans, int n, int nrhs, const float *dl, const float *d, const float *du, const float *du2, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgttrs$descriptor() {
        return LAPACKE_dgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgttrs$handle() {
        return LAPACKE_dgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgttrs$address() {
        return LAPACKE_dgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgttrs(int matrix_layout, char trans, int n, int nrhs, const double *dl, const double *d, const double *du, const double *du2, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgttrs$descriptor() {
        return LAPACKE_cgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgttrs$handle() {
        return LAPACKE_cgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgttrs$address() {
        return LAPACKE_cgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *dl, const _Complex float *d, const _Complex float *du, const _Complex float *du2, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgttrs$descriptor() {
        return LAPACKE_zgttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgttrs$handle() {
        return LAPACKE_zgttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgttrs$address() {
        return LAPACKE_zgttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgttrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *dl, const _Complex double *d, const _Complex double *du, const _Complex double *du2, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgttrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment dl, MemorySegment d, MemorySegment du, MemorySegment du2, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgttrs", matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbev$descriptor() {
        return LAPACKE_chbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbev$handle() {
        return LAPACKE_chbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbev$address() {
        return LAPACKE_chbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbev$descriptor() {
        return LAPACKE_zhbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbev$handle() {
        return LAPACKE_zhbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbev$address() {
        return LAPACKE_zhbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbev(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevd$descriptor() {
        return LAPACKE_chbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbevd$handle() {
        return LAPACKE_chbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbevd$address() {
        return LAPACKE_chbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex float *ab, int ldab, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevd$descriptor() {
        return LAPACKE_zhbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbevd$handle() {
        return LAPACKE_zhbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbevd$address() {
        return LAPACKE_zhbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevd(int matrix_layout, char jobz, char uplo, int n, int kd, _Complex double *ab, int ldab, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbevx$descriptor() {
        return LAPACKE_chbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbevx$handle() {
        return LAPACKE_chbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbevx$address() {
        return LAPACKE_chbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex float *ab, int ldab, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbevx$descriptor() {
        return LAPACKE_zhbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbevx$handle() {
        return LAPACKE_zhbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbevx$address() {
        return LAPACKE_zhbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, _Complex double *ab, int ldab, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgst$descriptor() {
        return LAPACKE_chbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_chbgst$handle() {
        return LAPACKE_chbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_chbgst$address() {
        return LAPACKE_chbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, const _Complex float *bb, int ldbb, _Complex float *x, int ldx)
     * }
     */
    public static int LAPACKE_chbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_chbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgst$descriptor() {
        return LAPACKE_zhbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_zhbgst$handle() {
        return LAPACKE_zhbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_zhbgst$address() {
        return LAPACKE_zhbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, const _Complex double *bb, int ldbb, _Complex double *x, int ldx)
     * }
     */
    public static int LAPACKE_zhbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_zhbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgv$descriptor() {
        return LAPACKE_chbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbgv$handle() {
        return LAPACKE_chbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbgv$address() {
        return LAPACKE_chbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgv$descriptor() {
        return LAPACKE_zhbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbgv$handle() {
        return LAPACKE_zhbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbgv$address() {
        return LAPACKE_zhbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvd$descriptor() {
        return LAPACKE_chbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chbgvd$handle() {
        return LAPACKE_chbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chbgvd$address() {
        return LAPACKE_chbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvd$descriptor() {
        return LAPACKE_zhbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvd$handle() {
        return LAPACKE_zhbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvd$address() {
        return LAPACKE_zhbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbgvx$descriptor() {
        return LAPACKE_chbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chbgvx$handle() {
        return LAPACKE_chbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chbgvx$address() {
        return LAPACKE_chbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex float *ab, int ldab, _Complex float *bb, int ldbb, _Complex float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbgvx$descriptor() {
        return LAPACKE_zhbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhbgvx$handle() {
        return LAPACKE_zhbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhbgvx$address() {
        return LAPACKE_zhbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, _Complex double *ab, int ldab, _Complex double *bb, int ldbb, _Complex double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_chbtrd$descriptor() {
        return LAPACKE_chbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_chbtrd$handle() {
        return LAPACKE_chbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_chbtrd$address() {
        return LAPACKE_chbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_chbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_chbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhbtrd$descriptor() {
        return LAPACKE_zhbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zhbtrd$handle() {
        return LAPACKE_zhbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zhbtrd$address() {
        return LAPACKE_zhbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhbtrd(int matrix_layout, char vect, char uplo, int n, int kd, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zhbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zhbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_checon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_checon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_checon$descriptor() {
        return LAPACKE_checon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_checon$handle() {
        return LAPACKE_checon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_checon$address() {
        return LAPACKE_checon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_checon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_checon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_checon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_checon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhecon$descriptor() {
        return LAPACKE_zhecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zhecon$handle() {
        return LAPACKE_zhecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zhecon$address() {
        return LAPACKE_zhecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhecon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zhecon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zhecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhecon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheequb$descriptor() {
        return LAPACKE_cheequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cheequb$handle() {
        return LAPACKE_cheequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cheequb$address() {
        return LAPACKE_cheequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cheequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cheequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheequb$descriptor() {
        return LAPACKE_zheequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zheequb$handle() {
        return LAPACKE_zheequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zheequb$address() {
        return LAPACKE_zheequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zheequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zheequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheev$descriptor() {
        return LAPACKE_cheev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheev$handle() {
        return LAPACKE_cheev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheev$address() {
        return LAPACKE_cheev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheev(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheev$descriptor() {
        return LAPACKE_zheev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheev$handle() {
        return LAPACKE_zheev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheev$address() {
        return LAPACKE_zheev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheev(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevd$descriptor() {
        return LAPACKE_cheevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_cheevd$handle() {
        return LAPACKE_cheevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_cheevd$address() {
        return LAPACKE_cheevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_cheevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_cheevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevd$descriptor() {
        return LAPACKE_zheevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zheevd$handle() {
        return LAPACKE_zheevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zheevd$address() {
        return LAPACKE_zheevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_zheevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_zheevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevr$descriptor() {
        return LAPACKE_cheevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_cheevr$handle() {
        return LAPACKE_cheevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_cheevr$address() {
        return LAPACKE_cheevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_cheevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_cheevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevr$descriptor() {
        return LAPACKE_zheevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_zheevr$handle() {
        return LAPACKE_zheevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_zheevr$address() {
        return LAPACKE_zheevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevr(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_zheevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_zheevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cheevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cheevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_cheevx$descriptor() {
        return LAPACKE_cheevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_cheevx$handle() {
        return LAPACKE_cheevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_cheevx$address() {
        return LAPACKE_cheevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_cheevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_cheevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cheevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zheevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zheevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zheevx$descriptor() {
        return LAPACKE_zheevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zheevx$handle() {
        return LAPACKE_zheevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zheevx$address() {
        return LAPACKE_zheevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zheevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zheevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zheevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zheevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegst$descriptor() {
        return LAPACKE_chegst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chegst$handle() {
        return LAPACKE_chegst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chegst$address() {
        return LAPACKE_chegst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegst(int matrix_layout, int itype, char uplo, int n, _Complex float *a, int lda, const _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chegst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chegst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegst$descriptor() {
        return LAPACKE_zhegst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhegst$handle() {
        return LAPACKE_zhegst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhegst$address() {
        return LAPACKE_zhegst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegst(int matrix_layout, int itype, char uplo, int n, _Complex double *a, int lda, const _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhegst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhegst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegv$descriptor() {
        return LAPACKE_chegv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_chegv$handle() {
        return LAPACKE_chegv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_chegv$address() {
        return LAPACKE_chegv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_chegv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_chegv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegv$descriptor() {
        return LAPACKE_zhegv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zhegv$handle() {
        return LAPACKE_zhegv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zhegv$address() {
        return LAPACKE_zhegv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_zhegv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_zhegv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvd$descriptor() {
        return LAPACKE_chegvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_chegvd$handle() {
        return LAPACKE_chegvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_chegvd$address() {
        return LAPACKE_chegvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_chegvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_chegvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvd$descriptor() {
        return LAPACKE_zhegvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_zhegvd$handle() {
        return LAPACKE_zhegvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_zhegvd$address() {
        return LAPACKE_zhegvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_zhegvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_zhegvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chegvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chegvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chegvx$descriptor() {
        return LAPACKE_chegvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chegvx$handle() {
        return LAPACKE_chegvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chegvx$address() {
        return LAPACKE_chegvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *a, int lda, _Complex float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chegvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chegvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chegvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhegvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhegvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhegvx$descriptor() {
        return LAPACKE_zhegvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhegvx$handle() {
        return LAPACKE_zhegvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhegvx$address() {
        return LAPACKE_zhegvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhegvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *a, int lda, _Complex double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhegvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhegvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhegvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cherfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfs$descriptor() {
        return LAPACKE_cherfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cherfs$handle() {
        return LAPACKE_cherfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cherfs$address() {
        return LAPACKE_cherfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cherfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cherfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zherfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfs$descriptor() {
        return LAPACKE_zherfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zherfs$handle() {
        return LAPACKE_zherfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zherfs$address() {
        return LAPACKE_zherfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zherfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zherfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cherfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cherfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cherfsx$descriptor() {
        return LAPACKE_cherfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cherfsx$handle() {
        return LAPACKE_cherfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cherfsx$address() {
        return LAPACKE_cherfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cherfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cherfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cherfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zherfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zherfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zherfsx$descriptor() {
        return LAPACKE_zherfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zherfsx$handle() {
        return LAPACKE_zherfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zherfsx$address() {
        return LAPACKE_zherfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zherfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zherfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zherfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zherfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesv$descriptor() {
        return LAPACKE_chesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chesv$handle() {
        return LAPACKE_chesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chesv$address() {
        return LAPACKE_chesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chesv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesv$descriptor() {
        return LAPACKE_zhesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhesv$handle() {
        return LAPACKE_zhesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhesv$address() {
        return LAPACKE_zhesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhesv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvx$descriptor() {
        return LAPACKE_chesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chesvx$handle() {
        return LAPACKE_chesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chesvx$address() {
        return LAPACKE_chesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chesvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvx$descriptor() {
        return LAPACKE_zhesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhesvx$handle() {
        return LAPACKE_zhesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhesvx$address() {
        return LAPACKE_zhesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhesvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_chesvxx$descriptor() {
        return LAPACKE_chesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_chesvxx$handle() {
        return LAPACKE_chesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_chesvxx$address() {
        return LAPACKE_chesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_chesvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_chesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chesvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhesvxx$descriptor() {
        return LAPACKE_zhesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zhesvxx$handle() {
        return LAPACKE_zhesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zhesvxx$address() {
        return LAPACKE_zhesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhesvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zhesvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zhesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhesvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrd$descriptor() {
        return LAPACKE_chetrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chetrd$handle() {
        return LAPACKE_chetrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chetrd$address() {
        return LAPACKE_chetrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrd(int matrix_layout, char uplo, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chetrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chetrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrd$descriptor() {
        return LAPACKE_zhetrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhetrd$handle() {
        return LAPACKE_zhetrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhetrd$address() {
        return LAPACKE_zhetrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrd(int matrix_layout, char uplo, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhetrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhetrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrf$descriptor() {
        return LAPACKE_chetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetrf$handle() {
        return LAPACKE_chetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetrf$address() {
        return LAPACKE_chetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_chetrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrf$descriptor() {
        return LAPACKE_zhetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetrf$handle() {
        return LAPACKE_zhetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetrf$address() {
        return LAPACKE_zhetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zhetrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetri$descriptor() {
        return LAPACKE_chetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chetri$handle() {
        return LAPACKE_chetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chetri$address() {
        return LAPACKE_chetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_chetri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_chetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetri$descriptor() {
        return LAPACKE_zhetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhetri$handle() {
        return LAPACKE_zhetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhetri$address() {
        return LAPACKE_zhetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhetri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chetrs$descriptor() {
        return LAPACKE_chetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chetrs$handle() {
        return LAPACKE_chetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chetrs$address() {
        return LAPACKE_chetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chetrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chetrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhetrs$descriptor() {
        return LAPACKE_zhetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhetrs$handle() {
        return LAPACKE_zhetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhetrs$address() {
        return LAPACKE_zhetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhetrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhetrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhetrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_chfrk$descriptor() {
        return LAPACKE_chfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MethodHandle LAPACKE_chfrk$handle() {
        return LAPACKE_chfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static MemorySegment LAPACKE_chfrk$address() {
        return LAPACKE_chfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const _Complex float *a, int lda, float beta, _Complex float *c)
     * }
     */
    public static int LAPACKE_chfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_chfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhfrk$descriptor() {
        return LAPACKE_zhfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MethodHandle LAPACKE_zhfrk$handle() {
        return LAPACKE_zhfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static MemorySegment LAPACKE_zhfrk$address() {
        return LAPACKE_zhfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const _Complex double *a, int lda, double beta, _Complex double *c)
     * }
     */
    public static int LAPACKE_zhfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_zhfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_shgeqz$descriptor() {
        return LAPACKE_shgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_shgeqz$handle() {
        return LAPACKE_shgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_shgeqz$address() {
        return LAPACKE_shgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, float *h, int ldh, float *t, int ldt, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_shgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_shgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhgeqz$descriptor() {
        return LAPACKE_dhgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dhgeqz$handle() {
        return LAPACKE_dhgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dhgeqz$address() {
        return LAPACKE_dhgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, double *h, int ldh, double *t, int ldt, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dhgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dhgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alphar, alphai, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chgeqz$descriptor() {
        return LAPACKE_chgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chgeqz$handle() {
        return LAPACKE_chgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chgeqz$address() {
        return LAPACKE_chgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *t, int ldt, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhgeqz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhgeqz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhgeqz$descriptor() {
        return LAPACKE_zhgeqz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhgeqz$handle() {
        return LAPACKE_zhgeqz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhgeqz$address() {
        return LAPACKE_zhgeqz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhgeqz(int matrix_layout, char job, char compq, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *t, int ldt, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhgeqz(int matrix_layout, byte job, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment t, int ldt, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhgeqz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhgeqz", matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, compz, n, ilo, ihi, h, ldh, t, ldt, alpha, beta, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpcon$descriptor() {
        return LAPACKE_chpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_chpcon$handle() {
        return LAPACKE_chpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_chpcon$address() {
        return LAPACKE_chpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_chpcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_chpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpcon$descriptor() {
        return LAPACKE_zhpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zhpcon$handle() {
        return LAPACKE_zhpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zhpcon$address() {
        return LAPACKE_zhpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zhpcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zhpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpev$descriptor() {
        return LAPACKE_chpev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpev$handle() {
        return LAPACKE_chpev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpev$address() {
        return LAPACKE_chpev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpev(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpev$descriptor() {
        return LAPACKE_zhpev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpev$handle() {
        return LAPACKE_zhpev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpev$address() {
        return LAPACKE_zhpev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpev(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevd$descriptor() {
        return LAPACKE_chpevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpevd$handle() {
        return LAPACKE_chpevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpevd$address() {
        return LAPACKE_chpevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevd(int matrix_layout, char jobz, char uplo, int n, _Complex float *ap, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevd$descriptor() {
        return LAPACKE_zhpevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpevd$handle() {
        return LAPACKE_zhpevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpevd$address() {
        return LAPACKE_zhpevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevd(int matrix_layout, char jobz, char uplo, int n, _Complex double *ap, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpevx$descriptor() {
        return LAPACKE_chpevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpevx$handle() {
        return LAPACKE_chpevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpevx$address() {
        return LAPACKE_chpevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chpevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chpevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpevx$descriptor() {
        return LAPACKE_zhpevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpevx$handle() {
        return LAPACKE_zhpevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpevx$address() {
        return LAPACKE_zhpevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpevx(int matrix_layout, char jobz, char range, char uplo, int n, _Complex double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhpevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgst$descriptor() {
        return LAPACKE_chpgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MethodHandle LAPACKE_chpgst$handle() {
        return LAPACKE_chpgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static MemorySegment LAPACKE_chpgst$address() {
        return LAPACKE_chpgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgst(int matrix_layout, int itype, char uplo, int n, _Complex float *ap, const _Complex float *bp)
     * }
     */
    public static int LAPACKE_chpgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_chpgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgst$descriptor() {
        return LAPACKE_zhpgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MethodHandle LAPACKE_zhpgst$handle() {
        return LAPACKE_zhpgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static MemorySegment LAPACKE_zhpgst$address() {
        return LAPACKE_zhpgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgst(int matrix_layout, int itype, char uplo, int n, _Complex double *ap, const _Complex double *bp)
     * }
     */
    public static int LAPACKE_zhpgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_zhpgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgv$descriptor() {
        return LAPACKE_chpgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpgv$handle() {
        return LAPACKE_chpgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpgv$address() {
        return LAPACKE_chpgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgv$descriptor() {
        return LAPACKE_zhpgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpgv$handle() {
        return LAPACKE_zhpgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpgv$address() {
        return LAPACKE_zhpgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgv(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvd$descriptor() {
        return LAPACKE_chpgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chpgvd$handle() {
        return LAPACKE_chpgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chpgvd$address() {
        return LAPACKE_chpgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex float *ap, _Complex float *bp, float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chpgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chpgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvd$descriptor() {
        return LAPACKE_zhpgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvd$handle() {
        return LAPACKE_zhpgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvd$address() {
        return LAPACKE_zhpgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvd(int matrix_layout, int itype, char jobz, char uplo, int n, _Complex double *ap, _Complex double *bp, double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhpgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhpgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpgvx$descriptor() {
        return LAPACKE_chpgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_chpgvx$handle() {
        return LAPACKE_chpgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_chpgvx$address() {
        return LAPACKE_chpgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex float *ap, _Complex float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_chpgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_chpgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpgvx$descriptor() {
        return LAPACKE_zhpgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_zhpgvx$handle() {
        return LAPACKE_zhpgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_zhpgvx$address() {
        return LAPACKE_zhpgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, _Complex double *ap, _Complex double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_zhpgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_zhpgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chprfs$descriptor() {
        return LAPACKE_chprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chprfs$handle() {
        return LAPACKE_chprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chprfs$address() {
        return LAPACKE_chprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhprfs$descriptor() {
        return LAPACKE_zhprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhprfs$handle() {
        return LAPACKE_zhprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhprfs$address() {
        return LAPACKE_zhprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsv$descriptor() {
        return LAPACKE_chpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chpsv$handle() {
        return LAPACKE_chpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chpsv$address() {
        return LAPACKE_chpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chpsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsv$descriptor() {
        return LAPACKE_zhpsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhpsv$handle() {
        return LAPACKE_zhpsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhpsv$address() {
        return LAPACKE_zhpsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhpsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhpsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chpsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chpsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chpsvx$descriptor() {
        return LAPACKE_chpsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_chpsvx$handle() {
        return LAPACKE_chpsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_chpsvx$address() {
        return LAPACKE_chpsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_chpsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_chpsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chpsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhpsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhpsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhpsvx$descriptor() {
        return LAPACKE_zhpsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zhpsvx$handle() {
        return LAPACKE_zhpsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zhpsvx$address() {
        return LAPACKE_zhpsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhpsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zhpsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zhpsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhpsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrd$descriptor() {
        return LAPACKE_chptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_chptrd$handle() {
        return LAPACKE_chptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_chptrd$address() {
        return LAPACKE_chptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrd(int matrix_layout, char uplo, int n, _Complex float *ap, float *d, float *e, _Complex float *tau)
     * }
     */
    public static int LAPACKE_chptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_chptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrd$descriptor() {
        return LAPACKE_zhptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zhptrd$handle() {
        return LAPACKE_zhptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zhptrd$address() {
        return LAPACKE_zhptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrd(int matrix_layout, char uplo, int n, _Complex double *ap, double *d, double *e, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zhptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_zhptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrf$descriptor() {
        return LAPACKE_chptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptrf$handle() {
        return LAPACKE_chptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptrf$address() {
        return LAPACKE_chptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_chptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrf$descriptor() {
        return LAPACKE_zhptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptrf$handle() {
        return LAPACKE_zhptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptrf$address() {
        return LAPACKE_zhptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zhptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptri$descriptor() {
        return LAPACKE_chptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_chptri$handle() {
        return LAPACKE_chptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_chptri$address() {
        return LAPACKE_chptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_chptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_chptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptri$descriptor() {
        return LAPACKE_zhptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zhptri$handle() {
        return LAPACKE_zhptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zhptri$address() {
        return LAPACKE_zhptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_zhptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zhptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_chptrs$descriptor() {
        return LAPACKE_chptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_chptrs$handle() {
        return LAPACKE_chptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_chptrs$address() {
        return LAPACKE_chptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_chptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_chptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhptrs$descriptor() {
        return LAPACKE_zhptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zhptrs$handle() {
        return LAPACKE_zhptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zhptrs$address() {
        return LAPACKE_zhptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zhptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zhptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_shsein$descriptor() {
        return LAPACKE_shsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_shsein$handle() {
        return LAPACKE_shsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_shsein$address() {
        return LAPACKE_shsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const float *h, int ldh, float *wr, const float *wi, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_shsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_shsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhsein$descriptor() {
        return LAPACKE_dhsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_dhsein$handle() {
        return LAPACKE_dhsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_dhsein$address() {
        return LAPACKE_dhsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhsein(int matrix_layout, char job, char eigsrc, char initv, int *select, int n, const double *h, int ldh, double *wr, const double *wi, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_dhsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_dhsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, wr, wi, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_chsein$descriptor() {
        return LAPACKE_chsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_chsein$handle() {
        return LAPACKE_chsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_chsein$address() {
        return LAPACKE_chsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex float *h, int ldh, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_chsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_chsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhsein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhsein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhsein$descriptor() {
        return LAPACKE_zhsein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MethodHandle LAPACKE_zhsein$handle() {
        return LAPACKE_zhsein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static MemorySegment LAPACKE_zhsein$address() {
        return LAPACKE_zhsein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhsein(int matrix_layout, char job, char eigsrc, char initv, const int *select, int n, const _Complex double *h, int ldh, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m, int *ifaill, int *ifailr)
     * }
     */
    public static int LAPACKE_zhsein(int matrix_layout, byte job, byte eigsrc, byte initv, MemorySegment select, int n, MemorySegment h, int ldh, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m, MemorySegment ifaill, MemorySegment ifailr) {
        var mh$ = LAPACKE_zhsein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhsein", matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
            }
            return (int)mh$.invokeExact(matrix_layout, job, eigsrc, initv, select, n, h, ldh, w, vl, ldvl, vr, ldvr, mm, m, ifaill, ifailr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_shseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_shseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_shseqr$descriptor() {
        return LAPACKE_shseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_shseqr$handle() {
        return LAPACKE_shseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_shseqr$address() {
        return LAPACKE_shseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_shseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, float *h, int ldh, float *wr, float *wi, float *z, int ldz)
     * }
     */
    public static int LAPACKE_shseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_shseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_shseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dhseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dhseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dhseqr$descriptor() {
        return LAPACKE_dhseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dhseqr$handle() {
        return LAPACKE_dhseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dhseqr$address() {
        return LAPACKE_dhseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, double *h, int ldh, double *wr, double *wi, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dhseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment wr, MemorySegment wi, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dhseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dhseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, wr, wi, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_chseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_chseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_chseqr$descriptor() {
        return LAPACKE_chseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_chseqr$handle() {
        return LAPACKE_chseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_chseqr$address() {
        return LAPACKE_chseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_chseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex float *h, int ldh, _Complex float *w, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_chseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_chseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_chseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zhseqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zhseqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zhseqr$descriptor() {
        return LAPACKE_zhseqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zhseqr$handle() {
        return LAPACKE_zhseqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zhseqr$address() {
        return LAPACKE_zhseqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zhseqr(int matrix_layout, char job, char compz, int n, int ilo, int ihi, _Complex double *h, int ldh, _Complex double *w, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zhseqr(int matrix_layout, byte job, byte compz, int n, int ilo, int ihi, MemorySegment h, int ldh, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zhseqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zhseqr", matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compz, n, ilo, ihi, h, ldh, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacgv$descriptor() {
        return LAPACKE_clacgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_clacgv$handle() {
        return LAPACKE_clacgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_clacgv$address() {
        return LAPACKE_clacgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacgv(int n, _Complex float *x, int incx)
     * }
     */
    public static int LAPACKE_clacgv(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_clacgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacgv", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacgv$descriptor() {
        return LAPACKE_zlacgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlacgv$handle() {
        return LAPACKE_zlacgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlacgv$address() {
        return LAPACKE_zlacgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacgv(int n, _Complex double *x, int incx)
     * }
     */
    public static int LAPACKE_zlacgv(int n, MemorySegment x, int incx) {
        var mh$ = LAPACKE_zlacgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacgv", n, x, incx);
            }
            return (int)mh$.invokeExact(n, x, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacn2$descriptor() {
        return LAPACKE_slacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_slacn2$handle() {
        return LAPACKE_slacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_slacn2$address() {
        return LAPACKE_slacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacn2(int n, float *v, float *x, int *isgn, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_slacn2(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_slacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacn2", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacn2$descriptor() {
        return LAPACKE_dlacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_dlacn2$handle() {
        return LAPACKE_dlacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_dlacn2$address() {
        return LAPACKE_dlacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacn2(int n, double *v, double *x, int *isgn, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_dlacn2(int n, MemorySegment v, MemorySegment x, MemorySegment isgn, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_dlacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacn2", n, v, x, isgn, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, isgn, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacn2$descriptor() {
        return LAPACKE_clacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_clacn2$handle() {
        return LAPACKE_clacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_clacn2$address() {
        return LAPACKE_clacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacn2(int n, _Complex float *v, _Complex float *x, float *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_clacn2(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_clacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacn2", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacn2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacn2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacn2$descriptor() {
        return LAPACKE_zlacn2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MethodHandle LAPACKE_zlacn2$handle() {
        return LAPACKE_zlacn2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static MemorySegment LAPACKE_zlacn2$address() {
        return LAPACKE_zlacn2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacn2(int n, _Complex double *v, _Complex double *x, double *est, int *kase, int *isave)
     * }
     */
    public static int LAPACKE_zlacn2(int n, MemorySegment v, MemorySegment x, MemorySegment est, MemorySegment kase, MemorySegment isave) {
        var mh$ = LAPACKE_zlacn2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacn2", n, v, x, est, kase, isave);
            }
            return (int)mh$.invokeExact(n, v, x, est, kase, isave);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_slacpy$descriptor() {
        return LAPACKE_slacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_slacpy$handle() {
        return LAPACKE_slacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_slacpy$address() {
        return LAPACKE_slacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slacpy(int matrix_layout, char uplo, int m, int n, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_slacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_slacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlacpy$descriptor() {
        return LAPACKE_dlacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dlacpy$handle() {
        return LAPACKE_dlacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dlacpy$address() {
        return LAPACKE_dlacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlacpy(int matrix_layout, char uplo, int m, int n, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dlacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dlacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacpy$descriptor() {
        return LAPACKE_clacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacpy$handle() {
        return LAPACKE_clacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacpy$address() {
        return LAPACKE_clacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacpy(int matrix_layout, char uplo, int m, int n, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacpy$descriptor() {
        return LAPACKE_zlacpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacpy$handle() {
        return LAPACKE_zlacpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacpy$address() {
        return LAPACKE_zlacpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacpy(int matrix_layout, char uplo, int m, int n, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacpy(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacpy", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacp2$descriptor() {
        return LAPACKE_clacp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_clacp2$handle() {
        return LAPACKE_clacp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_clacp2$address() {
        return LAPACKE_clacp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacp2(int matrix_layout, char uplo, int m, int n, const float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_clacp2(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_clacp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacp2", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacp2$descriptor() {
        return LAPACKE_zlacp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zlacp2$handle() {
        return LAPACKE_zlacp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zlacp2$address() {
        return LAPACKE_zlacp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacp2(int matrix_layout, char uplo, int m, int n, const double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zlacp2(int matrix_layout, byte uplo, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zlacp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacp2", matrix_layout, uplo, m, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlag2c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlag2c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlag2c$descriptor() {
        return LAPACKE_zlag2c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_zlag2c$handle() {
        return LAPACKE_zlag2c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_zlag2c$address() {
        return LAPACKE_zlag2c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlag2c(int matrix_layout, int m, int n, const _Complex double *a, int lda, _Complex float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_zlag2c(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_zlag2c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlag2c", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slag2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slag2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slag2d$descriptor() {
        return LAPACKE_slag2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slag2d$handle() {
        return LAPACKE_slag2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slag2d$address() {
        return LAPACKE_slag2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slag2d(int matrix_layout, int m, int n, const float *sa, int ldsa, double *a, int lda)
     * }
     */
    public static int LAPACKE_slag2d(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slag2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slag2d", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlag2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlag2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlag2s$descriptor() {
        return LAPACKE_dlag2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MethodHandle LAPACKE_dlag2s$handle() {
        return LAPACKE_dlag2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static MemorySegment LAPACKE_dlag2s$address() {
        return LAPACKE_dlag2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlag2s(int matrix_layout, int m, int n, const double *a, int lda, float *sa, int ldsa)
     * }
     */
    public static int LAPACKE_dlag2s(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment sa, int ldsa) {
        var mh$ = LAPACKE_dlag2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlag2s", matrix_layout, m, n, a, lda, sa, ldsa);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, sa, ldsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clag2z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clag2z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clag2z$descriptor() {
        return LAPACKE_clag2z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clag2z$handle() {
        return LAPACKE_clag2z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clag2z$address() {
        return LAPACKE_clag2z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clag2z(int matrix_layout, int m, int n, const _Complex float *sa, int ldsa, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_clag2z(int matrix_layout, int m, int n, MemorySegment sa, int ldsa, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clag2z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clag2z", matrix_layout, m, n, sa, ldsa, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, sa, ldsa, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_slagge$descriptor() {
        return LAPACKE_slagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_slagge$handle() {
        return LAPACKE_slagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_slagge$address() {
        return LAPACKE_slagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_slagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_slagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlagge$descriptor() {
        return LAPACKE_dlagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_dlagge$handle() {
        return LAPACKE_dlagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_dlagge$address() {
        return LAPACKE_dlagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_dlagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_dlagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_clagge$descriptor() {
        return LAPACKE_clagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_clagge$handle() {
        return LAPACKE_clagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_clagge$address() {
        return LAPACKE_clagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, const float *d, _Complex float *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_clagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_clagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlagge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlagge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlagge$descriptor() {
        return LAPACKE_zlagge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MethodHandle LAPACKE_zlagge$handle() {
        return LAPACKE_zlagge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static MemorySegment LAPACKE_zlagge$address() {
        return LAPACKE_zlagge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, const double *d, _Complex double *a, int lda, int *iseed)
     * }
     */
    public static int LAPACKE_zlagge(int matrix_layout, int m, int n, int kl, int ku, MemorySegment d, MemorySegment a, int lda, MemorySegment iseed) {
        var mh$ = LAPACKE_zlagge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlagge", matrix_layout, m, n, kl, ku, d, a, lda, iseed);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, d, a, lda, iseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slamch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_CHAR
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slamch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_slamch$descriptor() {
        return LAPACKE_slamch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_slamch$handle() {
        return LAPACKE_slamch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_slamch$address() {
        return LAPACKE_slamch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slamch(char cmach)
     * }
     */
    public static float LAPACKE_slamch(byte cmach) {
        var mh$ = LAPACKE_slamch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slamch", cmach);
            }
            return (float)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlamch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_CHAR
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlamch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlamch$descriptor() {
        return LAPACKE_dlamch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static MethodHandle LAPACKE_dlamch$handle() {
        return LAPACKE_dlamch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static MemorySegment LAPACKE_dlamch$address() {
        return LAPACKE_dlamch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlamch(char cmach)
     * }
     */
    public static double LAPACKE_dlamch(byte cmach) {
        var mh$ = LAPACKE_dlamch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlamch", cmach);
            }
            return (double)mh$.invokeExact(cmach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slange$descriptor() {
        return LAPACKE_slange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slange$handle() {
        return LAPACKE_slange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slange$address() {
        return LAPACKE_slange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slange(int matrix_layout, char norm, int m, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slange", matrix_layout, norm, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlange$descriptor() {
        return LAPACKE_dlange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlange$handle() {
        return LAPACKE_dlange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlange$address() {
        return LAPACKE_dlange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlange(int matrix_layout, char norm, int m, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlange", matrix_layout, norm, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clange$descriptor() {
        return LAPACKE_clange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clange$handle() {
        return LAPACKE_clange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clange$address() {
        return LAPACKE_clange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clange(int matrix_layout, char norm, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clange", matrix_layout, norm, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlange$descriptor() {
        return LAPACKE_zlange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlange$handle() {
        return LAPACKE_zlange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlange$address() {
        return LAPACKE_zlange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlange(int matrix_layout, char norm, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlange(int matrix_layout, byte norm, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlange", matrix_layout, norm, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clanhe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clanhe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clanhe$descriptor() {
        return LAPACKE_clanhe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clanhe$handle() {
        return LAPACKE_clanhe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clanhe$address() {
        return LAPACKE_clanhe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clanhe(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clanhe(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clanhe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clanhe", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlanhe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlanhe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlanhe$descriptor() {
        return LAPACKE_zlanhe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlanhe$handle() {
        return LAPACKE_zlanhe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlanhe$address() {
        return LAPACKE_zlanhe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlanhe(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlanhe(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlanhe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlanhe", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clacrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clacrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clacrm$descriptor() {
        return LAPACKE_clacrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clacrm$handle() {
        return LAPACKE_clacrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clacrm$address() {
        return LAPACKE_clacrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clacrm(int matrix_layout, int m, int n, const _Complex float *a, int lda, const float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clacrm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clacrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clacrm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlacrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlacrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlacrm$descriptor() {
        return LAPACKE_zlacrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlacrm$handle() {
        return LAPACKE_zlacrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlacrm$address() {
        return LAPACKE_zlacrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlacrm(int matrix_layout, int m, int n, const _Complex double *a, int lda, const double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlacrm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlacrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlacrm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarcm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarcm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarcm$descriptor() {
        return LAPACKE_clarcm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clarcm$handle() {
        return LAPACKE_clarcm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clarcm$address() {
        return LAPACKE_clarcm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarcm(int matrix_layout, int m, int n, const float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clarcm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clarcm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarcm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarcm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarcm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarcm$descriptor() {
        return LAPACKE_zlarcm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlarcm$handle() {
        return LAPACKE_zlarcm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlarcm$address() {
        return LAPACKE_zlarcm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarcm(int matrix_layout, int m, int n, const double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlarcm(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlarcm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarcm", matrix_layout, m, n, a, lda, b, ldb, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, b, ldb, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slansy$descriptor() {
        return LAPACKE_slansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slansy$handle() {
        return LAPACKE_slansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slansy$address() {
        return LAPACKE_slansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slansy(int matrix_layout, char norm, char uplo, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlansy$descriptor() {
        return LAPACKE_dlansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlansy$handle() {
        return LAPACKE_dlansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlansy$address() {
        return LAPACKE_dlansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlansy(int matrix_layout, char norm, char uplo, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clansy$descriptor() {
        return LAPACKE_clansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clansy$handle() {
        return LAPACKE_clansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clansy$address() {
        return LAPACKE_clansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clansy(int matrix_layout, char norm, char uplo, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlansy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlansy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlansy$descriptor() {
        return LAPACKE_zlansy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlansy$handle() {
        return LAPACKE_zlansy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlansy$address() {
        return LAPACKE_zlansy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlansy(int matrix_layout, char norm, char uplo, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlansy(int matrix_layout, byte norm, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlansy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlansy", matrix_layout, norm, uplo, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slantr$descriptor() {
        return LAPACKE_slantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slantr$handle() {
        return LAPACKE_slantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slantr$address() {
        return LAPACKE_slantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_slantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const float *a, int lda)
     * }
     */
    public static float LAPACKE_slantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlantr$descriptor() {
        return LAPACKE_dlantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlantr$handle() {
        return LAPACKE_dlantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlantr$address() {
        return LAPACKE_dlantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_dlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const double *a, int lda)
     * }
     */
    public static double LAPACKE_dlantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clantr$descriptor() {
        return LAPACKE_clantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clantr$handle() {
        return LAPACKE_clantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clantr$address() {
        return LAPACKE_clantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float LAPACKE_clantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex float *a, int lda)
     * }
     */
    public static float LAPACKE_clantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (float)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlantr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlantr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlantr$descriptor() {
        return LAPACKE_zlantr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlantr$handle() {
        return LAPACKE_zlantr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlantr$address() {
        return LAPACKE_zlantr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double LAPACKE_zlantr(int matrix_layout, char norm, char uplo, char diag, int m, int n, const _Complex double *a, int lda)
     * }
     */
    public static double LAPACKE_zlantr(int matrix_layout, byte norm, byte uplo, byte diag, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlantr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlantr", matrix_layout, norm, uplo, diag, m, n, a, lda);
            }
            return (double)mh$.invokeExact(matrix_layout, norm, uplo, diag, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfb$descriptor() {
        return LAPACKE_slarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_slarfb$handle() {
        return LAPACKE_slarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_slarfb$address() {
        return LAPACKE_slarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const float *v, int ldv, const float *t, int ldt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_slarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_slarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfb$descriptor() {
        return LAPACKE_dlarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dlarfb$handle() {
        return LAPACKE_dlarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dlarfb$address() {
        return LAPACKE_dlarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const double *v, int ldv, const double *t, int ldt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dlarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dlarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfb$descriptor() {
        return LAPACKE_clarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_clarfb$handle() {
        return LAPACKE_clarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_clarfb$address() {
        return LAPACKE_clarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex float *v, int ldv, const _Complex float *t, int ldt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_clarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_clarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfb$descriptor() {
        return LAPACKE_zlarfb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zlarfb$handle() {
        return LAPACKE_zlarfb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zlarfb$address() {
        return LAPACKE_zlarfb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfb(int matrix_layout, char side, char trans, char direct, char storev, int m, int n, int k, const _Complex double *v, int ldv, const _Complex double *t, int ldt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zlarfb(int matrix_layout, byte side, byte trans, byte direct, byte storev, int m, int n, int k, MemorySegment v, int ldv, MemorySegment t, int ldt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zlarfb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfb", matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, direct, storev, m, n, k, v, ldv, t, ldt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfg$descriptor() {
        return LAPACKE_slarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_slarfg$handle() {
        return LAPACKE_slarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_slarfg$address() {
        return LAPACKE_slarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfg(int n, float *alpha, float *x, int incx, float *tau)
     * }
     */
    public static int LAPACKE_slarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_slarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfg$descriptor() {
        return LAPACKE_dlarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dlarfg$handle() {
        return LAPACKE_dlarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dlarfg$address() {
        return LAPACKE_dlarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfg(int n, double *alpha, double *x, int incx, double *tau)
     * }
     */
    public static int LAPACKE_dlarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_dlarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfg$descriptor() {
        return LAPACKE_clarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_clarfg$handle() {
        return LAPACKE_clarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_clarfg$address() {
        return LAPACKE_clarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfg(int n, _Complex float *alpha, _Complex float *x, int incx, _Complex float *tau)
     * }
     */
    public static int LAPACKE_clarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_clarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfg$descriptor() {
        return LAPACKE_zlarfg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zlarfg$handle() {
        return LAPACKE_zlarfg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zlarfg$address() {
        return LAPACKE_zlarfg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfg(int n, _Complex double *alpha, _Complex double *x, int incx, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zlarfg(int n, MemorySegment alpha, MemorySegment x, int incx, MemorySegment tau) {
        var mh$ = LAPACKE_zlarfg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfg", n, alpha, x, incx, tau);
            }
            return (int)mh$.invokeExact(n, alpha, x, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarft$descriptor() {
        return LAPACKE_slarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_slarft$handle() {
        return LAPACKE_slarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_slarft$address() {
        return LAPACKE_slarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarft(int matrix_layout, char direct, char storev, int n, int k, const float *v, int ldv, const float *tau, float *t, int ldt)
     * }
     */
    public static int LAPACKE_slarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_slarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarft$descriptor() {
        return LAPACKE_dlarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dlarft$handle() {
        return LAPACKE_dlarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dlarft$address() {
        return LAPACKE_dlarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarft(int matrix_layout, char direct, char storev, int n, int k, const double *v, int ldv, const double *tau, double *t, int ldt)
     * }
     */
    public static int LAPACKE_dlarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dlarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarft$descriptor() {
        return LAPACKE_clarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_clarft$handle() {
        return LAPACKE_clarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_clarft$address() {
        return LAPACKE_clarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex float *v, int ldv, const _Complex float *tau, _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_clarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_clarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarft$descriptor() {
        return LAPACKE_zlarft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zlarft$handle() {
        return LAPACKE_zlarft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zlarft$address() {
        return LAPACKE_zlarft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarft(int matrix_layout, char direct, char storev, int n, int k, const _Complex double *v, int ldv, const _Complex double *tau, _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zlarft(int matrix_layout, byte direct, byte storev, int n, int k, MemorySegment v, int ldv, MemorySegment tau, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zlarft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarft", matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, direct, storev, n, k, v, ldv, tau, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarfx$descriptor() {
        return LAPACKE_slarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_slarfx$handle() {
        return LAPACKE_slarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_slarfx$address() {
        return LAPACKE_slarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarfx(int matrix_layout, char side, int m, int n, const float *v, float tau, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_slarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_slarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarfx$descriptor() {
        return LAPACKE_dlarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dlarfx$handle() {
        return LAPACKE_dlarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dlarfx$address() {
        return LAPACKE_dlarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarfx(int matrix_layout, char side, int m, int n, const double *v, double tau, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dlarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dlarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarfx$descriptor() {
        return LAPACKE_clarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_clarfx$handle() {
        return LAPACKE_clarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_clarfx$address() {
        return LAPACKE_clarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarfx(int matrix_layout, char side, int m, int n, const _Complex float *v, _Complex float tau, _Complex float *c, int ldc, _Complex float *work)
     * }
     */
    public static int LAPACKE_clarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, float tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_clarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarfx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarfx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarfx$descriptor() {
        return LAPACKE_zlarfx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zlarfx$handle() {
        return LAPACKE_zlarfx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zlarfx$address() {
        return LAPACKE_zlarfx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarfx(int matrix_layout, char side, int m, int n, const _Complex double *v, _Complex double tau, _Complex double *c, int ldc, _Complex double *work)
     * }
     */
    public static int LAPACKE_zlarfx(int matrix_layout, byte side, int m, int n, MemorySegment v, double tau, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zlarfx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarfx", matrix_layout, side, m, n, v, tau, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, side, m, n, v, tau, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_slarnv$descriptor() {
        return LAPACKE_slarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MethodHandle LAPACKE_slarnv$handle() {
        return LAPACKE_slarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static MemorySegment LAPACKE_slarnv$address() {
        return LAPACKE_slarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slarnv(int idist, int *iseed, int n, float *x)
     * }
     */
    public static int LAPACKE_slarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_slarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlarnv$descriptor() {
        return LAPACKE_dlarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dlarnv$handle() {
        return LAPACKE_dlarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dlarnv$address() {
        return LAPACKE_dlarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlarnv(int idist, int *iseed, int n, double *x)
     * }
     */
    public static int LAPACKE_dlarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_dlarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_clarnv$descriptor() {
        return LAPACKE_clarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_clarnv$handle() {
        return LAPACKE_clarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_clarnv$address() {
        return LAPACKE_clarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clarnv(int idist, int *iseed, int n, _Complex float *x)
     * }
     */
    public static int LAPACKE_clarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_clarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlarnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlarnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlarnv$descriptor() {
        return LAPACKE_zlarnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zlarnv$handle() {
        return LAPACKE_zlarnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zlarnv$address() {
        return LAPACKE_zlarnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlarnv(int idist, int *iseed, int n, _Complex double *x)
     * }
     */
    public static int LAPACKE_zlarnv(int idist, MemorySegment iseed, int n, MemorySegment x) {
        var mh$ = LAPACKE_zlarnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlarnv", idist, iseed, n, x);
            }
            return (int)mh$.invokeExact(idist, iseed, n, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slascl$descriptor() {
        return LAPACKE_slascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slascl$handle() {
        return LAPACKE_slascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slascl$address() {
        return LAPACKE_slascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slascl(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlascl$descriptor() {
        return LAPACKE_dlascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlascl$handle() {
        return LAPACKE_dlascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlascl$address() {
        return LAPACKE_dlascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlascl(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clascl$descriptor() {
        return LAPACKE_clascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clascl$handle() {
        return LAPACKE_clascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clascl$address() {
        return LAPACKE_clascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clascl(int matrix_layout, char type, int kl, int ku, float cfrom, float cto, int m, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clascl(int matrix_layout, byte type, int kl, int ku, float cfrom, float cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlascl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlascl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlascl$descriptor() {
        return LAPACKE_zlascl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlascl$handle() {
        return LAPACKE_zlascl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlascl$address() {
        return LAPACKE_zlascl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlascl(int matrix_layout, char type, int kl, int ku, double cfrom, double cto, int m, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlascl(int matrix_layout, byte type, int kl, int ku, double cfrom, double cto, int m, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlascl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlascl", matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, type, kl, ku, cfrom, cto, m, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaset$descriptor() {
        return LAPACKE_slaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slaset$handle() {
        return LAPACKE_slaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slaset$address() {
        return LAPACKE_slaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaset(int matrix_layout, char uplo, int m, int n, float alpha, float beta, float *a, int lda)
     * }
     */
    public static int LAPACKE_slaset(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaset$descriptor() {
        return LAPACKE_dlaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlaset$handle() {
        return LAPACKE_dlaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlaset$address() {
        return LAPACKE_dlaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaset(int matrix_layout, char uplo, int m, int n, double alpha, double beta, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlaset(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_claset$descriptor() {
        return LAPACKE_claset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_claset$handle() {
        return LAPACKE_claset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_claset$address() {
        return LAPACKE_claset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claset(int matrix_layout, char uplo, int m, int n, _Complex float alpha, _Complex float beta, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_claset(int matrix_layout, byte uplo, int m, int n, float alpha, float beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_claset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaset$descriptor() {
        return LAPACKE_zlaset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlaset$handle() {
        return LAPACKE_zlaset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlaset$address() {
        return LAPACKE_zlaset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaset(int matrix_layout, char uplo, int m, int n, _Complex double alpha, _Complex double beta, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlaset(int matrix_layout, byte uplo, int m, int n, double alpha, double beta, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlaset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaset", matrix_layout, uplo, m, n, alpha, beta, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, m, n, alpha, beta, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slasrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slasrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_slasrt$descriptor() {
        return LAPACKE_slasrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static MethodHandle LAPACKE_slasrt$handle() {
        return LAPACKE_slasrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static MemorySegment LAPACKE_slasrt$address() {
        return LAPACKE_slasrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slasrt(char id, int n, float *d)
     * }
     */
    public static int LAPACKE_slasrt(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_slasrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slasrt", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlasrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlasrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlasrt$descriptor() {
        return LAPACKE_dlasrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static MethodHandle LAPACKE_dlasrt$handle() {
        return LAPACKE_dlasrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static MemorySegment LAPACKE_dlasrt$address() {
        return LAPACKE_dlasrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlasrt(char id, int n, double *d)
     * }
     */
    public static int LAPACKE_dlasrt(byte id, int n, MemorySegment d) {
        var mh$ = LAPACKE_dlasrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlasrt", id, n, d);
            }
            return (int)mh$.invokeExact(id, n, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_slassq$descriptor() {
        return LAPACKE_slassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_slassq$handle() {
        return LAPACKE_slassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_slassq$address() {
        return LAPACKE_slassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slassq(int n, float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_slassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_slassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlassq$descriptor() {
        return LAPACKE_dlassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_dlassq$handle() {
        return LAPACKE_dlassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_dlassq$address() {
        return LAPACKE_dlassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlassq(int n, double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_dlassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_dlassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_classq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_classq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_classq$descriptor() {
        return LAPACKE_classq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_classq$handle() {
        return LAPACKE_classq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_classq$address() {
        return LAPACKE_classq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_classq(int n, _Complex float *x, int incx, float *scale, float *sumsq)
     * }
     */
    public static int LAPACKE_classq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_classq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_classq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlassq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlassq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlassq$descriptor() {
        return LAPACKE_zlassq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle LAPACKE_zlassq$handle() {
        return LAPACKE_zlassq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment LAPACKE_zlassq$address() {
        return LAPACKE_zlassq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlassq(int n, _Complex double *x, int incx, double *scale, double *sumsq)
     * }
     */
    public static int LAPACKE_zlassq(int n, MemorySegment x, int incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = LAPACKE_zlassq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlassq", n, x, incx, scale, sumsq);
            }
            return (int)mh$.invokeExact(n, x, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_slaswp$descriptor() {
        return LAPACKE_slaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_slaswp$handle() {
        return LAPACKE_slaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_slaswp$address() {
        return LAPACKE_slaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slaswp(int matrix_layout, int n, float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_slaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_slaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlaswp$descriptor() {
        return LAPACKE_dlaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_dlaswp$handle() {
        return LAPACKE_dlaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_dlaswp$address() {
        return LAPACKE_dlaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlaswp(int matrix_layout, int n, double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_dlaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_dlaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_claswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_claswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_claswp$descriptor() {
        return LAPACKE_claswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_claswp$handle() {
        return LAPACKE_claswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_claswp$address() {
        return LAPACKE_claswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_claswp(int matrix_layout, int n, _Complex float *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_claswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_claswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_claswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlaswp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlaswp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlaswp$descriptor() {
        return LAPACKE_zlaswp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MethodHandle LAPACKE_zlaswp$handle() {
        return LAPACKE_zlaswp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static MemorySegment LAPACKE_zlaswp$address() {
        return LAPACKE_zlaswp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlaswp(int matrix_layout, int n, _Complex double *a, int lda, int k1, int k2, const int *ipiv, int incx)
     * }
     */
    public static int LAPACKE_zlaswp(int matrix_layout, int n, MemorySegment a, int lda, int k1, int k2, MemorySegment ipiv, int incx) {
        var mh$ = LAPACKE_zlaswp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlaswp", matrix_layout, n, a, lda, k1, k2, ipiv, incx);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slatms$descriptor() {
        return LAPACKE_slatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slatms$handle() {
        return LAPACKE_slatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slatms$address() {
        return LAPACKE_slatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, float *a, int lda)
     * }
     */
    public static int LAPACKE_slatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlatms$descriptor() {
        return LAPACKE_dlatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlatms$handle() {
        return LAPACKE_dlatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlatms$address() {
        return LAPACKE_dlatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clatms$descriptor() {
        return LAPACKE_clatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clatms$handle() {
        return LAPACKE_clatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clatms$address() {
        return LAPACKE_clatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, float *d, int mode, float cond, float dmax, int kl, int ku, char pack, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, float cond, float dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlatms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlatms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlatms$descriptor() {
        return LAPACKE_zlatms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlatms$handle() {
        return LAPACKE_zlatms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlatms$address() {
        return LAPACKE_zlatms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlatms(int matrix_layout, int m, int n, char dist, int *iseed, char sym, double *d, int mode, double cond, double dmax, int kl, int ku, char pack, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlatms(int matrix_layout, int m, int n, byte dist, MemorySegment iseed, byte sym, MemorySegment d, int mode, double cond, double dmax, int kl, int ku, byte pack, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlatms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlatms", matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, dist, iseed, sym, d, mode, cond, dmax, kl, ku, pack, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_slauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_slauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_slauum$descriptor() {
        return LAPACKE_slauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_slauum$handle() {
        return LAPACKE_slauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_slauum$address() {
        return LAPACKE_slauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_slauum(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_slauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_slauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_slauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dlauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dlauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dlauum$descriptor() {
        return LAPACKE_dlauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dlauum$handle() {
        return LAPACKE_dlauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dlauum$address() {
        return LAPACKE_dlauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dlauum(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dlauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dlauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dlauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_clauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_clauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_clauum$descriptor() {
        return LAPACKE_clauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_clauum$handle() {
        return LAPACKE_clauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_clauum$address() {
        return LAPACKE_clauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_clauum(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_clauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_clauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_clauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zlauum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zlauum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zlauum$descriptor() {
        return LAPACKE_zlauum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zlauum$handle() {
        return LAPACKE_zlauum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zlauum$address() {
        return LAPACKE_zlauum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zlauum(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zlauum(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zlauum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zlauum", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sopgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopgtr$descriptor() {
        return LAPACKE_sopgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_sopgtr$handle() {
        return LAPACKE_sopgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_sopgtr$address() {
        return LAPACKE_sopgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopgtr(int matrix_layout, char uplo, int n, const float *ap, const float *tau, float *q, int ldq)
     * }
     */
    public static int LAPACKE_sopgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_sopgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dopgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopgtr$descriptor() {
        return LAPACKE_dopgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dopgtr$handle() {
        return LAPACKE_dopgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dopgtr$address() {
        return LAPACKE_dopgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopgtr(int matrix_layout, char uplo, int n, const double *ap, const double *tau, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dopgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dopgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sopmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sopmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sopmtr$descriptor() {
        return LAPACKE_sopmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sopmtr$handle() {
        return LAPACKE_sopmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sopmtr$address() {
        return LAPACKE_sopmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *ap, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sopmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sopmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sopmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dopmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dopmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dopmtr$descriptor() {
        return LAPACKE_dopmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dopmtr$handle() {
        return LAPACKE_dopmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dopmtr$address() {
        return LAPACKE_dopmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dopmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *ap, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dopmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dopmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dopmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgbr$descriptor() {
        return LAPACKE_sorgbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgbr$handle() {
        return LAPACKE_sorgbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgbr$address() {
        return LAPACKE_sorgbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgbr(int matrix_layout, char vect, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgbr$descriptor() {
        return LAPACKE_dorgbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgbr$handle() {
        return LAPACKE_dorgbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgbr$address() {
        return LAPACKE_dorgbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgbr(int matrix_layout, char vect, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorghr$descriptor() {
        return LAPACKE_sorghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorghr$handle() {
        return LAPACKE_sorghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorghr$address() {
        return LAPACKE_sorghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorghr$descriptor() {
        return LAPACKE_dorghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorghr$handle() {
        return LAPACKE_dorghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorghr$address() {
        return LAPACKE_dorghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorglq$descriptor() {
        return LAPACKE_sorglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorglq$handle() {
        return LAPACKE_sorglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorglq$address() {
        return LAPACKE_sorglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorglq$descriptor() {
        return LAPACKE_dorglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorglq$handle() {
        return LAPACKE_dorglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorglq$address() {
        return LAPACKE_dorglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgql$descriptor() {
        return LAPACKE_sorgql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgql$handle() {
        return LAPACKE_sorgql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgql$address() {
        return LAPACKE_sorgql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgql$descriptor() {
        return LAPACKE_dorgql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgql$handle() {
        return LAPACKE_dorgql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgql$address() {
        return LAPACKE_dorgql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgqr$descriptor() {
        return LAPACKE_sorgqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgqr$handle() {
        return LAPACKE_sorgqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgqr$address() {
        return LAPACKE_sorgqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgqr$descriptor() {
        return LAPACKE_dorgqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgqr$handle() {
        return LAPACKE_dorgqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgqr$address() {
        return LAPACKE_dorgqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgrq$descriptor() {
        return LAPACKE_sorgrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgrq$handle() {
        return LAPACKE_sorgrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgrq$address() {
        return LAPACKE_sorgrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgrq$descriptor() {
        return LAPACKE_dorgrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgrq$handle() {
        return LAPACKE_dorgrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgrq$address() {
        return LAPACKE_dorgrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtr$descriptor() {
        return LAPACKE_sorgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sorgtr$handle() {
        return LAPACKE_sorgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sorgtr$address() {
        return LAPACKE_sorgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtr(int matrix_layout, char uplo, int n, float *a, int lda, const float *tau)
     * }
     */
    public static int LAPACKE_sorgtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sorgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtr$descriptor() {
        return LAPACKE_dorgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dorgtr$handle() {
        return LAPACKE_dorgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dorgtr$address() {
        return LAPACKE_dorgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtr(int matrix_layout, char uplo, int n, double *a, int lda, const double *tau)
     * }
     */
    public static int LAPACKE_dorgtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dorgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sorgtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sorgtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sorgtsqr_row$descriptor() {
        return LAPACKE_sorgtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_sorgtsqr_row$handle() {
        return LAPACKE_sorgtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_sorgtsqr_row$address() {
        return LAPACKE_sorgtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, float *a, int lda, const float *t, int ldt)
     * }
     */
    public static int LAPACKE_sorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_sorgtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sorgtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dorgtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dorgtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dorgtsqr_row$descriptor() {
        return LAPACKE_dorgtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_dorgtsqr_row$handle() {
        return LAPACKE_dorgtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_dorgtsqr_row$address() {
        return LAPACKE_dorgtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, double *a, int lda, const double *t, int ldt)
     * }
     */
    public static int LAPACKE_dorgtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_dorgtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dorgtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormbr$descriptor() {
        return LAPACKE_sormbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormbr$handle() {
        return LAPACKE_sormbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormbr$address() {
        return LAPACKE_sormbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormbr$descriptor() {
        return LAPACKE_dormbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormbr$handle() {
        return LAPACKE_dormbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormbr$address() {
        return LAPACKE_dormbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormhr$descriptor() {
        return LAPACKE_sormhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormhr$handle() {
        return LAPACKE_sormhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormhr$address() {
        return LAPACKE_sormhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormhr$descriptor() {
        return LAPACKE_dormhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormhr$handle() {
        return LAPACKE_dormhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormhr$address() {
        return LAPACKE_dormhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormlq$descriptor() {
        return LAPACKE_sormlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormlq$handle() {
        return LAPACKE_sormlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormlq$address() {
        return LAPACKE_sormlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormlq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormlq$descriptor() {
        return LAPACKE_dormlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormlq$handle() {
        return LAPACKE_dormlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormlq$address() {
        return LAPACKE_dormlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormlq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormql$descriptor() {
        return LAPACKE_sormql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormql$handle() {
        return LAPACKE_sormql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormql$address() {
        return LAPACKE_sormql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormql(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormql$descriptor() {
        return LAPACKE_dormql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormql$handle() {
        return LAPACKE_dormql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormql$address() {
        return LAPACKE_dormql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormql(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormqr$descriptor() {
        return LAPACKE_sormqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormqr$handle() {
        return LAPACKE_sormqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormqr$address() {
        return LAPACKE_sormqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormqr(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormqr$descriptor() {
        return LAPACKE_dormqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormqr$handle() {
        return LAPACKE_dormqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormqr$address() {
        return LAPACKE_dormqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormqr(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrq$descriptor() {
        return LAPACKE_sormrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormrq$handle() {
        return LAPACKE_sormrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormrq$address() {
        return LAPACKE_sormrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrq(int matrix_layout, char side, char trans, int m, int n, int k, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrq$descriptor() {
        return LAPACKE_dormrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormrq$handle() {
        return LAPACKE_dormrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormrq$address() {
        return LAPACKE_dormrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrq(int matrix_layout, char side, char trans, int m, int n, int k, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormrz$descriptor() {
        return LAPACKE_sormrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormrz$handle() {
        return LAPACKE_sormrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormrz$address() {
        return LAPACKE_sormrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormrz$descriptor() {
        return LAPACKE_dormrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormrz$handle() {
        return LAPACKE_dormrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormrz$address() {
        return LAPACKE_dormrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sormtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sormtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sormtr$descriptor() {
        return LAPACKE_sormtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sormtr$handle() {
        return LAPACKE_sormtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sormtr$address() {
        return LAPACKE_sormtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const float *a, int lda, const float *tau, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sormtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sormtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sormtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dormtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dormtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dormtr$descriptor() {
        return LAPACKE_dormtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dormtr$handle() {
        return LAPACKE_dormtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dormtr$address() {
        return LAPACKE_dormtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dormtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const double *a, int lda, const double *tau, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dormtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dormtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dormtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbcon$descriptor() {
        return LAPACKE_spbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_spbcon$handle() {
        return LAPACKE_spbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_spbcon$address() {
        return LAPACKE_spbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbcon(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_spbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_spbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbcon$descriptor() {
        return LAPACKE_dpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dpbcon$handle() {
        return LAPACKE_dpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dpbcon$address() {
        return LAPACKE_dpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbcon(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbcon$descriptor() {
        return LAPACKE_cpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cpbcon$handle() {
        return LAPACKE_cpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cpbcon$address() {
        return LAPACKE_cpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbcon$descriptor() {
        return LAPACKE_zpbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zpbcon$handle() {
        return LAPACKE_zpbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zpbcon$address() {
        return LAPACKE_zpbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbcon(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zpbcon(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zpbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbcon", matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbequ$descriptor() {
        return LAPACKE_spbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spbequ$handle() {
        return LAPACKE_spbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spbequ$address() {
        return LAPACKE_spbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbequ(int matrix_layout, char uplo, int n, int kd, const float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbequ$descriptor() {
        return LAPACKE_dpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpbequ$handle() {
        return LAPACKE_dpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpbequ$address() {
        return LAPACKE_dpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbequ(int matrix_layout, char uplo, int n, int kd, const double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbequ$descriptor() {
        return LAPACKE_cpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpbequ$handle() {
        return LAPACKE_cpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpbequ$address() {
        return LAPACKE_cpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex float *ab, int ldab, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbequ$descriptor() {
        return LAPACKE_zpbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpbequ$handle() {
        return LAPACKE_zpbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpbequ$address() {
        return LAPACKE_zpbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbequ(int matrix_layout, char uplo, int n, int kd, const _Complex double *ab, int ldab, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpbequ(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbequ", matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbrfs$descriptor() {
        return LAPACKE_spbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spbrfs$handle() {
        return LAPACKE_spbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spbrfs$address() {
        return LAPACKE_spbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbrfs$descriptor() {
        return LAPACKE_dpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpbrfs$handle() {
        return LAPACKE_dpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpbrfs$address() {
        return LAPACKE_dpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbrfs$descriptor() {
        return LAPACKE_cpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpbrfs$handle() {
        return LAPACKE_cpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpbrfs$address() {
        return LAPACKE_cpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbrfs$descriptor() {
        return LAPACKE_zpbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpbrfs$handle() {
        return LAPACKE_zpbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpbrfs$address() {
        return LAPACKE_zpbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbrfs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpbrfs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbrfs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbstf$descriptor() {
        return LAPACKE_spbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_spbstf$handle() {
        return LAPACKE_spbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_spbstf$address() {
        return LAPACKE_spbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbstf(int matrix_layout, char uplo, int n, int kb, float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_spbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_spbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbstf$descriptor() {
        return LAPACKE_dpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_dpbstf$handle() {
        return LAPACKE_dpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_dpbstf$address() {
        return LAPACKE_dpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbstf(int matrix_layout, char uplo, int n, int kb, double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_dpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_dpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbstf$descriptor() {
        return LAPACKE_cpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_cpbstf$handle() {
        return LAPACKE_cpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_cpbstf$address() {
        return LAPACKE_cpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbstf(int matrix_layout, char uplo, int n, int kb, _Complex float *bb, int ldbb)
     * }
     */
    public static int LAPACKE_cpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_cpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbstf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbstf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbstf$descriptor() {
        return LAPACKE_zpbstf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MethodHandle LAPACKE_zpbstf$handle() {
        return LAPACKE_zpbstf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static MemorySegment LAPACKE_zpbstf$address() {
        return LAPACKE_zpbstf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbstf(int matrix_layout, char uplo, int n, int kb, _Complex double *bb, int ldbb)
     * }
     */
    public static int LAPACKE_zpbstf(int matrix_layout, byte uplo, int n, int kb, MemorySegment bb, int ldbb) {
        var mh$ = LAPACKE_zpbstf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbstf", matrix_layout, uplo, n, kb, bb, ldbb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kb, bb, ldbb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsv$descriptor() {
        return LAPACKE_spbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbsv$handle() {
        return LAPACKE_spbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbsv$address() {
        return LAPACKE_spbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsv$descriptor() {
        return LAPACKE_dpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbsv$handle() {
        return LAPACKE_dpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbsv$address() {
        return LAPACKE_dpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsv$descriptor() {
        return LAPACKE_cpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbsv$handle() {
        return LAPACKE_cpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbsv$address() {
        return LAPACKE_cpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsv$descriptor() {
        return LAPACKE_zpbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbsv$handle() {
        return LAPACKE_zpbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbsv$address() {
        return LAPACKE_zpbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsv(int matrix_layout, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbsv(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsv", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbsvx$descriptor() {
        return LAPACKE_spbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spbsvx$handle() {
        return LAPACKE_spbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spbsvx$address() {
        return LAPACKE_spbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, float *ab, int ldab, float *afb, int ldafb, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbsvx$descriptor() {
        return LAPACKE_dpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpbsvx$handle() {
        return LAPACKE_dpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpbsvx$address() {
        return LAPACKE_dpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, double *ab, int ldab, double *afb, int ldafb, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbsvx$descriptor() {
        return LAPACKE_cpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpbsvx$handle() {
        return LAPACKE_cpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpbsvx$address() {
        return LAPACKE_cpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbsvx$descriptor() {
        return LAPACKE_zpbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpbsvx$handle() {
        return LAPACKE_zpbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpbsvx$address() {
        return LAPACKE_zpbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbsvx(int matrix_layout, char fact, char uplo, int n, int kd, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpbsvx(int matrix_layout, byte fact, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbsvx", matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, kd, nrhs, ab, ldab, afb, ldafb, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrf$descriptor() {
        return LAPACKE_spbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_spbtrf$handle() {
        return LAPACKE_spbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_spbtrf$address() {
        return LAPACKE_spbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrf(int matrix_layout, char uplo, int n, int kd, float *ab, int ldab)
     * }
     */
    public static int LAPACKE_spbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_spbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrf$descriptor() {
        return LAPACKE_dpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrf$handle() {
        return LAPACKE_dpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrf$address() {
        return LAPACKE_dpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrf(int matrix_layout, char uplo, int n, int kd, double *ab, int ldab)
     * }
     */
    public static int LAPACKE_dpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_dpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrf$descriptor() {
        return LAPACKE_cpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrf$handle() {
        return LAPACKE_cpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrf$address() {
        return LAPACKE_cpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex float *ab, int ldab)
     * }
     */
    public static int LAPACKE_cpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_cpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrf$descriptor() {
        return LAPACKE_zpbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrf$handle() {
        return LAPACKE_zpbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrf$address() {
        return LAPACKE_zpbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrf(int matrix_layout, char uplo, int n, int kd, _Complex double *ab, int ldab)
     * }
     */
    public static int LAPACKE_zpbtrf(int matrix_layout, byte uplo, int n, int kd, MemorySegment ab, int ldab) {
        var mh$ = LAPACKE_zpbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrf", matrix_layout, uplo, n, kd, ab, ldab);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, ab, ldab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spbtrs$descriptor() {
        return LAPACKE_spbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spbtrs$handle() {
        return LAPACKE_spbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spbtrs$address() {
        return LAPACKE_spbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpbtrs$descriptor() {
        return LAPACKE_dpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpbtrs$handle() {
        return LAPACKE_dpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpbtrs$address() {
        return LAPACKE_dpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpbtrs$descriptor() {
        return LAPACKE_cpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpbtrs$handle() {
        return LAPACKE_cpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpbtrs$address() {
        return LAPACKE_cpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpbtrs$descriptor() {
        return LAPACKE_zpbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpbtrs$handle() {
        return LAPACKE_zpbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpbtrs$address() {
        return LAPACKE_zpbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpbtrs(int matrix_layout, char uplo, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpbtrs(int matrix_layout, byte uplo, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpbtrs", matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrf$descriptor() {
        return LAPACKE_spftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftrf$handle() {
        return LAPACKE_spftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftrf$address() {
        return LAPACKE_spftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrf(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrf$descriptor() {
        return LAPACKE_dpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftrf$handle() {
        return LAPACKE_dpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftrf$address() {
        return LAPACKE_dpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrf(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrf$descriptor() {
        return LAPACKE_cpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftrf$handle() {
        return LAPACKE_cpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftrf$address() {
        return LAPACKE_cpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrf(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrf$descriptor() {
        return LAPACKE_zpftrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftrf$handle() {
        return LAPACKE_zpftrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftrf$address() {
        return LAPACKE_zpftrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrf(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftrf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrf", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftri$descriptor() {
        return LAPACKE_spftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_spftri$handle() {
        return LAPACKE_spftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_spftri$address() {
        return LAPACKE_spftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftri(int matrix_layout, char transr, char uplo, int n, float *a)
     * }
     */
    public static int LAPACKE_spftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_spftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftri$descriptor() {
        return LAPACKE_dpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dpftri$handle() {
        return LAPACKE_dpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dpftri$address() {
        return LAPACKE_dpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftri(int matrix_layout, char transr, char uplo, int n, double *a)
     * }
     */
    public static int LAPACKE_dpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_dpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftri$descriptor() {
        return LAPACKE_cpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_cpftri$handle() {
        return LAPACKE_cpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_cpftri$address() {
        return LAPACKE_cpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftri(int matrix_layout, char transr, char uplo, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_cpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_cpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftri$descriptor() {
        return LAPACKE_zpftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_zpftri$handle() {
        return LAPACKE_zpftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_zpftri$address() {
        return LAPACKE_zpftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftri(int matrix_layout, char transr, char uplo, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_zpftri(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a) {
        var mh$ = LAPACKE_zpftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftri", matrix_layout, transr, uplo, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spftrs$descriptor() {
        return LAPACKE_spftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spftrs$handle() {
        return LAPACKE_spftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spftrs$address() {
        return LAPACKE_spftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpftrs$descriptor() {
        return LAPACKE_dpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpftrs$handle() {
        return LAPACKE_dpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpftrs$address() {
        return LAPACKE_dpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpftrs$descriptor() {
        return LAPACKE_cpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpftrs$handle() {
        return LAPACKE_cpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpftrs$address() {
        return LAPACKE_cpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpftrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpftrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpftrs$descriptor() {
        return LAPACKE_zpftrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpftrs$handle() {
        return LAPACKE_zpftrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpftrs$address() {
        return LAPACKE_zpftrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpftrs(int matrix_layout, char transr, char uplo, int n, int nrhs, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpftrs(int matrix_layout, byte transr, byte uplo, int n, int nrhs, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpftrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpftrs", matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, nrhs, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_spocon$descriptor() {
        return LAPACKE_spocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_spocon$handle() {
        return LAPACKE_spocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_spocon$address() {
        return LAPACKE_spocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spocon(int matrix_layout, char uplo, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_spocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_spocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpocon$descriptor() {
        return LAPACKE_dpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dpocon$handle() {
        return LAPACKE_dpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dpocon$address() {
        return LAPACKE_dpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpocon(int matrix_layout, char uplo, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpocon$descriptor() {
        return LAPACKE_cpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cpocon$handle() {
        return LAPACKE_cpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cpocon$address() {
        return LAPACKE_cpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpocon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpocon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpocon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpocon$descriptor() {
        return LAPACKE_zpocon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zpocon$handle() {
        return LAPACKE_zpocon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zpocon$address() {
        return LAPACKE_zpocon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpocon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zpocon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zpocon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpocon", matrix_layout, uplo, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequ$descriptor() {
        return LAPACKE_spoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequ$handle() {
        return LAPACKE_spoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequ$address() {
        return LAPACKE_spoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequ(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequ$descriptor() {
        return LAPACKE_dpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequ$handle() {
        return LAPACKE_dpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequ$address() {
        return LAPACKE_dpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequ(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequ$descriptor() {
        return LAPACKE_cpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequ$handle() {
        return LAPACKE_cpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequ$address() {
        return LAPACKE_cpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequ(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpoequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequ$descriptor() {
        return LAPACKE_zpoequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequ$handle() {
        return LAPACKE_zpoequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequ$address() {
        return LAPACKE_zpoequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequ(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequ(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequ", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_spoequb$descriptor() {
        return LAPACKE_spoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_spoequb$handle() {
        return LAPACKE_spoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_spoequb$address() {
        return LAPACKE_spoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spoequb(int matrix_layout, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_spoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_spoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpoequb$descriptor() {
        return LAPACKE_dpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dpoequb$handle() {
        return LAPACKE_dpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dpoequb$address() {
        return LAPACKE_dpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpoequb(int matrix_layout, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpoequb$descriptor() {
        return LAPACKE_cpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cpoequb$handle() {
        return LAPACKE_cpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cpoequb$address() {
        return LAPACKE_cpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpoequb(int matrix_layout, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpoequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpoequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpoequb$descriptor() {
        return LAPACKE_zpoequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zpoequb$handle() {
        return LAPACKE_zpoequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zpoequb$address() {
        return LAPACKE_zpoequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpoequb(int matrix_layout, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zpoequb(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zpoequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpoequb", matrix_layout, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfs$descriptor() {
        return LAPACKE_sporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sporfs$handle() {
        return LAPACKE_sporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sporfs$address() {
        return LAPACKE_sporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfs$descriptor() {
        return LAPACKE_dporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dporfs$handle() {
        return LAPACKE_dporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dporfs$address() {
        return LAPACKE_dporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfs$descriptor() {
        return LAPACKE_cporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cporfs$handle() {
        return LAPACKE_cporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cporfs$address() {
        return LAPACKE_cporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zporfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfs$descriptor() {
        return LAPACKE_zporfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zporfs$handle() {
        return LAPACKE_zporfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zporfs$address() {
        return LAPACKE_zporfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zporfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zporfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sporfsx$descriptor() {
        return LAPACKE_sporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sporfsx$handle() {
        return LAPACKE_sporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sporfsx$address() {
        return LAPACKE_sporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dporfsx$descriptor() {
        return LAPACKE_dporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dporfsx$handle() {
        return LAPACKE_dporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dporfsx$address() {
        return LAPACKE_dporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cporfsx$descriptor() {
        return LAPACKE_cporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cporfsx$handle() {
        return LAPACKE_cporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cporfsx$address() {
        return LAPACKE_cporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zporfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zporfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zporfsx$descriptor() {
        return LAPACKE_zporfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zporfsx$handle() {
        return LAPACKE_zporfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zporfsx$address() {
        return LAPACKE_zporfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zporfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zporfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zporfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zporfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposv$descriptor() {
        return LAPACKE_sposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sposv$handle() {
        return LAPACKE_sposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sposv$address() {
        return LAPACKE_sposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposv$descriptor() {
        return LAPACKE_dposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dposv$handle() {
        return LAPACKE_dposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dposv$address() {
        return LAPACKE_dposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposv$descriptor() {
        return LAPACKE_cposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cposv$handle() {
        return LAPACKE_cposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cposv$address() {
        return LAPACKE_cposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposv$descriptor() {
        return LAPACKE_zposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zposv$handle() {
        return LAPACKE_zposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zposv$address() {
        return LAPACKE_zposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsposv$descriptor() {
        return LAPACKE_dsposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsposv$handle() {
        return LAPACKE_dsposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsposv$address() {
        return LAPACKE_dsposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsposv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_dsposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_dsposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcposv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zcposv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcposv$descriptor() {
        return LAPACKE_zcposv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcposv$handle() {
        return LAPACKE_zcposv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcposv$address() {
        return LAPACKE_zcposv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcposv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_zcposv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_zcposv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcposv", matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvx$descriptor() {
        return LAPACKE_sposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sposvx$handle() {
        return LAPACKE_sposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sposvx$address() {
        return LAPACKE_sposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvx$descriptor() {
        return LAPACKE_dposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dposvx$handle() {
        return LAPACKE_dposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dposvx$address() {
        return LAPACKE_dposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvx$descriptor() {
        return LAPACKE_cposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cposvx$handle() {
        return LAPACKE_cposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cposvx$address() {
        return LAPACKE_cposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvx$descriptor() {
        return LAPACKE_zposvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zposvx$handle() {
        return LAPACKE_zposvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zposvx$address() {
        return LAPACKE_zposvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zposvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zposvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sposvxx$descriptor() {
        return LAPACKE_sposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sposvxx$handle() {
        return LAPACKE_sposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sposvxx$address() {
        return LAPACKE_sposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dposvxx$descriptor() {
        return LAPACKE_dposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dposvxx$handle() {
        return LAPACKE_dposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dposvxx$address() {
        return LAPACKE_dposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cposvxx$descriptor() {
        return LAPACKE_cposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cposvxx$handle() {
        return LAPACKE_cposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cposvxx$address() {
        return LAPACKE_cposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zposvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zposvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zposvxx$descriptor() {
        return LAPACKE_zposvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zposvxx$handle() {
        return LAPACKE_zposvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zposvxx$address() {
        return LAPACKE_zposvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zposvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zposvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zposvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zposvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf2$descriptor() {
        return LAPACKE_spotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf2$handle() {
        return LAPACKE_spotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf2$address() {
        return LAPACKE_spotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf2(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf2$descriptor() {
        return LAPACKE_dpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf2$handle() {
        return LAPACKE_dpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf2$address() {
        return LAPACKE_dpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf2(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf2$descriptor() {
        return LAPACKE_cpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf2$handle() {
        return LAPACKE_cpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf2$address() {
        return LAPACKE_cpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf2(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf2$descriptor() {
        return LAPACKE_zpotrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf2$handle() {
        return LAPACKE_zpotrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf2$address() {
        return LAPACKE_zpotrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf2(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf2(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf2", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrf$descriptor() {
        return LAPACKE_spotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotrf$handle() {
        return LAPACKE_spotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotrf$address() {
        return LAPACKE_spotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrf(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrf$descriptor() {
        return LAPACKE_dpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotrf$handle() {
        return LAPACKE_dpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotrf$address() {
        return LAPACKE_dpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrf(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrf$descriptor() {
        return LAPACKE_cpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotrf$handle() {
        return LAPACKE_cpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotrf$address() {
        return LAPACKE_cpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrf$descriptor() {
        return LAPACKE_zpotrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotrf$handle() {
        return LAPACKE_zpotrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotrf$address() {
        return LAPACKE_zpotrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrf", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotri$descriptor() {
        return LAPACKE_spotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_spotri$handle() {
        return LAPACKE_spotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_spotri$address() {
        return LAPACKE_spotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotri(int matrix_layout, char uplo, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_spotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_spotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotri$descriptor() {
        return LAPACKE_dpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dpotri$handle() {
        return LAPACKE_dpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dpotri$address() {
        return LAPACKE_dpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotri(int matrix_layout, char uplo, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotri$descriptor() {
        return LAPACKE_cpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_cpotri$handle() {
        return LAPACKE_cpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_cpotri$address() {
        return LAPACKE_cpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotri(int matrix_layout, char uplo, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_cpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_cpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotri$descriptor() {
        return LAPACKE_zpotri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_zpotri$handle() {
        return LAPACKE_zpotri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_zpotri$address() {
        return LAPACKE_zpotri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotri(int matrix_layout, char uplo, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_zpotri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_zpotri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotri", matrix_layout, uplo, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spotrs$descriptor() {
        return LAPACKE_spotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spotrs$handle() {
        return LAPACKE_spotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spotrs$address() {
        return LAPACKE_spotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spotrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpotrs$descriptor() {
        return LAPACKE_dpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpotrs$handle() {
        return LAPACKE_dpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpotrs$address() {
        return LAPACKE_dpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpotrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpotrs$descriptor() {
        return LAPACKE_cpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpotrs$handle() {
        return LAPACKE_cpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpotrs$address() {
        return LAPACKE_cpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpotrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpotrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpotrs$descriptor() {
        return LAPACKE_zpotrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpotrs$handle() {
        return LAPACKE_zpotrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpotrs$address() {
        return LAPACKE_zpotrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpotrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpotrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpotrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpotrs", matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppcon$descriptor() {
        return LAPACKE_sppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sppcon$handle() {
        return LAPACKE_sppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sppcon$address() {
        return LAPACKE_sppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppcon(int matrix_layout, char uplo, int n, const float *ap, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppcon$descriptor() {
        return LAPACKE_dppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dppcon$handle() {
        return LAPACKE_dppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dppcon$address() {
        return LAPACKE_dppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppcon(int matrix_layout, char uplo, int n, const double *ap, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppcon$descriptor() {
        return LAPACKE_cppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cppcon$handle() {
        return LAPACKE_cppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cppcon$address() {
        return LAPACKE_cppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppcon(int matrix_layout, char uplo, int n, const _Complex float *ap, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppcon$descriptor() {
        return LAPACKE_zppcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zppcon$handle() {
        return LAPACKE_zppcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zppcon$address() {
        return LAPACKE_zppcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppcon(int matrix_layout, char uplo, int n, const _Complex double *ap, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zppcon(int matrix_layout, byte uplo, int n, MemorySegment ap, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zppcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppcon", matrix_layout, uplo, n, ap, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppequ$descriptor() {
        return LAPACKE_sppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sppequ$handle() {
        return LAPACKE_sppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sppequ$address() {
        return LAPACKE_sppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppequ(int matrix_layout, char uplo, int n, const float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_sppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_sppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppequ$descriptor() {
        return LAPACKE_dppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dppequ$handle() {
        return LAPACKE_dppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dppequ$address() {
        return LAPACKE_dppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppequ(int matrix_layout, char uplo, int n, const double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppequ$descriptor() {
        return LAPACKE_cppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cppequ$handle() {
        return LAPACKE_cppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cppequ$address() {
        return LAPACKE_cppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppequ(int matrix_layout, char uplo, int n, const _Complex float *ap, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_cppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_cppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppequ$descriptor() {
        return LAPACKE_zppequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zppequ$handle() {
        return LAPACKE_zppequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zppequ$address() {
        return LAPACKE_zppequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppequ(int matrix_layout, char uplo, int n, const _Complex double *ap, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zppequ(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zppequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppequ", matrix_layout, uplo, n, ap, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_spprfs$descriptor() {
        return LAPACKE_spprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_spprfs$handle() {
        return LAPACKE_spprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_spprfs$address() {
        return LAPACKE_spprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_spprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_spprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpprfs$descriptor() {
        return LAPACKE_dpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dpprfs$handle() {
        return LAPACKE_dpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dpprfs$address() {
        return LAPACKE_dpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpprfs$descriptor() {
        return LAPACKE_cpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cpprfs$handle() {
        return LAPACKE_cpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cpprfs$address() {
        return LAPACKE_cpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpprfs$descriptor() {
        return LAPACKE_zpprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zpprfs$handle() {
        return LAPACKE_zpprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zpprfs$address() {
        return LAPACKE_zpprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zpprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zpprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpprfs", matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsv$descriptor() {
        return LAPACKE_sppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sppsv$handle() {
        return LAPACKE_sppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sppsv$address() {
        return LAPACKE_sppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsv$descriptor() {
        return LAPACKE_dppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dppsv$handle() {
        return LAPACKE_dppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dppsv$address() {
        return LAPACKE_dppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsv$descriptor() {
        return LAPACKE_cppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cppsv$handle() {
        return LAPACKE_cppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cppsv$address() {
        return LAPACKE_cppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsv$descriptor() {
        return LAPACKE_zppsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zppsv$handle() {
        return LAPACKE_zppsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zppsv$address() {
        return LAPACKE_zppsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zppsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zppsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsv", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sppsvx$descriptor() {
        return LAPACKE_sppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sppsvx$handle() {
        return LAPACKE_sppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sppsvx$address() {
        return LAPACKE_sppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *ap, float *afp, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dppsvx$descriptor() {
        return LAPACKE_dppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dppsvx$handle() {
        return LAPACKE_dppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dppsvx$address() {
        return LAPACKE_dppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *ap, double *afp, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cppsvx$descriptor() {
        return LAPACKE_cppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cppsvx$handle() {
        return LAPACKE_cppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cppsvx$address() {
        return LAPACKE_cppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *ap, _Complex float *afp, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zppsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zppsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zppsvx$descriptor() {
        return LAPACKE_zppsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zppsvx$handle() {
        return LAPACKE_zppsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zppsvx$address() {
        return LAPACKE_zppsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zppsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *ap, _Complex double *afp, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zppsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zppsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zppsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, equed, s, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrf$descriptor() {
        return LAPACKE_spptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptrf$handle() {
        return LAPACKE_spptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptrf$address() {
        return LAPACKE_spptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrf(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrf$descriptor() {
        return LAPACKE_dpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptrf$handle() {
        return LAPACKE_dpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptrf$address() {
        return LAPACKE_dpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrf(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrf$descriptor() {
        return LAPACKE_cpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptrf$handle() {
        return LAPACKE_cpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptrf$address() {
        return LAPACKE_cpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrf(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrf$descriptor() {
        return LAPACKE_zpptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptrf$handle() {
        return LAPACKE_zpptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptrf$address() {
        return LAPACKE_zpptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrf(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptrf(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrf", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptri$descriptor() {
        return LAPACKE_spptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_spptri$handle() {
        return LAPACKE_spptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_spptri$address() {
        return LAPACKE_spptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptri(int matrix_layout, char uplo, int n, float *ap)
     * }
     */
    public static int LAPACKE_spptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_spptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptri$descriptor() {
        return LAPACKE_dpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dpptri$handle() {
        return LAPACKE_dpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dpptri$address() {
        return LAPACKE_dpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptri(int matrix_layout, char uplo, int n, double *ap)
     * }
     */
    public static int LAPACKE_dpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptri$descriptor() {
        return LAPACKE_cpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_cpptri$handle() {
        return LAPACKE_cpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_cpptri$address() {
        return LAPACKE_cpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptri(int matrix_layout, char uplo, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_cpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_cpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptri$descriptor() {
        return LAPACKE_zpptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_zpptri$handle() {
        return LAPACKE_zpptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_zpptri$address() {
        return LAPACKE_zpptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptri(int matrix_layout, char uplo, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_zpptri(int matrix_layout, byte uplo, int n, MemorySegment ap) {
        var mh$ = LAPACKE_zpptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptri", matrix_layout, uplo, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spptrs$descriptor() {
        return LAPACKE_spptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spptrs$handle() {
        return LAPACKE_spptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spptrs$address() {
        return LAPACKE_spptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpptrs$descriptor() {
        return LAPACKE_dpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpptrs$handle() {
        return LAPACKE_dpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpptrs$address() {
        return LAPACKE_dpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpptrs$descriptor() {
        return LAPACKE_cpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpptrs$handle() {
        return LAPACKE_cpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpptrs$address() {
        return LAPACKE_cpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpptrs$descriptor() {
        return LAPACKE_zpptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpptrs$handle() {
        return LAPACKE_zpptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpptrs$address() {
        return LAPACKE_zpptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpptrs", matrix_layout, uplo, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_spstrf$descriptor() {
        return LAPACKE_spstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MethodHandle LAPACKE_spstrf$handle() {
        return LAPACKE_spstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MemorySegment LAPACKE_spstrf$address() {
        return LAPACKE_spstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spstrf(int matrix_layout, char uplo, int n, float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static int LAPACKE_spstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol) {
        var mh$ = LAPACKE_spstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpstrf$descriptor() {
        return LAPACKE_dpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MethodHandle LAPACKE_dpstrf$handle() {
        return LAPACKE_dpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MemorySegment LAPACKE_dpstrf$address() {
        return LAPACKE_dpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpstrf(int matrix_layout, char uplo, int n, double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static int LAPACKE_dpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol) {
        var mh$ = LAPACKE_dpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpstrf$descriptor() {
        return LAPACKE_cpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MethodHandle LAPACKE_cpstrf$handle() {
        return LAPACKE_cpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static MemorySegment LAPACKE_cpstrf$address() {
        return LAPACKE_cpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpstrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *piv, int *rank, float tol)
     * }
     */
    public static int LAPACKE_cpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, float tol) {
        var mh$ = LAPACKE_cpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpstrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpstrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpstrf$descriptor() {
        return LAPACKE_zpstrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MethodHandle LAPACKE_zpstrf$handle() {
        return LAPACKE_zpstrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static MemorySegment LAPACKE_zpstrf$address() {
        return LAPACKE_zpstrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpstrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *piv, int *rank, double tol)
     * }
     */
    public static int LAPACKE_zpstrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment piv, MemorySegment rank, double tol) {
        var mh$ = LAPACKE_zpstrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpstrf", matrix_layout, uplo, n, a, lda, piv, rank, tol);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, piv, rank, tol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptcon$descriptor() {
        return LAPACKE_sptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sptcon$handle() {
        return LAPACKE_sptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sptcon$address() {
        return LAPACKE_sptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptcon(int n, const float *d, const float *e, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sptcon(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptcon$descriptor() {
        return LAPACKE_dptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dptcon$handle() {
        return LAPACKE_dptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dptcon$address() {
        return LAPACKE_dptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptcon(int n, const double *d, const double *e, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dptcon(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptcon$descriptor() {
        return LAPACKE_cptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cptcon$handle() {
        return LAPACKE_cptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cptcon$address() {
        return LAPACKE_cptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptcon(int n, const float *d, const _Complex float *e, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cptcon(int n, MemorySegment d, MemorySegment e, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptcon$descriptor() {
        return LAPACKE_zptcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zptcon$handle() {
        return LAPACKE_zptcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zptcon$address() {
        return LAPACKE_zptcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptcon(int n, const double *d, const _Complex double *e, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zptcon(int n, MemorySegment d, MemorySegment e, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zptcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptcon", n, d, e, anorm, rcond);
            }
            return (int)mh$.invokeExact(n, d, e, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_spteqr$descriptor() {
        return LAPACKE_spteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_spteqr$handle() {
        return LAPACKE_spteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_spteqr$address() {
        return LAPACKE_spteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_spteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_spteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpteqr$descriptor() {
        return LAPACKE_dpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dpteqr$handle() {
        return LAPACKE_dpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dpteqr$address() {
        return LAPACKE_dpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpteqr$descriptor() {
        return LAPACKE_cpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cpteqr$handle() {
        return LAPACKE_cpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cpteqr$address() {
        return LAPACKE_cpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpteqr$descriptor() {
        return LAPACKE_zpteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zpteqr$handle() {
        return LAPACKE_zpteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zpteqr$address() {
        return LAPACKE_zpteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zpteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zpteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptrfs$descriptor() {
        return LAPACKE_sptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sptrfs$handle() {
        return LAPACKE_sptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sptrfs$address() {
        return LAPACKE_sptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, const float *d, const float *e, const float *df, const float *ef, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sptrfs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptrfs", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptrfs$descriptor() {
        return LAPACKE_dptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dptrfs$handle() {
        return LAPACKE_dptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dptrfs$address() {
        return LAPACKE_dptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, const double *d, const double *e, const double *df, const double *ef, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dptrfs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptrfs", matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptrfs$descriptor() {
        return LAPACKE_cptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cptrfs$handle() {
        return LAPACKE_cptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cptrfs$address() {
        return LAPACKE_cptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptrfs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, const float *df, const _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cptrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptrfs", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptrfs$descriptor() {
        return LAPACKE_zptrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zptrfs$handle() {
        return LAPACKE_zptrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zptrfs$address() {
        return LAPACKE_zptrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptrfs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, const double *df, const _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zptrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zptrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptrfs", matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsv$descriptor() {
        return LAPACKE_sptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sptsv$handle() {
        return LAPACKE_sptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sptsv$address() {
        return LAPACKE_sptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, float *d, float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsv$descriptor() {
        return LAPACKE_dptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dptsv$handle() {
        return LAPACKE_dptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dptsv$address() {
        return LAPACKE_dptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, double *d, double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsv$descriptor() {
        return LAPACKE_cptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cptsv$handle() {
        return LAPACKE_cptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cptsv$address() {
        return LAPACKE_cptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, float *d, _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsv$descriptor() {
        return LAPACKE_zptsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zptsv$handle() {
        return LAPACKE_zptsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zptsv$address() {
        return LAPACKE_zptsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, double *d, _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zptsv(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zptsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsv", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sptsvx$descriptor() {
        return LAPACKE_sptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sptsvx$handle() {
        return LAPACKE_sptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sptsvx$address() {
        return LAPACKE_sptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const float *e, float *df, float *ef, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dptsvx$descriptor() {
        return LAPACKE_dptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dptsvx$handle() {
        return LAPACKE_dptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dptsvx$address() {
        return LAPACKE_dptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const double *e, double *df, double *ef, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cptsvx$descriptor() {
        return LAPACKE_cptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cptsvx$handle() {
        return LAPACKE_cptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cptsvx$address() {
        return LAPACKE_cptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cptsvx(int matrix_layout, char fact, int n, int nrhs, const float *d, const _Complex float *e, float *df, _Complex float *ef, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zptsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zptsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zptsvx$descriptor() {
        return LAPACKE_zptsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zptsvx$handle() {
        return LAPACKE_zptsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zptsvx$address() {
        return LAPACKE_zptsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zptsvx(int matrix_layout, char fact, int n, int nrhs, const double *d, const _Complex double *e, double *df, _Complex double *ef, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zptsvx(int matrix_layout, byte fact, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment df, MemorySegment ef, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zptsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zptsvx", matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrf$descriptor() {
        return LAPACKE_spttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_spttrf$handle() {
        return LAPACKE_spttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_spttrf$address() {
        return LAPACKE_spttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrf(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_spttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_spttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrf$descriptor() {
        return LAPACKE_dpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dpttrf$handle() {
        return LAPACKE_dpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dpttrf$address() {
        return LAPACKE_dpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrf(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrf$descriptor() {
        return LAPACKE_cpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static MethodHandle LAPACKE_cpttrf$handle() {
        return LAPACKE_cpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static MemorySegment LAPACKE_cpttrf$address() {
        return LAPACKE_cpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrf(int n, float *d, _Complex float *e)
     * }
     */
    public static int LAPACKE_cpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_cpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpttrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrf$descriptor() {
        return LAPACKE_zpttrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static MethodHandle LAPACKE_zpttrf$handle() {
        return LAPACKE_zpttrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static MemorySegment LAPACKE_zpttrf$address() {
        return LAPACKE_zpttrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrf(int n, double *d, _Complex double *e)
     * }
     */
    public static int LAPACKE_zpttrf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_zpttrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_spttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_spttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_spttrs$descriptor() {
        return LAPACKE_spttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_spttrs$handle() {
        return LAPACKE_spttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_spttrs$address() {
        return LAPACKE_spttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, const float *d, const float *e, float *b, int ldb)
     * }
     */
    public static int LAPACKE_spttrs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_spttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_spttrs", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dpttrs$descriptor() {
        return LAPACKE_dpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dpttrs$handle() {
        return LAPACKE_dpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dpttrs$address() {
        return LAPACKE_dpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, const double *d, const double *e, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dpttrs(int matrix_layout, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dpttrs", matrix_layout, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cpttrs$descriptor() {
        return LAPACKE_cpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cpttrs$handle() {
        return LAPACKE_cpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cpttrs$address() {
        return LAPACKE_cpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cpttrs(int matrix_layout, char uplo, int n, int nrhs, const float *d, const _Complex float *e, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cpttrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cpttrs", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zpttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zpttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zpttrs$descriptor() {
        return LAPACKE_zpttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zpttrs$handle() {
        return LAPACKE_zpttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zpttrs$address() {
        return LAPACKE_zpttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zpttrs(int matrix_layout, char uplo, int n, int nrhs, const double *d, const _Complex double *e, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zpttrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment d, MemorySegment e, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zpttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zpttrs", matrix_layout, uplo, n, nrhs, d, e, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, d, e, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbev$descriptor() {
        return LAPACKE_ssbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbev$handle() {
        return LAPACKE_ssbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbev$address() {
        return LAPACKE_ssbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbev(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbev$descriptor() {
        return LAPACKE_dsbev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbev$handle() {
        return LAPACKE_dsbev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbev$address() {
        return LAPACKE_dsbev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbev(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbev(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbev", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevd$descriptor() {
        return LAPACKE_ssbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbevd$handle() {
        return LAPACKE_ssbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbevd$address() {
        return LAPACKE_ssbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevd(int matrix_layout, char jobz, char uplo, int n, int kd, float *ab, int ldab, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevd$descriptor() {
        return LAPACKE_dsbevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbevd$handle() {
        return LAPACKE_dsbevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbevd$address() {
        return LAPACKE_dsbevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevd(int matrix_layout, char jobz, char uplo, int n, int kd, double *ab, int ldab, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbevd(int matrix_layout, byte jobz, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevd", matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, kd, ab, ldab, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbevx$descriptor() {
        return LAPACKE_ssbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbevx$handle() {
        return LAPACKE_ssbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbevx$address() {
        return LAPACKE_ssbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, float *ab, int ldab, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbevx$descriptor() {
        return LAPACKE_dsbevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbevx$handle() {
        return LAPACKE_dsbevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbevx$address() {
        return LAPACKE_dsbevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbevx(int matrix_layout, char jobz, char range, char uplo, int n, int kd, double *ab, int ldab, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsbevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbevx", matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, kd, ab, ldab, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgst$descriptor() {
        return LAPACKE_ssbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_ssbgst$handle() {
        return LAPACKE_ssbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_ssbgst$address() {
        return LAPACKE_ssbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, float *ab, int ldab, const float *bb, int ldbb, float *x, int ldx)
     * }
     */
    public static int LAPACKE_ssbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_ssbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgst$descriptor() {
        return LAPACKE_dsbgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static MethodHandle LAPACKE_dsbgst$handle() {
        return LAPACKE_dsbgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static MemorySegment LAPACKE_dsbgst$address() {
        return LAPACKE_dsbgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgst(int matrix_layout, char vect, char uplo, int n, int ka, int kb, double *ab, int ldab, const double *bb, int ldbb, double *x, int ldx)
     * }
     */
    public static int LAPACKE_dsbgst(int matrix_layout, byte vect, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment x, int ldx) {
        var mh$ = LAPACKE_dsbgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgst", matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, ka, kb, ab, ldab, bb, ldbb, x, ldx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgv$descriptor() {
        return LAPACKE_ssbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbgv$handle() {
        return LAPACKE_ssbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbgv$address() {
        return LAPACKE_ssbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgv$descriptor() {
        return LAPACKE_dsbgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbgv$handle() {
        return LAPACKE_dsbgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbgv$address() {
        return LAPACKE_dsbgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgv(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbgv(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgv", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvd$descriptor() {
        return LAPACKE_ssbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvd$handle() {
        return LAPACKE_ssbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvd$address() {
        return LAPACKE_ssbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvd$descriptor() {
        return LAPACKE_dsbgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvd$handle() {
        return LAPACKE_dsbgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvd$address() {
        return LAPACKE_dsbgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvd(int matrix_layout, char jobz, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsbgvd(int matrix_layout, byte jobz, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsbgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvd", matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbgvx$descriptor() {
        return LAPACKE_ssbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssbgvx$handle() {
        return LAPACKE_ssbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssbgvx$address() {
        return LAPACKE_ssbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, float *ab, int ldab, float *bb, int ldbb, float *q, int ldq, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbgvx$descriptor() {
        return LAPACKE_dsbgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsbgvx$handle() {
        return LAPACKE_dsbgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsbgvx$address() {
        return LAPACKE_dsbgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbgvx(int matrix_layout, char jobz, char range, char uplo, int n, int ka, int kb, double *ab, int ldab, double *bb, int ldbb, double *q, int ldq, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsbgvx(int matrix_layout, byte jobz, byte range, byte uplo, int n, int ka, int kb, MemorySegment ab, int ldab, MemorySegment bb, int ldbb, MemorySegment q, int ldq, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsbgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbgvx", matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssbtrd$descriptor() {
        return LAPACKE_ssbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_ssbtrd$handle() {
        return LAPACKE_ssbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_ssbtrd$address() {
        return LAPACKE_ssbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssbtrd(int matrix_layout, char vect, char uplo, int n, int kd, float *ab, int ldab, float *d, float *e, float *q, int ldq)
     * }
     */
    public static int LAPACKE_ssbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_ssbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsbtrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsbtrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsbtrd$descriptor() {
        return LAPACKE_dsbtrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_dsbtrd$handle() {
        return LAPACKE_dsbtrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_dsbtrd$address() {
        return LAPACKE_dsbtrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsbtrd(int matrix_layout, char vect, char uplo, int n, int kd, double *ab, int ldab, double *d, double *e, double *q, int ldq)
     * }
     */
    public static int LAPACKE_dsbtrd(int matrix_layout, byte vect, byte uplo, int n, int kd, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_dsbtrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsbtrd", matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, uplo, n, kd, ab, ldab, d, e, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssfrk$descriptor() {
        return LAPACKE_ssfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MethodHandle LAPACKE_ssfrk$handle() {
        return LAPACKE_ssfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static MemorySegment LAPACKE_ssfrk$address() {
        return LAPACKE_ssfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, float alpha, const float *a, int lda, float beta, float *c)
     * }
     */
    public static int LAPACKE_ssfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, float alpha, MemorySegment a, int lda, float beta, MemorySegment c) {
        var mh$ = LAPACKE_ssfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsfrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsfrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsfrk$descriptor() {
        return LAPACKE_dsfrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MethodHandle LAPACKE_dsfrk$handle() {
        return LAPACKE_dsfrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static MemorySegment LAPACKE_dsfrk$address() {
        return LAPACKE_dsfrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsfrk(int matrix_layout, char transr, char uplo, char trans, int n, int k, double alpha, const double *a, int lda, double beta, double *c)
     * }
     */
    public static int LAPACKE_dsfrk(int matrix_layout, byte transr, byte uplo, byte trans, int n, int k, double alpha, MemorySegment a, int lda, double beta, MemorySegment c) {
        var mh$ = LAPACKE_dsfrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsfrk", matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, trans, n, k, alpha, a, lda, beta, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspcon$descriptor() {
        return LAPACKE_sspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sspcon$handle() {
        return LAPACKE_sspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sspcon$address() {
        return LAPACKE_sspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspcon(int matrix_layout, char uplo, int n, const float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspcon$descriptor() {
        return LAPACKE_dspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dspcon$handle() {
        return LAPACKE_dspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dspcon$address() {
        return LAPACKE_dspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspcon(int matrix_layout, char uplo, int n, const double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspcon$descriptor() {
        return LAPACKE_cspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cspcon$handle() {
        return LAPACKE_cspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cspcon$address() {
        return LAPACKE_cspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspcon(int matrix_layout, char uplo, int n, const _Complex float *ap, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspcon$descriptor() {
        return LAPACKE_zspcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zspcon$handle() {
        return LAPACKE_zspcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zspcon$address() {
        return LAPACKE_zspcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspcon(int matrix_layout, char uplo, int n, const _Complex double *ap, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zspcon(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zspcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspcon", matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspev$descriptor() {
        return LAPACKE_sspev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspev$handle() {
        return LAPACKE_sspev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspev$address() {
        return LAPACKE_sspev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspev(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspev$descriptor() {
        return LAPACKE_dspev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspev$handle() {
        return LAPACKE_dspev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspev$address() {
        return LAPACKE_dspev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspev(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspev", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevd$descriptor() {
        return LAPACKE_sspevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspevd$handle() {
        return LAPACKE_sspevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspevd$address() {
        return LAPACKE_sspevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevd(int matrix_layout, char jobz, char uplo, int n, float *ap, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevd$descriptor() {
        return LAPACKE_dspevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspevd$handle() {
        return LAPACKE_dspevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspevd$address() {
        return LAPACKE_dspevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevd(int matrix_layout, char jobz, char uplo, int n, double *ap, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevd", matrix_layout, jobz, uplo, n, ap, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, ap, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspevx$descriptor() {
        return LAPACKE_sspevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspevx$handle() {
        return LAPACKE_sspevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspevx$address() {
        return LAPACKE_sspevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspevx(int matrix_layout, char jobz, char range, char uplo, int n, float *ap, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sspevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sspevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspevx$descriptor() {
        return LAPACKE_dspevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspevx$handle() {
        return LAPACKE_dspevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspevx$address() {
        return LAPACKE_dspevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspevx(int matrix_layout, char jobz, char range, char uplo, int n, double *ap, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dspevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment ap, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dspevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspevx", matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, ap, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgst$descriptor() {
        return LAPACKE_sspgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MethodHandle LAPACKE_sspgst$handle() {
        return LAPACKE_sspgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static MemorySegment LAPACKE_sspgst$address() {
        return LAPACKE_sspgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgst(int matrix_layout, int itype, char uplo, int n, float *ap, const float *bp)
     * }
     */
    public static int LAPACKE_sspgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_sspgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgst$descriptor() {
        return LAPACKE_dspgst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MethodHandle LAPACKE_dspgst$handle() {
        return LAPACKE_dspgst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static MemorySegment LAPACKE_dspgst$address() {
        return LAPACKE_dspgst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgst(int matrix_layout, int itype, char uplo, int n, double *ap, const double *bp)
     * }
     */
    public static int LAPACKE_dspgst(int matrix_layout, int itype, byte uplo, int n, MemorySegment ap, MemorySegment bp) {
        var mh$ = LAPACKE_dspgst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgst", matrix_layout, itype, uplo, n, ap, bp);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgv$descriptor() {
        return LAPACKE_sspgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspgv$handle() {
        return LAPACKE_sspgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspgv$address() {
        return LAPACKE_sspgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgv(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgv$descriptor() {
        return LAPACKE_dspgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspgv$handle() {
        return LAPACKE_dspgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspgv$address() {
        return LAPACKE_dspgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgv(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspgv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgv", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvd$descriptor() {
        return LAPACKE_sspgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sspgvd$handle() {
        return LAPACKE_sspgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sspgvd$address() {
        return LAPACKE_sspgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *ap, float *bp, float *w, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sspgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sspgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvd$descriptor() {
        return LAPACKE_dspgvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dspgvd$handle() {
        return LAPACKE_dspgvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dspgvd$address() {
        return LAPACKE_dspgvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *ap, double *bp, double *w, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dspgvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment ap, MemorySegment bp, MemorySegment w, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dspgvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvd", matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, ap, bp, w, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspgvx$descriptor() {
        return LAPACKE_sspgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sspgvx$handle() {
        return LAPACKE_sspgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sspgvx$address() {
        return LAPACKE_sspgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *ap, float *bp, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sspgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sspgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspgvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspgvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspgvx$descriptor() {
        return LAPACKE_dspgvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dspgvx$handle() {
        return LAPACKE_dspgvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dspgvx$address() {
        return LAPACKE_dspgvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspgvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *ap, double *bp, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dspgvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment ap, MemorySegment bp, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dspgvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspgvx", matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, ap, bp, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssprfs$descriptor() {
        return LAPACKE_ssprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssprfs$handle() {
        return LAPACKE_ssprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssprfs$address() {
        return LAPACKE_ssprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssprfs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const float *afp, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsprfs$descriptor() {
        return LAPACKE_dsprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsprfs$handle() {
        return LAPACKE_dsprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsprfs$address() {
        return LAPACKE_dsprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsprfs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const double *afp, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csprfs$descriptor() {
        return LAPACKE_csprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csprfs$handle() {
        return LAPACKE_csprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csprfs$address() {
        return LAPACKE_csprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const _Complex float *afp, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsprfs$descriptor() {
        return LAPACKE_zsprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsprfs$handle() {
        return LAPACKE_zsprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsprfs$address() {
        return LAPACKE_zsprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsprfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const _Complex double *afp, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsprfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsprfs", matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsv$descriptor() {
        return LAPACKE_sspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sspsv$handle() {
        return LAPACKE_sspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sspsv$address() {
        return LAPACKE_sspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsv(int matrix_layout, char uplo, int n, int nrhs, float *ap, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsv$descriptor() {
        return LAPACKE_dspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dspsv$handle() {
        return LAPACKE_dspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dspsv$address() {
        return LAPACKE_dspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsv(int matrix_layout, char uplo, int n, int nrhs, double *ap, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsv$descriptor() {
        return LAPACKE_cspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cspsv$handle() {
        return LAPACKE_cspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cspsv$address() {
        return LAPACKE_cspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *ap, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsv$descriptor() {
        return LAPACKE_zspsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zspsv$handle() {
        return LAPACKE_zspsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zspsv$address() {
        return LAPACKE_zspsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *ap, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zspsv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zspsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsv", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sspsvx$descriptor() {
        return LAPACKE_sspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sspsvx$handle() {
        return LAPACKE_sspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sspsvx$address() {
        return LAPACKE_sspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *ap, float *afp, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dspsvx$descriptor() {
        return LAPACKE_dspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dspsvx$handle() {
        return LAPACKE_dspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dspsvx$address() {
        return LAPACKE_dspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *ap, double *afp, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cspsvx$descriptor() {
        return LAPACKE_cspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cspsvx$handle() {
        return LAPACKE_cspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cspsvx$address() {
        return LAPACKE_cspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *ap, _Complex float *afp, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zspsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zspsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zspsvx$descriptor() {
        return LAPACKE_zspsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zspsvx$handle() {
        return LAPACKE_zspsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zspsvx$address() {
        return LAPACKE_zspsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zspsvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *ap, _Complex double *afp, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zspsvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment afp, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zspsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zspsvx", matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrd$descriptor() {
        return LAPACKE_ssptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssptrd$handle() {
        return LAPACKE_ssptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssptrd$address() {
        return LAPACKE_ssptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrd(int matrix_layout, char uplo, int n, float *ap, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrd$descriptor() {
        return LAPACKE_dsptrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsptrd$handle() {
        return LAPACKE_dsptrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsptrd$address() {
        return LAPACKE_dsptrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrd(int matrix_layout, char uplo, int n, double *ap, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsptrd(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsptrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrd", matrix_layout, uplo, n, ap, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrf$descriptor() {
        return LAPACKE_ssptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptrf$handle() {
        return LAPACKE_ssptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptrf$address() {
        return LAPACKE_ssptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrf(int matrix_layout, char uplo, int n, float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_ssptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrf$descriptor() {
        return LAPACKE_dsptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptrf$handle() {
        return LAPACKE_dsptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptrf$address() {
        return LAPACKE_dsptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrf(int matrix_layout, char uplo, int n, double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_dsptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrf$descriptor() {
        return LAPACKE_csptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptrf$handle() {
        return LAPACKE_csptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptrf$address() {
        return LAPACKE_csptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrf(int matrix_layout, char uplo, int n, _Complex float *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_csptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrf$descriptor() {
        return LAPACKE_zsptrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptrf$handle() {
        return LAPACKE_zsptrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptrf$address() {
        return LAPACKE_zsptrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrf(int matrix_layout, char uplo, int n, _Complex double *ap, int *ipiv)
     * }
     */
    public static int LAPACKE_zsptrf(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrf", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptri$descriptor() {
        return LAPACKE_ssptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssptri$handle() {
        return LAPACKE_ssptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssptri$address() {
        return LAPACKE_ssptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptri(int matrix_layout, char uplo, int n, float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptri$descriptor() {
        return LAPACKE_dsptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsptri$handle() {
        return LAPACKE_dsptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsptri$address() {
        return LAPACKE_dsptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptri(int matrix_layout, char uplo, int n, double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptri$descriptor() {
        return LAPACKE_csptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csptri$handle() {
        return LAPACKE_csptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csptri$address() {
        return LAPACKE_csptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptri(int matrix_layout, char uplo, int n, _Complex float *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_csptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_csptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptri$descriptor() {
        return LAPACKE_zsptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsptri$handle() {
        return LAPACKE_zsptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsptri$address() {
        return LAPACKE_zsptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptri(int matrix_layout, char uplo, int n, _Complex double *ap, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsptri(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptri", matrix_layout, uplo, n, ap, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssptrs$descriptor() {
        return LAPACKE_ssptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssptrs$handle() {
        return LAPACKE_ssptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssptrs$address() {
        return LAPACKE_ssptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssptrs(int matrix_layout, char uplo, int n, int nrhs, const float *ap, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsptrs$descriptor() {
        return LAPACKE_dsptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsptrs$handle() {
        return LAPACKE_dsptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsptrs$address() {
        return LAPACKE_dsptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsptrs(int matrix_layout, char uplo, int n, int nrhs, const double *ap, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csptrs$descriptor() {
        return LAPACKE_csptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csptrs$handle() {
        return LAPACKE_csptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csptrs$address() {
        return LAPACKE_csptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *ap, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsptrs$descriptor() {
        return LAPACKE_zsptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsptrs$handle() {
        return LAPACKE_zsptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsptrs$address() {
        return LAPACKE_zsptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsptrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *ap, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsptrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment ap, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsptrs", matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, ap, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstebz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstebz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstebz$descriptor() {
        return LAPACKE_sstebz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static MethodHandle LAPACKE_sstebz$handle() {
        return LAPACKE_sstebz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static MemorySegment LAPACKE_sstebz$address() {
        return LAPACKE_sstebz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstebz(char range, char order, int n, float vl, float vu, int il, int iu, float abstol, const float *d, const float *e, int *m, int *nsplit, float *w, int *iblock, int *isplit)
     * }
     */
    public static int LAPACKE_sstebz(byte range, byte order, int n, float vl, float vu, int il, int iu, float abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit) {
        var mh$ = LAPACKE_sstebz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstebz", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstebz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstebz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstebz$descriptor() {
        return LAPACKE_dstebz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static MethodHandle LAPACKE_dstebz$handle() {
        return LAPACKE_dstebz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static MemorySegment LAPACKE_dstebz$address() {
        return LAPACKE_dstebz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstebz(char range, char order, int n, double vl, double vu, int il, int iu, double abstol, const double *d, const double *e, int *m, int *nsplit, double *w, int *iblock, int *isplit)
     * }
     */
    public static int LAPACKE_dstebz(byte range, byte order, int n, double vl, double vu, int il, int iu, double abstol, MemorySegment d, MemorySegment e, MemorySegment m, MemorySegment nsplit, MemorySegment w, MemorySegment iblock, MemorySegment isplit) {
        var mh$ = LAPACKE_dstebz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstebz", range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
            }
            return (int)mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, d, e, m, nsplit, w, iblock, isplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstedc$descriptor() {
        return LAPACKE_sstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstedc$handle() {
        return LAPACKE_sstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstedc$address() {
        return LAPACKE_sstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstedc(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstedc$descriptor() {
        return LAPACKE_dstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstedc$handle() {
        return LAPACKE_dstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstedc$address() {
        return LAPACKE_dstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstedc(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstedc$descriptor() {
        return LAPACKE_cstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cstedc$handle() {
        return LAPACKE_cstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cstedc$address() {
        return LAPACKE_cstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstedc(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstedc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstedc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstedc$descriptor() {
        return LAPACKE_zstedc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zstedc$handle() {
        return LAPACKE_zstedc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zstedc$address() {
        return LAPACKE_zstedc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstedc(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zstedc(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zstedc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstedc", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstegr$descriptor() {
        return LAPACKE_sstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_sstegr$handle() {
        return LAPACKE_sstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_sstegr$address() {
        return LAPACKE_sstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_sstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_sstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstegr$descriptor() {
        return LAPACKE_dstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dstegr$handle() {
        return LAPACKE_dstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dstegr$address() {
        return LAPACKE_dstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstegr$descriptor() {
        return LAPACKE_cstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_cstegr$handle() {
        return LAPACKE_cstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_cstegr$address() {
        return LAPACKE_cstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstegr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, _Complex float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_cstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_cstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstegr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstegr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstegr$descriptor() {
        return LAPACKE_zstegr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_zstegr$handle() {
        return LAPACKE_zstegr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_zstegr$address() {
        return LAPACKE_zstegr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstegr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, _Complex double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_zstegr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_zstegr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstegr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstein$descriptor() {
        return LAPACKE_sstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_sstein$handle() {
        return LAPACKE_sstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_sstein$address() {
        return LAPACKE_sstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, float *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_sstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_sstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstein$descriptor() {
        return LAPACKE_dstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_dstein$handle() {
        return LAPACKE_dstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_dstein$address() {
        return LAPACKE_dstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, double *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_dstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_dstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstein$descriptor() {
        return LAPACKE_cstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_cstein$handle() {
        return LAPACKE_cstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_cstein$address() {
        return LAPACKE_cstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstein(int matrix_layout, int n, const float *d, const float *e, int m, const float *w, const int *iblock, const int *isplit, _Complex float *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_cstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_cstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstein$descriptor() {
        return LAPACKE_zstein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static MethodHandle LAPACKE_zstein$handle() {
        return LAPACKE_zstein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static MemorySegment LAPACKE_zstein$address() {
        return LAPACKE_zstein.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstein(int matrix_layout, int n, const double *d, const double *e, int m, const double *w, const int *iblock, const int *isplit, _Complex double *z, int ldz, int *ifailv)
     * }
     */
    public static int LAPACKE_zstein(int matrix_layout, int n, MemorySegment d, MemorySegment e, int m, MemorySegment w, MemorySegment iblock, MemorySegment isplit, MemorySegment z, int ldz, MemorySegment ifailv) {
        var mh$ = LAPACKE_zstein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstein", matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, d, e, m, w, iblock, isplit, z, ldz, ifailv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstemr$descriptor() {
        return LAPACKE_sstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_sstemr$handle() {
        return LAPACKE_sstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_sstemr$address() {
        return LAPACKE_sstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_sstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_sstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstemr$descriptor() {
        return LAPACKE_dstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_dstemr$handle() {
        return LAPACKE_dstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_dstemr$address() {
        return LAPACKE_dstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_dstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_dstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_cstemr$descriptor() {
        return LAPACKE_cstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_cstemr$handle() {
        return LAPACKE_cstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_cstemr$address() {
        return LAPACKE_cstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cstemr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *m, float *w, _Complex float *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_cstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_cstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zstemr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zstemr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static FunctionDescriptor LAPACKE_zstemr$descriptor() {
        return LAPACKE_zstemr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MethodHandle LAPACKE_zstemr$handle() {
        return LAPACKE_zstemr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static MemorySegment LAPACKE_zstemr$address() {
        return LAPACKE_zstemr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zstemr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *m, double *w, _Complex double *z, int ldz, int nzc, int *isuppz, int *tryrac)
     * }
     */
    public static int LAPACKE_zstemr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, int nzc, MemorySegment isuppz, MemorySegment tryrac) {
        var mh$ = LAPACKE_zstemr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zstemr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, m, w, z, ldz, nzc, isuppz, tryrac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssteqr$descriptor() {
        return LAPACKE_ssteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_ssteqr$handle() {
        return LAPACKE_ssteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_ssteqr$address() {
        return LAPACKE_ssteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssteqr(int matrix_layout, char compz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_ssteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_ssteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsteqr$descriptor() {
        return LAPACKE_dsteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dsteqr$handle() {
        return LAPACKE_dsteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dsteqr$address() {
        return LAPACKE_dsteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsteqr(int matrix_layout, char compz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dsteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dsteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_csteqr$descriptor() {
        return LAPACKE_csteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_csteqr$handle() {
        return LAPACKE_csteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_csteqr$address() {
        return LAPACKE_csteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csteqr(int matrix_layout, char compz, int n, float *d, float *e, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_csteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_csteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsteqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsteqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsteqr$descriptor() {
        return LAPACKE_zsteqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zsteqr$handle() {
        return LAPACKE_zsteqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zsteqr$address() {
        return LAPACKE_zsteqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsteqr(int matrix_layout, char compz, int n, double *d, double *e, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zsteqr(int matrix_layout, byte compz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zsteqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsteqr", matrix_layout, compz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssterf$descriptor() {
        return LAPACKE_ssterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static MethodHandle LAPACKE_ssterf$handle() {
        return LAPACKE_ssterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static MemorySegment LAPACKE_ssterf$address() {
        return LAPACKE_ssterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssterf(int n, float *d, float *e)
     * }
     */
    public static int LAPACKE_ssterf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_ssterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssterf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsterf$descriptor() {
        return LAPACKE_dsterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static MethodHandle LAPACKE_dsterf$handle() {
        return LAPACKE_dsterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static MemorySegment LAPACKE_dsterf$address() {
        return LAPACKE_dsterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsterf(int n, double *d, double *e)
     * }
     */
    public static int LAPACKE_dsterf(int n, MemorySegment d, MemorySegment e) {
        var mh$ = LAPACKE_dsterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsterf", n, d, e);
            }
            return (int)mh$.invokeExact(n, d, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstev$descriptor() {
        return LAPACKE_sstev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstev$handle() {
        return LAPACKE_sstev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstev$address() {
        return LAPACKE_sstev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstev(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstev(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstev", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstev$descriptor() {
        return LAPACKE_dstev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstev$handle() {
        return LAPACKE_dstev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstev$address() {
        return LAPACKE_dstev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstev(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstev(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstev", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevd$descriptor() {
        return LAPACKE_sstevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sstevd$handle() {
        return LAPACKE_sstevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sstevd$address() {
        return LAPACKE_sstevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevd(int matrix_layout, char jobz, int n, float *d, float *e, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sstevd(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sstevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevd", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevd$descriptor() {
        return LAPACKE_dstevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dstevd$handle() {
        return LAPACKE_dstevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dstevd$address() {
        return LAPACKE_dstevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevd(int matrix_layout, char jobz, int n, double *d, double *e, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dstevd(int matrix_layout, byte jobz, int n, MemorySegment d, MemorySegment e, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dstevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevd", matrix_layout, jobz, n, d, e, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, n, d, e, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevr$descriptor() {
        return LAPACKE_sstevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_sstevr$handle() {
        return LAPACKE_sstevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_sstevr$address() {
        return LAPACKE_sstevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevr(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_sstevr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_sstevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevr$descriptor() {
        return LAPACKE_dstevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dstevr$handle() {
        return LAPACKE_dstevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dstevr$address() {
        return LAPACKE_dstevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevr(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dstevr(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dstevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevr", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sstevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sstevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_sstevx$descriptor() {
        return LAPACKE_sstevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_sstevx$handle() {
        return LAPACKE_sstevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_sstevx$address() {
        return LAPACKE_sstevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sstevx(int matrix_layout, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_sstevx(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_sstevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sstevx", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dstevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dstevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dstevx$descriptor() {
        return LAPACKE_dstevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dstevx$handle() {
        return LAPACKE_dstevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dstevx$address() {
        return LAPACKE_dstevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dstevx(int matrix_layout, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dstevx(int matrix_layout, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dstevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dstevx", matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, n, d, e, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssycon$descriptor() {
        return LAPACKE_ssycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ssycon$handle() {
        return LAPACKE_ssycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ssycon$address() {
        return LAPACKE_ssycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssycon(int matrix_layout, char uplo, int n, const float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_ssycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_ssycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsycon$descriptor() {
        return LAPACKE_dsycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dsycon$handle() {
        return LAPACKE_dsycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dsycon$address() {
        return LAPACKE_dsycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsycon(int matrix_layout, char uplo, int n, const double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dsycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dsycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_csycon$descriptor() {
        return LAPACKE_csycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_csycon$handle() {
        return LAPACKE_csycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_csycon$address() {
        return LAPACKE_csycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csycon(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_csycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_csycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsycon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsycon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsycon$descriptor() {
        return LAPACKE_zsycon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zsycon$handle() {
        return LAPACKE_zsycon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zsycon$address() {
        return LAPACKE_zsycon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsycon(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zsycon(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zsycon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsycon", matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyequb$descriptor() {
        return LAPACKE_ssyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_ssyequb$handle() {
        return LAPACKE_ssyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_ssyequb$address() {
        return LAPACKE_ssyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyequb(int matrix_layout, char uplo, int n, const float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_ssyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_ssyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyequb$descriptor() {
        return LAPACKE_dsyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dsyequb$handle() {
        return LAPACKE_dsyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dsyequb$address() {
        return LAPACKE_dsyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyequb(int matrix_layout, char uplo, int n, const double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_dsyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_dsyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyequb$descriptor() {
        return LAPACKE_csyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_csyequb$handle() {
        return LAPACKE_csyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_csyequb$address() {
        return LAPACKE_csyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyequb(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, float *s, float *scond, float *amax)
     * }
     */
    public static int LAPACKE_csyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_csyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyequb$descriptor() {
        return LAPACKE_zsyequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zsyequb$handle() {
        return LAPACKE_zsyequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zsyequb$address() {
        return LAPACKE_zsyequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyequb(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, double *s, double *scond, double *amax)
     * }
     */
    public static int LAPACKE_zsyequb(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment scond, MemorySegment amax) {
        var mh$ = LAPACKE_zsyequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyequb", matrix_layout, uplo, n, a, lda, s, scond, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, s, scond, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyev$descriptor() {
        return LAPACKE_ssyev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyev$handle() {
        return LAPACKE_ssyev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyev$address() {
        return LAPACKE_ssyev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyev(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyev$descriptor() {
        return LAPACKE_dsyev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyev$handle() {
        return LAPACKE_dsyev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyev$address() {
        return LAPACKE_dsyev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyev(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyev(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyev", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevd$descriptor() {
        return LAPACKE_ssyevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssyevd$handle() {
        return LAPACKE_ssyevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssyevd$address() {
        return LAPACKE_ssyevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevd(int matrix_layout, char jobz, char uplo, int n, float *a, int lda, float *w)
     * }
     */
    public static int LAPACKE_ssyevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_ssyevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevd$descriptor() {
        return LAPACKE_dsyevd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsyevd$handle() {
        return LAPACKE_dsyevd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsyevd$address() {
        return LAPACKE_dsyevd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevd(int matrix_layout, char jobz, char uplo, int n, double *a, int lda, double *w)
     * }
     */
    public static int LAPACKE_dsyevd(int matrix_layout, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment w) {
        var mh$ = LAPACKE_dsyevd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevd", matrix_layout, jobz, uplo, n, a, lda, w);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, uplo, n, a, lda, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevr$descriptor() {
        return LAPACKE_ssyevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_ssyevr$handle() {
        return LAPACKE_ssyevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_ssyevr$address() {
        return LAPACKE_ssyevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevr(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_ssyevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_ssyevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevr$descriptor() {
        return LAPACKE_dsyevr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MethodHandle LAPACKE_dsyevr$handle() {
        return LAPACKE_dsyevr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static MemorySegment LAPACKE_dsyevr$address() {
        return LAPACKE_dsyevr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevr(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *isuppz)
     * }
     */
    public static int LAPACKE_dsyevr(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment isuppz) {
        var mh$ = LAPACKE_dsyevr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevr", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, isuppz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyevx$descriptor() {
        return LAPACKE_ssyevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssyevx$handle() {
        return LAPACKE_ssyevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssyevx$address() {
        return LAPACKE_ssyevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyevx(int matrix_layout, char jobz, char range, char uplo, int n, float *a, int lda, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssyevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssyevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyevx$descriptor() {
        return LAPACKE_dsyevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsyevx$handle() {
        return LAPACKE_dsyevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsyevx$address() {
        return LAPACKE_dsyevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyevx(int matrix_layout, char jobz, char range, char uplo, int n, double *a, int lda, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsyevx(int matrix_layout, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsyevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyevx", matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, range, uplo, n, a, lda, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygst$descriptor() {
        return LAPACKE_ssygst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssygst$handle() {
        return LAPACKE_ssygst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssygst$address() {
        return LAPACKE_ssygst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygst(int matrix_layout, int itype, char uplo, int n, float *a, int lda, const float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssygst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssygst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygst$descriptor() {
        return LAPACKE_dsygst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsygst$handle() {
        return LAPACKE_dsygst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsygst$address() {
        return LAPACKE_dsygst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygst(int matrix_layout, int itype, char uplo, int n, double *a, int lda, const double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsygst(int matrix_layout, int itype, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsygst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygst", matrix_layout, itype, uplo, n, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, uplo, n, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygv$descriptor() {
        return LAPACKE_ssygv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssygv$handle() {
        return LAPACKE_ssygv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssygv$address() {
        return LAPACKE_ssygv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygv(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_ssygv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_ssygv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygv$descriptor() {
        return LAPACKE_dsygv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsygv$handle() {
        return LAPACKE_dsygv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsygv$address() {
        return LAPACKE_dsygv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygv(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_dsygv(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_dsygv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygv", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvd$descriptor() {
        return LAPACKE_ssygvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MethodHandle LAPACKE_ssygvd$handle() {
        return LAPACKE_ssygvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static MemorySegment LAPACKE_ssygvd$address() {
        return LAPACKE_ssygvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvd(int matrix_layout, int itype, char jobz, char uplo, int n, float *a, int lda, float *b, int ldb, float *w)
     * }
     */
    public static int LAPACKE_ssygvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_ssygvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvd$descriptor() {
        return LAPACKE_dsygvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MethodHandle LAPACKE_dsygvd$handle() {
        return LAPACKE_dsygvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static MemorySegment LAPACKE_dsygvd$address() {
        return LAPACKE_dsygvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvd(int matrix_layout, int itype, char jobz, char uplo, int n, double *a, int lda, double *b, int ldb, double *w)
     * }
     */
    public static int LAPACKE_dsygvd(int matrix_layout, int itype, byte jobz, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment w) {
        var mh$ = LAPACKE_dsygvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvd", matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, uplo, n, a, lda, b, ldb, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssygvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssygvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssygvx$descriptor() {
        return LAPACKE_ssygvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_ssygvx$handle() {
        return LAPACKE_ssygvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_ssygvx$address() {
        return LAPACKE_ssygvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, float *a, int lda, float *b, int ldb, float vl, float vu, int il, int iu, float abstol, int *m, float *w, float *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_ssygvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, float vl, float vu, int il, int iu, float abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_ssygvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssygvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsygvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsygvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsygvx$descriptor() {
        return LAPACKE_dsygvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MethodHandle LAPACKE_dsygvx$handle() {
        return LAPACKE_dsygvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static MemorySegment LAPACKE_dsygvx$address() {
        return LAPACKE_dsygvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsygvx(int matrix_layout, int itype, char jobz, char range, char uplo, int n, double *a, int lda, double *b, int ldb, double vl, double vu, int il, int iu, double abstol, int *m, double *w, double *z, int ldz, int *ifail)
     * }
     */
    public static int LAPACKE_dsygvx(int matrix_layout, int itype, byte jobz, byte range, byte uplo, int n, MemorySegment a, int lda, MemorySegment b, int ldb, double vl, double vu, int il, int iu, double abstol, MemorySegment m, MemorySegment w, MemorySegment z, int ldz, MemorySegment ifail) {
        var mh$ = LAPACKE_dsygvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsygvx", matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
            }
            return (int)mh$.invokeExact(matrix_layout, itype, jobz, range, uplo, n, a, lda, b, ldb, vl, vu, il, iu, abstol, m, w, z, ldz, ifail);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfs$descriptor() {
        return LAPACKE_ssyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfs$handle() {
        return LAPACKE_ssyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfs$address() {
        return LAPACKE_ssyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfs$descriptor() {
        return LAPACKE_dsyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfs$handle() {
        return LAPACKE_dsyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfs$address() {
        return LAPACKE_dsyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfs$descriptor() {
        return LAPACKE_csyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csyrfs$handle() {
        return LAPACKE_csyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csyrfs$address() {
        return LAPACKE_csyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfs$descriptor() {
        return LAPACKE_zsyrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfs$handle() {
        return LAPACKE_zsyrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfs$address() {
        return LAPACKE_zsyrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsyrfs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsyrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfs", matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssyrfsx$descriptor() {
        return LAPACKE_ssyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_ssyrfsx$handle() {
        return LAPACKE_ssyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_ssyrfsx$address() {
        return LAPACKE_ssyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *s, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_ssyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_ssyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsyrfsx$descriptor() {
        return LAPACKE_dsyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dsyrfsx$handle() {
        return LAPACKE_dsyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dsyrfsx$address() {
        return LAPACKE_dsyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *s, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dsyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dsyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_csyrfsx$descriptor() {
        return LAPACKE_csyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_csyrfsx$handle() {
        return LAPACKE_csyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_csyrfsx$address() {
        return LAPACKE_csyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *s, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_csyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_csyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsyrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsyrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsyrfsx$descriptor() {
        return LAPACKE_zsyrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zsyrfsx$handle() {
        return LAPACKE_zsyrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zsyrfsx$address() {
        return LAPACKE_zsyrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsyrfsx(int matrix_layout, char uplo, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *s, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zsyrfsx(int matrix_layout, byte uplo, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zsyrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsyrfsx", matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, equed, n, nrhs, a, lda, af, ldaf, ipiv, s, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysv$descriptor() {
        return LAPACKE_ssysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssysv$handle() {
        return LAPACKE_ssysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssysv$address() {
        return LAPACKE_ssysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysv(int matrix_layout, char uplo, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysv$descriptor() {
        return LAPACKE_dsysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsysv$handle() {
        return LAPACKE_dsysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsysv$address() {
        return LAPACKE_dsysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysv(int matrix_layout, char uplo, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysv$descriptor() {
        return LAPACKE_csysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csysv$handle() {
        return LAPACKE_csysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csysv$address() {
        return LAPACKE_csysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysv(int matrix_layout, char uplo, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysv$descriptor() {
        return LAPACKE_zsysv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsysv$handle() {
        return LAPACKE_zsysv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsysv$address() {
        return LAPACKE_zsysv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysv(int matrix_layout, char uplo, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsysv(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsysv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysv", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvx$descriptor() {
        return LAPACKE_ssysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ssysvx$handle() {
        return LAPACKE_ssysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ssysvx$address() {
        return LAPACKE_ssysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const float *a, int lda, float *af, int ldaf, int *ipiv, const float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ssysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ssysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvx$descriptor() {
        return LAPACKE_dsysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dsysvx$handle() {
        return LAPACKE_dsysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dsysvx$address() {
        return LAPACKE_dsysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const double *a, int lda, double *af, int ldaf, int *ipiv, const double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dsysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dsysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvx$descriptor() {
        return LAPACKE_csysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_csysvx$handle() {
        return LAPACKE_csysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_csysvx$address() {
        return LAPACKE_csysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_csysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_csysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvx$descriptor() {
        return LAPACKE_zsysvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zsysvx$handle() {
        return LAPACKE_zsysvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zsysvx$address() {
        return LAPACKE_zsysvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvx(int matrix_layout, char fact, char uplo, int n, int nrhs, const _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zsysvx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zsysvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, rcond, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssysvxx$descriptor() {
        return LAPACKE_ssysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_ssysvxx$handle() {
        return LAPACKE_ssysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_ssysvxx$address() {
        return LAPACKE_ssysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *s, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_ssysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_ssysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsysvxx$descriptor() {
        return LAPACKE_dsysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dsysvxx$handle() {
        return LAPACKE_dsysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dsysvxx$address() {
        return LAPACKE_dsysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *s, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dsysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dsysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_csysvxx$descriptor() {
        return LAPACKE_csysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_csysvxx$handle() {
        return LAPACKE_csysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_csysvxx$address() {
        return LAPACKE_csysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *s, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_csysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_csysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsysvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsysvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsysvxx$descriptor() {
        return LAPACKE_zsysvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zsysvxx$handle() {
        return LAPACKE_zsysvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zsysvxx$address() {
        return LAPACKE_zsysvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsysvxx(int matrix_layout, char fact, char uplo, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *s, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zsysvxx(int matrix_layout, byte fact, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment s, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zsysvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsysvxx", matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, equed, s, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrd$descriptor() {
        return LAPACKE_ssytrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ssytrd$handle() {
        return LAPACKE_ssytrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ssytrd$address() {
        return LAPACKE_ssytrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrd(int matrix_layout, char uplo, int n, float *a, int lda, float *d, float *e, float *tau)
     * }
     */
    public static int LAPACKE_ssytrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_ssytrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrd$descriptor() {
        return LAPACKE_dsytrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dsytrd$handle() {
        return LAPACKE_dsytrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dsytrd$address() {
        return LAPACKE_dsytrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrd(int matrix_layout, char uplo, int n, double *a, int lda, double *d, double *e, double *tau)
     * }
     */
    public static int LAPACKE_dsytrd(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tau) {
        var mh$ = LAPACKE_dsytrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrd", matrix_layout, uplo, n, a, lda, d, e, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, d, e, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrf$descriptor() {
        return LAPACKE_ssytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytrf$handle() {
        return LAPACKE_ssytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytrf$address() {
        return LAPACKE_ssytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrf(int matrix_layout, char uplo, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_ssytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrf$descriptor() {
        return LAPACKE_dsytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytrf$handle() {
        return LAPACKE_dsytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytrf$address() {
        return LAPACKE_dsytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrf(int matrix_layout, char uplo, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dsytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrf$descriptor() {
        return LAPACKE_csytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytrf$handle() {
        return LAPACKE_csytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytrf$address() {
        return LAPACKE_csytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrf(int matrix_layout, char uplo, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_csytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrf$descriptor() {
        return LAPACKE_zsytrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytrf$handle() {
        return LAPACKE_zsytrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytrf$address() {
        return LAPACKE_zsytrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrf(int matrix_layout, char uplo, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zsytrf(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrf", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytri$descriptor() {
        return LAPACKE_ssytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_ssytri$handle() {
        return LAPACKE_ssytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_ssytri$address() {
        return LAPACKE_ssytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytri(int matrix_layout, char uplo, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_ssytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_ssytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytri$descriptor() {
        return LAPACKE_dsytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dsytri$handle() {
        return LAPACKE_dsytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dsytri$address() {
        return LAPACKE_dsytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytri(int matrix_layout, char uplo, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dsytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dsytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytri$descriptor() {
        return LAPACKE_csytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_csytri$handle() {
        return LAPACKE_csytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_csytri$address() {
        return LAPACKE_csytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytri(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_csytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_csytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytri$descriptor() {
        return LAPACKE_zsytri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zsytri$handle() {
        return LAPACKE_zsytri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zsytri$address() {
        return LAPACKE_zsytri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytri(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zsytri(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zsytri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytri", matrix_layout, uplo, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ssytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ssytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ssytrs$descriptor() {
        return LAPACKE_ssytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ssytrs$handle() {
        return LAPACKE_ssytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ssytrs$address() {
        return LAPACKE_ssytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ssytrs(int matrix_layout, char uplo, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_ssytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ssytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ssytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsytrs$descriptor() {
        return LAPACKE_dsytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dsytrs$handle() {
        return LAPACKE_dsytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dsytrs$address() {
        return LAPACKE_dsytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsytrs(int matrix_layout, char uplo, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dsytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dsytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_csytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_csytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_csytrs$descriptor() {
        return LAPACKE_csytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_csytrs$handle() {
        return LAPACKE_csytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_csytrs$address() {
        return LAPACKE_csytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_csytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_csytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_csytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_csytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zsytrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zsytrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zsytrs$descriptor() {
        return LAPACKE_zsytrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zsytrs$handle() {
        return LAPACKE_zsytrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zsytrs$address() {
        return LAPACKE_zsytrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zsytrs(int matrix_layout, char uplo, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zsytrs(int matrix_layout, byte uplo, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zsytrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zsytrs", matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbcon$descriptor() {
        return LAPACKE_stbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_stbcon$handle() {
        return LAPACKE_stbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_stbcon$address() {
        return LAPACKE_stbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const float *ab, int ldab, float *rcond)
     * }
     */
    public static int LAPACKE_stbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_stbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbcon$descriptor() {
        return LAPACKE_dtbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtbcon$handle() {
        return LAPACKE_dtbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtbcon$address() {
        return LAPACKE_dtbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const double *ab, int ldab, double *rcond)
     * }
     */
    public static int LAPACKE_dtbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_dtbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbcon$descriptor() {
        return LAPACKE_ctbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctbcon$handle() {
        return LAPACKE_ctbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctbcon$address() {
        return LAPACKE_ctbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex float *ab, int ldab, float *rcond)
     * }
     */
    public static int LAPACKE_ctbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_ctbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbcon$descriptor() {
        return LAPACKE_ztbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztbcon$handle() {
        return LAPACKE_ztbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztbcon$address() {
        return LAPACKE_ztbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbcon(int matrix_layout, char norm, char uplo, char diag, int n, int kd, const _Complex double *ab, int ldab, double *rcond)
     * }
     */
    public static int LAPACKE_ztbcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, int kd, MemorySegment ab, int ldab, MemorySegment rcond) {
        var mh$ = LAPACKE_ztbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbcon", matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, kd, ab, ldab, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbrfs$descriptor() {
        return LAPACKE_stbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_stbrfs$handle() {
        return LAPACKE_stbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_stbrfs$address() {
        return LAPACKE_stbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_stbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_stbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbrfs$descriptor() {
        return LAPACKE_dtbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtbrfs$handle() {
        return LAPACKE_dtbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtbrfs$address() {
        return LAPACKE_dtbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbrfs$descriptor() {
        return LAPACKE_ctbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctbrfs$handle() {
        return LAPACKE_ctbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctbrfs$address() {
        return LAPACKE_ctbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbrfs$descriptor() {
        return LAPACKE_ztbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztbrfs$handle() {
        return LAPACKE_ztbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztbrfs$address() {
        return LAPACKE_ztbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbrfs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztbrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbrfs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stbtrs$descriptor() {
        return LAPACKE_stbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stbtrs$handle() {
        return LAPACKE_stbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stbtrs$address() {
        return LAPACKE_stbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const float *ab, int ldab, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtbtrs$descriptor() {
        return LAPACKE_dtbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtbtrs$handle() {
        return LAPACKE_dtbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtbtrs$address() {
        return LAPACKE_dtbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const double *ab, int ldab, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctbtrs$descriptor() {
        return LAPACKE_ctbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctbtrs$handle() {
        return LAPACKE_ctbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctbtrs$address() {
        return LAPACKE_ctbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex float *ab, int ldab, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztbtrs$descriptor() {
        return LAPACKE_ztbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztbtrs$handle() {
        return LAPACKE_ztbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztbtrs$address() {
        return LAPACKE_ztbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztbtrs(int matrix_layout, char uplo, char trans, char diag, int n, int kd, int nrhs, const _Complex double *ab, int ldab, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztbtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int kd, int nrhs, MemorySegment ab, int ldab, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztbtrs", matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, kd, nrhs, ab, ldab, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfsm$descriptor() {
        return LAPACKE_stfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stfsm$handle() {
        return LAPACKE_stfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stfsm$address() {
        return LAPACKE_stfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, float alpha, const float *a, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfsm$descriptor() {
        return LAPACKE_dtfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtfsm$handle() {
        return LAPACKE_dtfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtfsm$address() {
        return LAPACKE_dtfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, double alpha, const double *a, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfsm$descriptor() {
        return LAPACKE_ctfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctfsm$handle() {
        return LAPACKE_ctfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctfsm$address() {
        return LAPACKE_ctfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex float alpha, const _Complex float *a, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, float alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfsm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfsm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfsm$descriptor() {
        return LAPACKE_ztfsm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztfsm$handle() {
        return LAPACKE_ztfsm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztfsm$address() {
        return LAPACKE_ztfsm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfsm(int matrix_layout, char transr, char side, char uplo, char trans, char diag, int m, int n, _Complex double alpha, const _Complex double *a, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztfsm(int matrix_layout, byte transr, byte side, byte uplo, byte trans, byte diag, int m, int n, double alpha, MemorySegment a, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztfsm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfsm", matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, side, uplo, trans, diag, m, n, alpha, a, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_stftri$descriptor() {
        return LAPACKE_stftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MethodHandle LAPACKE_stftri$handle() {
        return LAPACKE_stftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static MemorySegment LAPACKE_stftri$address() {
        return LAPACKE_stftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stftri(int matrix_layout, char transr, char uplo, char diag, int n, float *a)
     * }
     */
    public static int LAPACKE_stftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_stftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtftri$descriptor() {
        return LAPACKE_dtftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MethodHandle LAPACKE_dtftri$handle() {
        return LAPACKE_dtftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static MemorySegment LAPACKE_dtftri$address() {
        return LAPACKE_dtftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtftri(int matrix_layout, char transr, char uplo, char diag, int n, double *a)
     * }
     */
    public static int LAPACKE_dtftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_dtftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctftri$descriptor() {
        return LAPACKE_ctftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MethodHandle LAPACKE_ctftri$handle() {
        return LAPACKE_ctftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static MemorySegment LAPACKE_ctftri$address() {
        return LAPACKE_ctftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex float *a)
     * }
     */
    public static int LAPACKE_ctftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ctftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztftri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztftri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztftri$descriptor() {
        return LAPACKE_ztftri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MethodHandle LAPACKE_ztftri$handle() {
        return LAPACKE_ztftri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static MemorySegment LAPACKE_ztftri$address() {
        return LAPACKE_ztftri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztftri(int matrix_layout, char transr, char uplo, char diag, int n, _Complex double *a)
     * }
     */
    public static int LAPACKE_ztftri(int matrix_layout, byte transr, byte uplo, byte diag, int n, MemorySegment a) {
        var mh$ = LAPACKE_ztftri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztftri", matrix_layout, transr, uplo, diag, n, a);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, diag, n, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttp$descriptor() {
        return LAPACKE_stfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stfttp$handle() {
        return LAPACKE_stfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stfttp$address() {
        return LAPACKE_stfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttp(int matrix_layout, char transr, char uplo, int n, const float *arf, float *ap)
     * }
     */
    public static int LAPACKE_stfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_stfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttp$descriptor() {
        return LAPACKE_dtfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtfttp$handle() {
        return LAPACKE_dtfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtfttp$address() {
        return LAPACKE_dtfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttp(int matrix_layout, char transr, char uplo, int n, const double *arf, double *ap)
     * }
     */
    public static int LAPACKE_dtfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_dtfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttp$descriptor() {
        return LAPACKE_ctfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctfttp$handle() {
        return LAPACKE_ctfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctfttp$address() {
        return LAPACKE_ctfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttp(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ctfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttp$descriptor() {
        return LAPACKE_ztfttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztfttp$handle() {
        return LAPACKE_ztfttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztfttp$address() {
        return LAPACKE_ztfttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttp(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztfttp(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment ap) {
        var mh$ = LAPACKE_ztfttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttp", matrix_layout, transr, uplo, n, arf, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stfttr$descriptor() {
        return LAPACKE_stfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stfttr$handle() {
        return LAPACKE_stfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stfttr$address() {
        return LAPACKE_stfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stfttr(int matrix_layout, char transr, char uplo, int n, const float *arf, float *a, int lda)
     * }
     */
    public static int LAPACKE_stfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtfttr$descriptor() {
        return LAPACKE_dtfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtfttr$handle() {
        return LAPACKE_dtfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtfttr$address() {
        return LAPACKE_dtfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtfttr(int matrix_layout, char transr, char uplo, int n, const double *arf, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctfttr$descriptor() {
        return LAPACKE_ctfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctfttr$handle() {
        return LAPACKE_ctfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctfttr$address() {
        return LAPACKE_ctfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctfttr(int matrix_layout, char transr, char uplo, int n, const _Complex float *arf, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztfttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztfttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztfttr$descriptor() {
        return LAPACKE_ztfttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztfttr$handle() {
        return LAPACKE_ztfttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztfttr$address() {
        return LAPACKE_ztfttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztfttr(int matrix_layout, char transr, char uplo, int n, const _Complex double *arf, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztfttr(int matrix_layout, byte transr, byte uplo, int n, MemorySegment arf, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztfttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztfttr", matrix_layout, transr, uplo, n, arf, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, arf, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgevc$descriptor() {
        return LAPACKE_stgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_stgevc$handle() {
        return LAPACKE_stgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_stgevc$address() {
        return LAPACKE_stgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgevc(int matrix_layout, char side, char howmny, const int *select, int n, const float *s, int lds, const float *p, int ldp, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_stgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_stgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgevc$descriptor() {
        return LAPACKE_dtgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtgevc$handle() {
        return LAPACKE_dtgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtgevc$address() {
        return LAPACKE_dtgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgevc(int matrix_layout, char side, char howmny, const int *select, int n, const double *s, int lds, const double *p, int ldp, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgevc$descriptor() {
        return LAPACKE_ctgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctgevc$handle() {
        return LAPACKE_ctgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctgevc$address() {
        return LAPACKE_ctgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex float *s, int lds, const _Complex float *p, int ldp, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgevc$descriptor() {
        return LAPACKE_ztgevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztgevc$handle() {
        return LAPACKE_ztgevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztgevc$address() {
        return LAPACKE_ztgevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgevc(int matrix_layout, char side, char howmny, const int *select, int n, const _Complex double *s, int lds, const _Complex double *p, int ldp, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztgevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment s, int lds, MemorySegment p, int ldp, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztgevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgevc", matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, s, lds, p, ldp, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgexc$descriptor() {
        return LAPACKE_stgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_stgexc$handle() {
        return LAPACKE_stgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_stgexc$address() {
        return LAPACKE_stgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_stgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_stgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgexc$descriptor() {
        return LAPACKE_dtgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_dtgexc$handle() {
        return LAPACKE_dtgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_dtgexc$address() {
        return LAPACKE_dtgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_dtgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_dtgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgexc$descriptor() {
        return LAPACKE_ctgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctgexc$handle() {
        return LAPACKE_ctgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctgexc$address() {
        return LAPACKE_ctgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ctgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgexc$descriptor() {
        return LAPACKE_ztgexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztgexc$handle() {
        return LAPACKE_ztgexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztgexc$address() {
        return LAPACKE_ztgexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztgexc(int matrix_layout, int wantq, int wantz, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, int ifst, int ilst) {
        var mh$ = LAPACKE_ztgexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgexc", matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsen$descriptor() {
        return LAPACKE_stgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_stgsen$handle() {
        return LAPACKE_stgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_stgsen$address() {
        return LAPACKE_stgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *q, int ldq, float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static int LAPACKE_stgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_stgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsen$descriptor() {
        return LAPACKE_dtgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_dtgsen$handle() {
        return LAPACKE_dtgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_dtgsen$address() {
        return LAPACKE_dtgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *q, int ldq, double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static int LAPACKE_dtgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_dtgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alphar, alphai, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsen$descriptor() {
        return LAPACKE_ctgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_ctgsen$handle() {
        return LAPACKE_ctgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_ctgsen$address() {
        return LAPACKE_ctgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *q, int ldq, _Complex float *z, int ldz, int *m, float *pl, float *pr, float *dif)
     * }
     */
    public static int LAPACKE_ctgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_ctgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsen$descriptor() {
        return LAPACKE_ztgsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_ztgsen$handle() {
        return LAPACKE_ztgsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_ztgsen$address() {
        return LAPACKE_ztgsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, const int *select, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *q, int ldq, _Complex double *z, int ldz, int *m, double *pl, double *pr, double *dif)
     * }
     */
    public static int LAPACKE_ztgsen(int matrix_layout, int ijob, int wantq, int wantz, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment dif) {
        var mh$ = LAPACKE_ztgsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsen", matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, ijob, wantq, wantz, select, n, a, lda, b, ldb, alpha, beta, q, ldq, z, ldz, m, pl, pr, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsja$descriptor() {
        return LAPACKE_stgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_stgsja$handle() {
        return LAPACKE_stgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_stgsja$address() {
        return LAPACKE_stgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, float *a, int lda, float *b, int ldb, float tola, float tolb, float *alpha, float *beta, float *u, int ldu, float *v, int ldv, float *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_stgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_stgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsja$descriptor() {
        return LAPACKE_dtgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_dtgsja$handle() {
        return LAPACKE_dtgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_dtgsja$address() {
        return LAPACKE_dtgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, double *a, int lda, double *b, int ldb, double tola, double tolb, double *alpha, double *beta, double *u, int ldu, double *v, int ldv, double *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_dtgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_dtgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsja$descriptor() {
        return LAPACKE_ctgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ctgsja$handle() {
        return LAPACKE_ctgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ctgsja$address() {
        return LAPACKE_ctgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex float *a, int lda, _Complex float *b, int ldb, float tola, float tolb, float *alpha, float *beta, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_ctgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, float tola, float tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_ctgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsja {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsja");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsja$descriptor() {
        return LAPACKE_ztgsja.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static MethodHandle LAPACKE_ztgsja$handle() {
        return LAPACKE_ztgsja.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static MemorySegment LAPACKE_ztgsja$address() {
        return LAPACKE_ztgsja.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsja(int matrix_layout, char jobu, char jobv, char jobq, int m, int p, int n, int k, int l, _Complex double *a, int lda, _Complex double *b, int ldb, double tola, double tolb, double *alpha, double *beta, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *q, int ldq, int *ncycle)
     * }
     */
    public static int LAPACKE_ztgsja(int matrix_layout, byte jobu, byte jobv, byte jobq, int m, int p, int n, int k, int l, MemorySegment a, int lda, MemorySegment b, int ldb, double tola, double tolb, MemorySegment alpha, MemorySegment beta, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment q, int ldq, MemorySegment ncycle) {
        var mh$ = LAPACKE_ztgsja.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsja", matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobv, jobq, m, p, n, k, l, a, lda, b, ldb, tola, tolb, alpha, beta, u, ldu, v, ldv, q, ldq, ncycle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsna$descriptor() {
        return LAPACKE_stgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_stgsna$handle() {
        return LAPACKE_stgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_stgsna$address() {
        return LAPACKE_stgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *a, int lda, const float *b, int ldb, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_stgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_stgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsna$descriptor() {
        return LAPACKE_dtgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtgsna$handle() {
        return LAPACKE_dtgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtgsna$address() {
        return LAPACKE_dtgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *a, int lda, const double *b, int ldb, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsna$descriptor() {
        return LAPACKE_ctgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctgsna$handle() {
        return LAPACKE_ctgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctgsna$address() {
        return LAPACKE_ctgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsna$descriptor() {
        return LAPACKE_ztgsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztgsna$handle() {
        return LAPACKE_ztgsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztgsna$address() {
        return LAPACKE_ztgsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *dif, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztgsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment dif, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztgsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsna", matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, a, lda, b, ldb, vl, ldvl, vr, ldvr, s, dif, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_stgsyl$descriptor() {
        return LAPACKE_stgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_stgsyl$handle() {
        return LAPACKE_stgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_stgsyl$address() {
        return LAPACKE_stgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stgsyl(int matrix_layout, char trans, int ijob, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, const float *d, int ldd, const float *e, int lde, float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static int LAPACKE_stgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_stgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtgsyl$descriptor() {
        return LAPACKE_dtgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_dtgsyl$handle() {
        return LAPACKE_dtgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_dtgsyl$address() {
        return LAPACKE_dtgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtgsyl(int matrix_layout, char trans, int ijob, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, const double *d, int ldd, const double *e, int lde, double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static int LAPACKE_dtgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_dtgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctgsyl$descriptor() {
        return LAPACKE_ctgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MethodHandle LAPACKE_ctgsyl$handle() {
        return LAPACKE_ctgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static MemorySegment LAPACKE_ctgsyl$address() {
        return LAPACKE_ctgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, const _Complex float *d, int ldd, const _Complex float *e, int lde, _Complex float *f, int ldf, float *scale, float *dif)
     * }
     */
    public static int LAPACKE_ctgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_ctgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztgsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztgsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztgsyl$descriptor() {
        return LAPACKE_ztgsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MethodHandle LAPACKE_ztgsyl$handle() {
        return LAPACKE_ztgsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static MemorySegment LAPACKE_ztgsyl$address() {
        return LAPACKE_ztgsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztgsyl(int matrix_layout, char trans, int ijob, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, const _Complex double *d, int ldd, const _Complex double *e, int lde, _Complex double *f, int ldf, double *scale, double *dif)
     * }
     */
    public static int LAPACKE_ztgsyl(int matrix_layout, byte trans, int ijob, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment d, int ldd, MemorySegment e, int lde, MemorySegment f, int ldf, MemorySegment scale, MemorySegment dif) {
        var mh$ = LAPACKE_ztgsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztgsyl", matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, ijob, m, n, a, lda, b, ldb, c, ldc, d, ldd, e, lde, f, ldf, scale, dif);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpcon$descriptor() {
        return LAPACKE_stpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_stpcon$handle() {
        return LAPACKE_stpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_stpcon$address() {
        return LAPACKE_stpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *ap, float *rcond)
     * }
     */
    public static int LAPACKE_stpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_stpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpcon$descriptor() {
        return LAPACKE_dtpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtpcon$handle() {
        return LAPACKE_dtpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtpcon$address() {
        return LAPACKE_dtpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *ap, double *rcond)
     * }
     */
    public static int LAPACKE_dtpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_dtpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpcon$descriptor() {
        return LAPACKE_ctpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctpcon$handle() {
        return LAPACKE_ctpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctpcon$address() {
        return LAPACKE_ctpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *ap, float *rcond)
     * }
     */
    public static int LAPACKE_ctpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_ctpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpcon$descriptor() {
        return LAPACKE_ztpcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztpcon$handle() {
        return LAPACKE_ztpcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztpcon$address() {
        return LAPACKE_ztpcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *ap, double *rcond)
     * }
     */
    public static int LAPACKE_ztpcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment ap, MemorySegment rcond) {
        var mh$ = LAPACKE_ztpcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpcon", matrix_layout, norm, uplo, diag, n, ap, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, ap, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_stprfs$descriptor() {
        return LAPACKE_stprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_stprfs$handle() {
        return LAPACKE_stprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_stprfs$address() {
        return LAPACKE_stprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_stprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_stprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtprfs$descriptor() {
        return LAPACKE_dtprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtprfs$handle() {
        return LAPACKE_dtprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtprfs$address() {
        return LAPACKE_dtprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctprfs$descriptor() {
        return LAPACKE_ctprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctprfs$handle() {
        return LAPACKE_ctprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctprfs$address() {
        return LAPACKE_ctprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztprfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztprfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztprfs$descriptor() {
        return LAPACKE_ztprfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztprfs$handle() {
        return LAPACKE_ztprfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztprfs$address() {
        return LAPACKE_ztprfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztprfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztprfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztprfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztprfs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptri$descriptor() {
        return LAPACKE_stptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_stptri$handle() {
        return LAPACKE_stptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_stptri$address() {
        return LAPACKE_stptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptri(int matrix_layout, char uplo, char diag, int n, float *ap)
     * }
     */
    public static int LAPACKE_stptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_stptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptri$descriptor() {
        return LAPACKE_dtptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtptri$handle() {
        return LAPACKE_dtptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtptri$address() {
        return LAPACKE_dtptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptri(int matrix_layout, char uplo, char diag, int n, double *ap)
     * }
     */
    public static int LAPACKE_dtptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_dtptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptri$descriptor() {
        return LAPACKE_ctptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctptri$handle() {
        return LAPACKE_ctptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctptri$address() {
        return LAPACKE_ctptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptri(int matrix_layout, char uplo, char diag, int n, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ctptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztptri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptri$descriptor() {
        return LAPACKE_ztptri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztptri$handle() {
        return LAPACKE_ztptri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztptri$address() {
        return LAPACKE_ztptri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptri(int matrix_layout, char uplo, char diag, int n, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztptri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment ap) {
        var mh$ = LAPACKE_ztptri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptri", matrix_layout, uplo, diag, n, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_stptrs$descriptor() {
        return LAPACKE_stptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_stptrs$handle() {
        return LAPACKE_stptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_stptrs$address() {
        return LAPACKE_stptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *ap, float *b, int ldb)
     * }
     */
    public static int LAPACKE_stptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_stptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtptrs$descriptor() {
        return LAPACKE_dtptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtptrs$handle() {
        return LAPACKE_dtptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtptrs$address() {
        return LAPACKE_dtptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *ap, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctptrs$descriptor() {
        return LAPACKE_ctptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctptrs$handle() {
        return LAPACKE_ctptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctptrs$address() {
        return LAPACKE_ctptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *ap, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztptrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztptrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztptrs$descriptor() {
        return LAPACKE_ztptrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztptrs$handle() {
        return LAPACKE_ztptrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztptrs$address() {
        return LAPACKE_ztptrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztptrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *ap, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztptrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment ap, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztptrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztptrs", matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, ap, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttf$descriptor() {
        return LAPACKE_stpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_stpttf$handle() {
        return LAPACKE_stpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_stpttf$address() {
        return LAPACKE_stpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttf(int matrix_layout, char transr, char uplo, int n, const float *ap, float *arf)
     * }
     */
    public static int LAPACKE_stpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_stpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttf$descriptor() {
        return LAPACKE_dtpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtpttf$handle() {
        return LAPACKE_dtpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtpttf$address() {
        return LAPACKE_dtpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttf(int matrix_layout, char transr, char uplo, int n, const double *ap, double *arf)
     * }
     */
    public static int LAPACKE_dtpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_dtpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttf$descriptor() {
        return LAPACKE_ctpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctpttf$handle() {
        return LAPACKE_ctpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctpttf$address() {
        return LAPACKE_ctpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *ap, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ctpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttf$descriptor() {
        return LAPACKE_ztpttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztpttf$handle() {
        return LAPACKE_ztpttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztpttf$address() {
        return LAPACKE_ztpttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *ap, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztpttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment ap, MemorySegment arf) {
        var mh$ = LAPACKE_ztpttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttf", matrix_layout, transr, uplo, n, ap, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, ap, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_stpttr$descriptor() {
        return LAPACKE_stpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_stpttr$handle() {
        return LAPACKE_stpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_stpttr$address() {
        return LAPACKE_stpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stpttr(int matrix_layout, char uplo, int n, const float *ap, float *a, int lda)
     * }
     */
    public static int LAPACKE_stpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_stpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtpttr$descriptor() {
        return LAPACKE_dtpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtpttr$handle() {
        return LAPACKE_dtpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtpttr$address() {
        return LAPACKE_dtpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtpttr(int matrix_layout, char uplo, int n, const double *ap, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctpttr$descriptor() {
        return LAPACKE_ctpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctpttr$handle() {
        return LAPACKE_ctpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctpttr$address() {
        return LAPACKE_ctpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctpttr(int matrix_layout, char uplo, int n, const _Complex float *ap, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztpttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztpttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztpttr$descriptor() {
        return LAPACKE_ztpttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztpttr$handle() {
        return LAPACKE_ztpttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztpttr$address() {
        return LAPACKE_ztpttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztpttr(int matrix_layout, char uplo, int n, const _Complex double *ap, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztpttr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztpttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztpttr", matrix_layout, uplo, n, ap, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_strcon$descriptor() {
        return LAPACKE_strcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_strcon$handle() {
        return LAPACKE_strcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_strcon$address() {
        return LAPACKE_strcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strcon(int matrix_layout, char norm, char uplo, char diag, int n, const float *a, int lda, float *rcond)
     * }
     */
    public static int LAPACKE_strcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_strcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrcon$descriptor() {
        return LAPACKE_dtrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dtrcon$handle() {
        return LAPACKE_dtrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dtrcon$address() {
        return LAPACKE_dtrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrcon(int matrix_layout, char norm, char uplo, char diag, int n, const double *a, int lda, double *rcond)
     * }
     */
    public static int LAPACKE_dtrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_dtrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrcon$descriptor() {
        return LAPACKE_ctrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ctrcon$handle() {
        return LAPACKE_ctrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ctrcon$address() {
        return LAPACKE_ctrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex float *a, int lda, float *rcond)
     * }
     */
    public static int LAPACKE_ctrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_ctrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrcon$descriptor() {
        return LAPACKE_ztrcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_ztrcon$handle() {
        return LAPACKE_ztrcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_ztrcon$address() {
        return LAPACKE_ztrcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrcon(int matrix_layout, char norm, char uplo, char diag, int n, const _Complex double *a, int lda, double *rcond)
     * }
     */
    public static int LAPACKE_ztrcon(int matrix_layout, byte norm, byte uplo, byte diag, int n, MemorySegment a, int lda, MemorySegment rcond) {
        var mh$ = LAPACKE_ztrcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrcon", matrix_layout, norm, uplo, diag, n, a, lda, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, uplo, diag, n, a, lda, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_strevc$descriptor() {
        return LAPACKE_strevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_strevc$handle() {
        return LAPACKE_strevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_strevc$address() {
        return LAPACKE_strevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strevc(int matrix_layout, char side, char howmny, int *select, int n, const float *t, int ldt, float *vl, int ldvl, float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_strevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_strevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrevc$descriptor() {
        return LAPACKE_dtrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtrevc$handle() {
        return LAPACKE_dtrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtrevc$address() {
        return LAPACKE_dtrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrevc(int matrix_layout, char side, char howmny, int *select, int n, const double *t, int ldt, double *vl, int ldvl, double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrevc$descriptor() {
        return LAPACKE_ctrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctrevc$handle() {
        return LAPACKE_ctrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctrevc$address() {
        return LAPACKE_ctrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex float *t, int ldt, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrevc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrevc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrevc$descriptor() {
        return LAPACKE_ztrevc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztrevc$handle() {
        return LAPACKE_ztrevc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztrevc$address() {
        return LAPACKE_ztrevc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrevc(int matrix_layout, char side, char howmny, const int *select, int n, _Complex double *t, int ldt, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztrevc(int matrix_layout, byte side, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztrevc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrevc", matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, side, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_strexc$descriptor() {
        return LAPACKE_strexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_strexc$handle() {
        return LAPACKE_strexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_strexc$address() {
        return LAPACKE_strexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strexc(int matrix_layout, char compq, int n, float *t, int ldt, float *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_strexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_strexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrexc$descriptor() {
        return LAPACKE_dtrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MethodHandle LAPACKE_dtrexc$handle() {
        return LAPACKE_dtrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static MemorySegment LAPACKE_dtrexc$address() {
        return LAPACKE_dtrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrexc(int matrix_layout, char compq, int n, double *t, int ldt, double *q, int ldq, int *ifst, int *ilst)
     * }
     */
    public static int LAPACKE_dtrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment ifst, MemorySegment ilst) {
        var mh$ = LAPACKE_dtrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrexc$descriptor() {
        return LAPACKE_ctrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ctrexc$handle() {
        return LAPACKE_ctrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ctrexc$address() {
        return LAPACKE_ctrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrexc(int matrix_layout, char compq, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ctrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ctrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrexc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrexc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrexc$descriptor() {
        return LAPACKE_ztrexc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MethodHandle LAPACKE_ztrexc$handle() {
        return LAPACKE_ztrexc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static MemorySegment LAPACKE_ztrexc$address() {
        return LAPACKE_ztrexc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrexc(int matrix_layout, char compq, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, int ifst, int ilst)
     * }
     */
    public static int LAPACKE_ztrexc(int matrix_layout, byte compq, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, int ifst, int ilst) {
        var mh$ = LAPACKE_ztrexc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrexc", matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, n, t, ldt, q, ldq, ifst, ilst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_strrfs$descriptor() {
        return LAPACKE_strrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_strrfs$handle() {
        return LAPACKE_strrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_strrfs$address() {
        return LAPACKE_strrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, const float *b, int ldb, const float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_strrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_strrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrrfs$descriptor() {
        return LAPACKE_dtrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dtrrfs$handle() {
        return LAPACKE_dtrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dtrrfs$address() {
        return LAPACKE_dtrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, const double *b, int ldb, const double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dtrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dtrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrrfs$descriptor() {
        return LAPACKE_ctrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_ctrrfs$handle() {
        return LAPACKE_ctrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_ctrrfs$address() {
        return LAPACKE_ctrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *b, int ldb, const _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_ctrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ctrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrrfs$descriptor() {
        return LAPACKE_ztrrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_ztrrfs$handle() {
        return LAPACKE_ztrrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_ztrrfs$address() {
        return LAPACKE_ztrrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrrfs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *b, int ldb, const _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_ztrrfs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_ztrrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrrfs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsen$descriptor() {
        return LAPACKE_strsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_strsen$handle() {
        return LAPACKE_strsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_strsen$address() {
        return LAPACKE_strsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsen(int matrix_layout, char job, char compq, const int *select, int n, float *t, int ldt, float *q, int ldq, float *wr, float *wi, int *m, float *s, float *sep)
     * }
     */
    public static int LAPACKE_strsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_strsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsen$descriptor() {
        return LAPACKE_dtrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_dtrsen$handle() {
        return LAPACKE_dtrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_dtrsen$address() {
        return LAPACKE_dtrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsen(int matrix_layout, char job, char compq, const int *select, int n, double *t, int ldt, double *q, int ldq, double *wr, double *wi, int *m, double *s, double *sep)
     * }
     */
    public static int LAPACKE_dtrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment wr, MemorySegment wi, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_dtrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, wr, wi, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsen$descriptor() {
        return LAPACKE_ctrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_ctrsen$handle() {
        return LAPACKE_ctrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_ctrsen$address() {
        return LAPACKE_ctrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex float *t, int ldt, _Complex float *q, int ldq, _Complex float *w, int *m, float *s, float *sep)
     * }
     */
    public static int LAPACKE_ctrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_ctrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsen$descriptor() {
        return LAPACKE_ztrsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ztrsen$handle() {
        return LAPACKE_ztrsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ztrsen$address() {
        return LAPACKE_ztrsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsen(int matrix_layout, char job, char compq, const int *select, int n, _Complex double *t, int ldt, _Complex double *q, int ldq, _Complex double *w, int *m, double *s, double *sep)
     * }
     */
    public static int LAPACKE_ztrsen(int matrix_layout, byte job, byte compq, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment q, int ldq, MemorySegment w, MemorySegment m, MemorySegment s, MemorySegment sep) {
        var mh$ = LAPACKE_ztrsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsen", matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
            }
            return (int)mh$.invokeExact(matrix_layout, job, compq, select, n, t, ldt, q, ldq, w, m, s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsna$descriptor() {
        return LAPACKE_strsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_strsna$handle() {
        return LAPACKE_strsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_strsna$address() {
        return LAPACKE_strsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsna(int matrix_layout, char job, char howmny, const int *select, int n, const float *t, int ldt, const float *vl, int ldvl, const float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_strsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_strsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsna$descriptor() {
        return LAPACKE_dtrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_dtrsna$handle() {
        return LAPACKE_dtrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_dtrsna$address() {
        return LAPACKE_dtrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsna(int matrix_layout, char job, char howmny, const int *select, int n, const double *t, int ldt, const double *vl, int ldvl, const double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_dtrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_dtrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsna$descriptor() {
        return LAPACKE_ctrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ctrsna$handle() {
        return LAPACKE_ctrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ctrsna$address() {
        return LAPACKE_ctrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex float *t, int ldt, const _Complex float *vl, int ldvl, const _Complex float *vr, int ldvr, float *s, float *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_ctrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ctrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsna$descriptor() {
        return LAPACKE_ztrsna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MethodHandle LAPACKE_ztrsna$handle() {
        return LAPACKE_ztrsna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static MemorySegment LAPACKE_ztrsna$address() {
        return LAPACKE_ztrsna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsna(int matrix_layout, char job, char howmny, const int *select, int n, const _Complex double *t, int ldt, const _Complex double *vl, int ldvl, const _Complex double *vr, int ldvr, double *s, double *sep, int mm, int *m)
     * }
     */
    public static int LAPACKE_ztrsna(int matrix_layout, byte job, byte howmny, MemorySegment select, int n, MemorySegment t, int ldt, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment s, MemorySegment sep, int mm, MemorySegment m) {
        var mh$ = LAPACKE_ztrsna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsna", matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
            }
            return (int)mh$.invokeExact(matrix_layout, job, howmny, select, n, t, ldt, vl, ldvl, vr, ldvr, s, sep, mm, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_strsyl$descriptor() {
        return LAPACKE_strsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_strsyl$handle() {
        return LAPACKE_strsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_strsyl$address() {
        return LAPACKE_strsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const float *a, int lda, const float *b, int ldb, float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_strsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_strsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrsyl$descriptor() {
        return LAPACKE_dtrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dtrsyl$handle() {
        return LAPACKE_dtrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dtrsyl$address() {
        return LAPACKE_dtrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const double *a, int lda, const double *b, int ldb, double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_dtrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_dtrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrsyl$descriptor() {
        return LAPACKE_ctrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_ctrsyl$handle() {
        return LAPACKE_ctrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_ctrsyl$address() {
        return LAPACKE_ctrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex float *a, int lda, const _Complex float *b, int ldb, _Complex float *c, int ldc, float *scale)
     * }
     */
    public static int LAPACKE_ctrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ctrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrsyl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrsyl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrsyl$descriptor() {
        return LAPACKE_ztrsyl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_ztrsyl$handle() {
        return LAPACKE_ztrsyl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_ztrsyl$address() {
        return LAPACKE_ztrsyl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrsyl(int matrix_layout, char trana, char tranb, int isgn, int m, int n, const _Complex double *a, int lda, const _Complex double *b, int ldb, _Complex double *c, int ldc, double *scale)
     * }
     */
    public static int LAPACKE_ztrsyl(int matrix_layout, byte trana, byte tranb, int isgn, int m, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, int ldc, MemorySegment scale) {
        var mh$ = LAPACKE_ztrsyl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrsyl", matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtri$descriptor() {
        return LAPACKE_strtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_strtri$handle() {
        return LAPACKE_strtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_strtri$address() {
        return LAPACKE_strtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtri(int matrix_layout, char uplo, char diag, int n, float *a, int lda)
     * }
     */
    public static int LAPACKE_strtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_strtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtri$descriptor() {
        return LAPACKE_dtrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_dtrtri$handle() {
        return LAPACKE_dtrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_dtrtri$address() {
        return LAPACKE_dtrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtri(int matrix_layout, char uplo, char diag, int n, double *a, int lda)
     * }
     */
    public static int LAPACKE_dtrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_dtrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtri$descriptor() {
        return LAPACKE_ctrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ctrtri$handle() {
        return LAPACKE_ctrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ctrtri$address() {
        return LAPACKE_ctrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtri(int matrix_layout, char uplo, char diag, int n, _Complex float *a, int lda)
     * }
     */
    public static int LAPACKE_ctrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ctrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrtri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtri$descriptor() {
        return LAPACKE_ztrtri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MethodHandle LAPACKE_ztrtri$handle() {
        return LAPACKE_ztrtri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static MemorySegment LAPACKE_ztrtri$address() {
        return LAPACKE_ztrtri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtri(int matrix_layout, char uplo, char diag, int n, _Complex double *a, int lda)
     * }
     */
    public static int LAPACKE_ztrtri(int matrix_layout, byte uplo, byte diag, int n, MemorySegment a, int lda) {
        var mh$ = LAPACKE_ztrtri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtri", matrix_layout, uplo, diag, n, a, lda);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, diag, n, a, lda);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_strtrs$descriptor() {
        return LAPACKE_strtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_strtrs$handle() {
        return LAPACKE_strtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_strtrs$address() {
        return LAPACKE_strtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_strtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_strtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrtrs$descriptor() {
        return LAPACKE_dtrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dtrtrs$handle() {
        return LAPACKE_dtrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dtrtrs$address() {
        return LAPACKE_dtrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dtrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dtrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrtrs$descriptor() {
        return LAPACKE_ctrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ctrtrs$handle() {
        return LAPACKE_ctrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ctrtrs$address() {
        return LAPACKE_ctrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_ctrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ctrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrtrs$descriptor() {
        return LAPACKE_ztrtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_ztrtrs$handle() {
        return LAPACKE_ztrtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_ztrtrs$address() {
        return LAPACKE_ztrtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrtrs(int matrix_layout, char uplo, char trans, char diag, int n, int nrhs, const _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_ztrtrs(int matrix_layout, byte uplo, byte trans, byte diag, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_ztrtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrtrs", matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, trans, diag, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttf$descriptor() {
        return LAPACKE_strttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MethodHandle LAPACKE_strttf$handle() {
        return LAPACKE_strttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static MemorySegment LAPACKE_strttf$address() {
        return LAPACKE_strttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttf(int matrix_layout, char transr, char uplo, int n, const float *a, int lda, float *arf)
     * }
     */
    public static int LAPACKE_strttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_strttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttf$descriptor() {
        return LAPACKE_dtrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MethodHandle LAPACKE_dtrttf$handle() {
        return LAPACKE_dtrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static MemorySegment LAPACKE_dtrttf$address() {
        return LAPACKE_dtrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttf(int matrix_layout, char transr, char uplo, int n, const double *a, int lda, double *arf)
     * }
     */
    public static int LAPACKE_dtrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_dtrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttf$descriptor() {
        return LAPACKE_ctrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MethodHandle LAPACKE_ctrttf$handle() {
        return LAPACKE_ctrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static MemorySegment LAPACKE_ctrttf$address() {
        return LAPACKE_ctrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttf(int matrix_layout, char transr, char uplo, int n, const _Complex float *a, int lda, _Complex float *arf)
     * }
     */
    public static int LAPACKE_ctrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ctrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrttf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttf$descriptor() {
        return LAPACKE_ztrttf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MethodHandle LAPACKE_ztrttf$handle() {
        return LAPACKE_ztrttf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static MemorySegment LAPACKE_ztrttf$address() {
        return LAPACKE_ztrttf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttf(int matrix_layout, char transr, char uplo, int n, const _Complex double *a, int lda, _Complex double *arf)
     * }
     */
    public static int LAPACKE_ztrttf(int matrix_layout, byte transr, byte uplo, int n, MemorySegment a, int lda, MemorySegment arf) {
        var mh$ = LAPACKE_ztrttf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttf", matrix_layout, transr, uplo, n, a, lda, arf);
            }
            return (int)mh$.invokeExact(matrix_layout, transr, uplo, n, a, lda, arf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_strttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_strttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_strttp$descriptor() {
        return LAPACKE_strttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MethodHandle LAPACKE_strttp$handle() {
        return LAPACKE_strttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static MemorySegment LAPACKE_strttp$address() {
        return LAPACKE_strttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_strttp(int matrix_layout, char uplo, int n, const float *a, int lda, float *ap)
     * }
     */
    public static int LAPACKE_strttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_strttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_strttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtrttp$descriptor() {
        return LAPACKE_dtrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MethodHandle LAPACKE_dtrttp$handle() {
        return LAPACKE_dtrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static MemorySegment LAPACKE_dtrttp$address() {
        return LAPACKE_dtrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtrttp(int matrix_layout, char uplo, int n, const double *a, int lda, double *ap)
     * }
     */
    public static int LAPACKE_dtrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_dtrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctrttp$descriptor() {
        return LAPACKE_ctrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MethodHandle LAPACKE_ctrttp$handle() {
        return LAPACKE_ctrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static MemorySegment LAPACKE_ctrttp$address() {
        return LAPACKE_ctrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctrttp(int matrix_layout, char uplo, int n, const _Complex float *a, int lda, _Complex float *ap)
     * }
     */
    public static int LAPACKE_ctrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ctrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztrttp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztrttp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztrttp$descriptor() {
        return LAPACKE_ztrttp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MethodHandle LAPACKE_ztrttp$handle() {
        return LAPACKE_ztrttp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static MemorySegment LAPACKE_ztrttp$address() {
        return LAPACKE_ztrttp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztrttp(int matrix_layout, char uplo, int n, const _Complex double *a, int lda, _Complex double *ap)
     * }
     */
    public static int LAPACKE_ztrttp(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment ap) {
        var mh$ = LAPACKE_ztrttp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztrttp", matrix_layout, uplo, n, a, lda, ap);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_stzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_stzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_stzrzf$descriptor() {
        return LAPACKE_stzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_stzrzf$handle() {
        return LAPACKE_stzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_stzrzf$address() {
        return LAPACKE_stzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_stzrzf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_stzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_stzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_stzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dtzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dtzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dtzrzf$descriptor() {
        return LAPACKE_dtzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dtzrzf$handle() {
        return LAPACKE_dtzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dtzrzf$address() {
        return LAPACKE_dtzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dtzrzf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dtzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dtzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dtzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ctzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ctzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ctzrzf$descriptor() {
        return LAPACKE_ctzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_ctzrzf$handle() {
        return LAPACKE_ctzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_ctzrzf$address() {
        return LAPACKE_ctzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ctzrzf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_ctzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_ctzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ctzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ztzrzf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ztzrzf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_ztzrzf$descriptor() {
        return LAPACKE_ztzrzf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_ztzrzf$handle() {
        return LAPACKE_ztzrzf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_ztzrzf$address() {
        return LAPACKE_ztzrzf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ztzrzf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_ztzrzf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_ztzrzf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ztzrzf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungbr$descriptor() {
        return LAPACKE_cungbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungbr$handle() {
        return LAPACKE_cungbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungbr$address() {
        return LAPACKE_cungbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungbr(int matrix_layout, char vect, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungbr$descriptor() {
        return LAPACKE_zungbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungbr$handle() {
        return LAPACKE_zungbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungbr$address() {
        return LAPACKE_zungbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungbr(int matrix_layout, char vect, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungbr(int matrix_layout, byte vect, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungbr", matrix_layout, vect, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunghr$descriptor() {
        return LAPACKE_cunghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cunghr$handle() {
        return LAPACKE_cunghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cunghr$address() {
        return LAPACKE_cunghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cunghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cunghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunghr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunghr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunghr$descriptor() {
        return LAPACKE_zunghr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zunghr$handle() {
        return LAPACKE_zunghr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zunghr$address() {
        return LAPACKE_zunghr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zunghr(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zunghr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunghr", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunglq$descriptor() {
        return LAPACKE_cunglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cunglq$handle() {
        return LAPACKE_cunglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cunglq$address() {
        return LAPACKE_cunglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cunglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cunglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunglq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunglq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunglq$descriptor() {
        return LAPACKE_zunglq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zunglq$handle() {
        return LAPACKE_zunglq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zunglq$address() {
        return LAPACKE_zunglq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zunglq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zunglq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunglq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungql$descriptor() {
        return LAPACKE_cungql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungql$handle() {
        return LAPACKE_cungql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungql$address() {
        return LAPACKE_cungql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungql(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungql$descriptor() {
        return LAPACKE_zungql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungql$handle() {
        return LAPACKE_zungql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungql$address() {
        return LAPACKE_zungql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungql(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungql(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungql", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungqr$descriptor() {
        return LAPACKE_cungqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungqr$handle() {
        return LAPACKE_cungqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungqr$address() {
        return LAPACKE_cungqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungqr$descriptor() {
        return LAPACKE_zungqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungqr$handle() {
        return LAPACKE_zungqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungqr$address() {
        return LAPACKE_zungqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungqr(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungqr", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungrq$descriptor() {
        return LAPACKE_cungrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungrq$handle() {
        return LAPACKE_cungrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungrq$address() {
        return LAPACKE_cungrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungrq$descriptor() {
        return LAPACKE_zungrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungrq$handle() {
        return LAPACKE_zungrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungrq$address() {
        return LAPACKE_zungrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungrq(int matrix_layout, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungrq", matrix_layout, m, n, k, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, k, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtr$descriptor() {
        return LAPACKE_cungtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cungtr$handle() {
        return LAPACKE_cungtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cungtr$address() {
        return LAPACKE_cungtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtr(int matrix_layout, char uplo, int n, _Complex float *a, int lda, const _Complex float *tau)
     * }
     */
    public static int LAPACKE_cungtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cungtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtr$descriptor() {
        return LAPACKE_zungtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zungtr$handle() {
        return LAPACKE_zungtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zungtr$address() {
        return LAPACKE_zungtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtr(int matrix_layout, char uplo, int n, _Complex double *a, int lda, const _Complex double *tau)
     * }
     */
    public static int LAPACKE_zungtr(int matrix_layout, byte uplo, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zungtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtr", matrix_layout, uplo, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cungtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cungtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cungtsqr_row$descriptor() {
        return LAPACKE_cungtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_cungtsqr_row$handle() {
        return LAPACKE_cungtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_cungtsqr_row$address() {
        return LAPACKE_cungtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex float *a, int lda, const _Complex float *t, int ldt)
     * }
     */
    public static int LAPACKE_cungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_cungtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cungtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zungtsqr_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zungtsqr_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zungtsqr_row$descriptor() {
        return LAPACKE_zungtsqr_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static MethodHandle LAPACKE_zungtsqr_row$handle() {
        return LAPACKE_zungtsqr_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static MemorySegment LAPACKE_zungtsqr_row$address() {
        return LAPACKE_zungtsqr_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, _Complex double *a, int lda, const _Complex double *t, int ldt)
     * }
     */
    public static int LAPACKE_zungtsqr_row(int matrix_layout, int m, int n, int mb, int nb, MemorySegment a, int lda, MemorySegment t, int ldt) {
        var mh$ = LAPACKE_zungtsqr_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zungtsqr_row", matrix_layout, m, n, mb, nb, a, lda, t, ldt);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, mb, nb, a, lda, t, ldt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmbr$descriptor() {
        return LAPACKE_cunmbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmbr$handle() {
        return LAPACKE_cunmbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmbr$address() {
        return LAPACKE_cunmbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmbr$descriptor() {
        return LAPACKE_zunmbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmbr$handle() {
        return LAPACKE_zunmbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmbr$address() {
        return LAPACKE_zunmbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmbr(int matrix_layout, char vect, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmbr(int matrix_layout, byte vect, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmbr", matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmhr$descriptor() {
        return LAPACKE_cunmhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmhr$handle() {
        return LAPACKE_cunmhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmhr$address() {
        return LAPACKE_cunmhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmhr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmhr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmhr$descriptor() {
        return LAPACKE_zunmhr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmhr$handle() {
        return LAPACKE_zunmhr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmhr$address() {
        return LAPACKE_zunmhr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmhr(int matrix_layout, char side, char trans, int m, int n, int ilo, int ihi, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmhr(int matrix_layout, byte side, byte trans, int m, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmhr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmhr", matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, ilo, ihi, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmlq$descriptor() {
        return LAPACKE_cunmlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmlq$handle() {
        return LAPACKE_cunmlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmlq$address() {
        return LAPACKE_cunmlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmlq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmlq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmlq$descriptor() {
        return LAPACKE_zunmlq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmlq$handle() {
        return LAPACKE_zunmlq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmlq$address() {
        return LAPACKE_zunmlq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmlq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmlq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmlq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmlq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmql$descriptor() {
        return LAPACKE_cunmql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmql$handle() {
        return LAPACKE_cunmql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmql$address() {
        return LAPACKE_cunmql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmql {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmql");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmql$descriptor() {
        return LAPACKE_zunmql.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmql$handle() {
        return LAPACKE_zunmql.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmql$address() {
        return LAPACKE_zunmql.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmql(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmql(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmql.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmql", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmqr$descriptor() {
        return LAPACKE_cunmqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmqr$handle() {
        return LAPACKE_cunmqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmqr$address() {
        return LAPACKE_cunmqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmqr$descriptor() {
        return LAPACKE_zunmqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmqr$handle() {
        return LAPACKE_zunmqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmqr$address() {
        return LAPACKE_zunmqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmqr(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmqr(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmqr", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrq$descriptor() {
        return LAPACKE_cunmrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmrq$handle() {
        return LAPACKE_cunmrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmrq$address() {
        return LAPACKE_cunmrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmrq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrq$descriptor() {
        return LAPACKE_zunmrq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmrq$handle() {
        return LAPACKE_zunmrq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmrq$address() {
        return LAPACKE_zunmrq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrq(int matrix_layout, char side, char trans, int m, int n, int k, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmrq(int matrix_layout, byte side, byte trans, int m, int n, int k, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmrq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrq", matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmrz$descriptor() {
        return LAPACKE_cunmrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmrz$handle() {
        return LAPACKE_cunmrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmrz$address() {
        return LAPACKE_cunmrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmrz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmrz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmrz$descriptor() {
        return LAPACKE_zunmrz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmrz$handle() {
        return LAPACKE_zunmrz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmrz$address() {
        return LAPACKE_zunmrz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmrz(int matrix_layout, char side, char trans, int m, int n, int k, int l, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmrz(int matrix_layout, byte side, byte trans, int m, int n, int k, int l, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmrz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmrz", matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, trans, m, n, k, l, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cunmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cunmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cunmtr$descriptor() {
        return LAPACKE_cunmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cunmtr$handle() {
        return LAPACKE_cunmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cunmtr$address() {
        return LAPACKE_cunmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *a, int lda, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cunmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cunmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cunmtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zunmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zunmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zunmtr$descriptor() {
        return LAPACKE_zunmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zunmtr$handle() {
        return LAPACKE_zunmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zunmtr$address() {
        return LAPACKE_zunmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zunmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *a, int lda, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zunmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zunmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zunmtr", matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, a, lda, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cupgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupgtr$descriptor() {
        return LAPACKE_cupgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_cupgtr$handle() {
        return LAPACKE_cupgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_cupgtr$address() {
        return LAPACKE_cupgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupgtr(int matrix_layout, char uplo, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *q, int ldq)
     * }
     */
    public static int LAPACKE_cupgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_cupgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupgtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zupgtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupgtr$descriptor() {
        return LAPACKE_zupgtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static MethodHandle LAPACKE_zupgtr$handle() {
        return LAPACKE_zupgtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static MemorySegment LAPACKE_zupgtr$address() {
        return LAPACKE_zupgtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupgtr(int matrix_layout, char uplo, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *q, int ldq)
     * }
     */
    public static int LAPACKE_zupgtr(int matrix_layout, byte uplo, int n, MemorySegment ap, MemorySegment tau, MemorySegment q, int ldq) {
        var mh$ = LAPACKE_zupgtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupgtr", matrix_layout, uplo, n, ap, tau, q, ldq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ap, tau, q, ldq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cupmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cupmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cupmtr$descriptor() {
        return LAPACKE_cupmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cupmtr$handle() {
        return LAPACKE_cupmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cupmtr$address() {
        return LAPACKE_cupmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex float *ap, const _Complex float *tau, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cupmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cupmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cupmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zupmtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zupmtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zupmtr$descriptor() {
        return LAPACKE_zupmtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zupmtr$handle() {
        return LAPACKE_zupmtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zupmtr$address() {
        return LAPACKE_zupmtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zupmtr(int matrix_layout, char side, char uplo, char trans, int m, int n, const _Complex double *ap, const _Complex double *tau, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zupmtr(int matrix_layout, byte side, byte uplo, byte trans, int m, int n, MemorySegment ap, MemorySegment tau, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zupmtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zupmtr", matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, side, uplo, trans, m, n, ap, tau, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsdc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsdc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsdc_work$descriptor() {
        return LAPACKE_sbdsdc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sbdsdc_work$handle() {
        return LAPACKE_sbdsdc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sbdsdc_work$address() {
        return LAPACKE_sbdsdc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc_work(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sbdsdc_work(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sbdsdc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsdc_work", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsdc_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsdc_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsdc_work$descriptor() {
        return LAPACKE_dbdsdc_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dbdsdc_work$handle() {
        return LAPACKE_dbdsdc_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dbdsdc_work$address() {
        return LAPACKE_dbdsdc_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc_work(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dbdsdc_work(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dbdsdc_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsdc_work", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsvdx_work$descriptor() {
        return LAPACKE_sbdsvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sbdsvdx_work$handle() {
        return LAPACKE_sbdsvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sbdsvdx_work$address() {
        return LAPACKE_sbdsvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sbdsvdx_work(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sbdsvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsvdx_work", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsvdx_work$descriptor() {
        return LAPACKE_dbdsvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dbdsvdx_work$handle() {
        return LAPACKE_dbdsvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dbdsvdx_work$address() {
        return LAPACKE_dbdsvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx_work(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dbdsvdx_work(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dbdsvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsvdx_work", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsqr_work$descriptor() {
        return LAPACKE_sbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sbdsqr_work$handle() {
        return LAPACKE_sbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sbdsqr_work$address() {
        return LAPACKE_sbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsqr_work$descriptor() {
        return LAPACKE_dbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dbdsqr_work$handle() {
        return LAPACKE_dbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dbdsqr_work$address() {
        return LAPACKE_dbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbdsqr_work$descriptor() {
        return LAPACKE_cbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cbdsqr_work$handle() {
        return LAPACKE_cbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cbdsqr_work$address() {
        return LAPACKE_cbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_cbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_cbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbdsqr_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zbdsqr_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbdsqr_work$descriptor() {
        return LAPACKE_zbdsqr_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zbdsqr_work$handle() {
        return LAPACKE_zbdsqr_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zbdsqr_work$address() {
        return LAPACKE_zbdsqr_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr_work(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_zbdsqr_work(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_zbdsqr_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbdsqr_work", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sdisna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sdisna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_sdisna_work$descriptor() {
        return LAPACKE_sdisna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_sdisna_work$handle() {
        return LAPACKE_sdisna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_sdisna_work$address() {
        return LAPACKE_sdisna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sdisna_work(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static int LAPACKE_sdisna_work(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_sdisna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sdisna_work", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ddisna_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ddisna_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ddisna_work$descriptor() {
        return LAPACKE_ddisna_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ddisna_work$handle() {
        return LAPACKE_ddisna_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ddisna_work$address() {
        return LAPACKE_ddisna_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ddisna_work(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static int LAPACKE_ddisna_work(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_ddisna_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ddisna_work", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbbrd_work$descriptor() {
        return LAPACKE_sgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgbbrd_work$handle() {
        return LAPACKE_sgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgbbrd_work$address() {
        return LAPACKE_sgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc, float *work)
     * }
     */
    public static int LAPACKE_sgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_sgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbbrd_work$descriptor() {
        return LAPACKE_dgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgbbrd_work$handle() {
        return LAPACKE_dgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgbbrd_work$address() {
        return LAPACKE_dgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc, double *work)
     * }
     */
    public static int LAPACKE_dgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work) {
        var mh$ = LAPACKE_dgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbbrd_work$descriptor() {
        return LAPACKE_cgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbbrd_work$handle() {
        return LAPACKE_cgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbbrd_work$address() {
        return LAPACKE_cgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbbrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbbrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbbrd_work$descriptor() {
        return LAPACKE_zgbbrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbbrd_work$handle() {
        return LAPACKE_zgbbrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbbrd_work$address() {
        return LAPACKE_zgbbrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd_work(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbbrd_work(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbbrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbbrd_work", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbcon_work$descriptor() {
        return LAPACKE_sgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbcon_work$handle() {
        return LAPACKE_sgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbcon_work$address() {
        return LAPACKE_sgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbcon_work$descriptor() {
        return LAPACKE_dgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbcon_work$handle() {
        return LAPACKE_dgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbcon_work$address() {
        return LAPACKE_dgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbcon_work$descriptor() {
        return LAPACKE_cgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbcon_work$handle() {
        return LAPACKE_cgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbcon_work$address() {
        return LAPACKE_cgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbcon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbcon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbcon_work$descriptor() {
        return LAPACKE_zgbcon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbcon_work$handle() {
        return LAPACKE_zgbcon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbcon_work$address() {
        return LAPACKE_zgbcon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbcon_work(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbcon_work(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbcon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbcon_work", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequ_work$descriptor() {
        return LAPACKE_sgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequ_work$handle() {
        return LAPACKE_sgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequ_work$address() {
        return LAPACKE_sgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequ_work$descriptor() {
        return LAPACKE_dgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequ_work$handle() {
        return LAPACKE_dgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequ_work$address() {
        return LAPACKE_dgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequ_work$descriptor() {
        return LAPACKE_cgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequ_work$handle() {
        return LAPACKE_cgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequ_work$address() {
        return LAPACKE_cgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequ_work$descriptor() {
        return LAPACKE_zgbequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequ_work$handle() {
        return LAPACKE_zgbequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequ_work$address() {
        return LAPACKE_zgbequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequ_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequ_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequb_work$descriptor() {
        return LAPACKE_sgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequb_work$handle() {
        return LAPACKE_sgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequb_work$address() {
        return LAPACKE_sgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequb_work$descriptor() {
        return LAPACKE_dgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequb_work$handle() {
        return LAPACKE_dgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequb_work$address() {
        return LAPACKE_dgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequb_work$descriptor() {
        return LAPACKE_cgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequb_work$handle() {
        return LAPACKE_cgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequb_work$address() {
        return LAPACKE_cgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequb_work$descriptor() {
        return LAPACKE_zgbequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequb_work$handle() {
        return LAPACKE_zgbequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequb_work$address() {
        return LAPACKE_zgbequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequb_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequb_work", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfs_work$descriptor() {
        return LAPACKE_sgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfs_work$handle() {
        return LAPACKE_sgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfs_work$address() {
        return LAPACKE_sgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfs_work$descriptor() {
        return LAPACKE_dgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfs_work$handle() {
        return LAPACKE_dgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfs_work$address() {
        return LAPACKE_dgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfs_work$descriptor() {
        return LAPACKE_cgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfs_work$handle() {
        return LAPACKE_cgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfs_work$address() {
        return LAPACKE_cgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbrfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfs_work$descriptor() {
        return LAPACKE_zgbrfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfs_work$handle() {
        return LAPACKE_zgbrfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfs_work$address() {
        return LAPACKE_zgbrfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbrfs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbrfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfsx_work$descriptor() {
        return LAPACKE_sgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfsx_work$handle() {
        return LAPACKE_sgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfsx_work$address() {
        return LAPACKE_sgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfsx_work$descriptor() {
        return LAPACKE_dgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfsx_work$handle() {
        return LAPACKE_dgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfsx_work$address() {
        return LAPACKE_dgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfsx_work$descriptor() {
        return LAPACKE_cgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfsx_work$handle() {
        return LAPACKE_cgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfsx_work$address() {
        return LAPACKE_cgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbrfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfsx_work$descriptor() {
        return LAPACKE_zgbrfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfsx_work$handle() {
        return LAPACKE_zgbrfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfsx_work$address() {
        return LAPACKE_zgbrfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx_work(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbrfsx_work(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbrfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfsx_work", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsv_work$descriptor() {
        return LAPACKE_sgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbsv_work$handle() {
        return LAPACKE_sgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbsv_work$address() {
        return LAPACKE_sgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsv_work$descriptor() {
        return LAPACKE_dgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbsv_work$handle() {
        return LAPACKE_dgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbsv_work$address() {
        return LAPACKE_dgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsv_work$descriptor() {
        return LAPACKE_cgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbsv_work$handle() {
        return LAPACKE_cgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbsv_work$address() {
        return LAPACKE_cgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsv_work$descriptor() {
        return LAPACKE_zgbsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbsv_work$handle() {
        return LAPACKE_zgbsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbsv_work$address() {
        return LAPACKE_zgbsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbsv_work(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsv_work", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvx_work$descriptor() {
        return LAPACKE_sgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvx_work$handle() {
        return LAPACKE_sgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvx_work$address() {
        return LAPACKE_sgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvx_work$descriptor() {
        return LAPACKE_dgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvx_work$handle() {
        return LAPACKE_dgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvx_work$address() {
        return LAPACKE_dgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvx_work$descriptor() {
        return LAPACKE_cgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvx_work$handle() {
        return LAPACKE_cgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvx_work$address() {
        return LAPACKE_cgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvx_work$descriptor() {
        return LAPACKE_zgbsvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvx_work$handle() {
        return LAPACKE_zgbsvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvx_work$address() {
        return LAPACKE_zgbsvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbsvx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbsvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvxx_work$descriptor() {
        return LAPACKE_sgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvxx_work$handle() {
        return LAPACKE_sgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvxx_work$address() {
        return LAPACKE_sgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvxx_work$descriptor() {
        return LAPACKE_dgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvxx_work$handle() {
        return LAPACKE_dgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvxx_work$address() {
        return LAPACKE_dgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvxx_work$descriptor() {
        return LAPACKE_cgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvxx_work$handle() {
        return LAPACKE_cgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvxx_work$address() {
        return LAPACKE_cgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvxx_work$descriptor() {
        return LAPACKE_zgbsvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvxx_work$handle() {
        return LAPACKE_zgbsvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvxx_work$address() {
        return LAPACKE_zgbsvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx_work(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgbsvxx_work(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgbsvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvxx_work", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrf_work$descriptor() {
        return LAPACKE_sgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrf_work$handle() {
        return LAPACKE_sgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrf_work$address() {
        return LAPACKE_sgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_sgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrf_work$descriptor() {
        return LAPACKE_dgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrf_work$handle() {
        return LAPACKE_dgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrf_work$address() {
        return LAPACKE_dgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_dgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrf_work$descriptor() {
        return LAPACKE_cgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrf_work$handle() {
        return LAPACKE_cgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrf_work$address() {
        return LAPACKE_cgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_cgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbtrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrf_work$descriptor() {
        return LAPACKE_zgbtrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrf_work$handle() {
        return LAPACKE_zgbtrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrf_work$address() {
        return LAPACKE_zgbtrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_zgbtrf_work(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgbtrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrf_work", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrs_work$descriptor() {
        return LAPACKE_sgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrs_work$handle() {
        return LAPACKE_sgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrs_work$address() {
        return LAPACKE_sgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrs_work$descriptor() {
        return LAPACKE_dgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrs_work$handle() {
        return LAPACKE_dgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrs_work$address() {
        return LAPACKE_dgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrs_work$descriptor() {
        return LAPACKE_cgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrs_work$handle() {
        return LAPACKE_cgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrs_work$address() {
        return LAPACKE_cgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbtrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrs_work$descriptor() {
        return LAPACKE_zgbtrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrs_work$handle() {
        return LAPACKE_zgbtrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrs_work$address() {
        return LAPACKE_zgbtrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs_work(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbtrs_work(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbtrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrs_work", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebak_work$descriptor() {
        return LAPACKE_sgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sgebak_work$handle() {
        return LAPACKE_sgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sgebak_work$address() {
        return LAPACKE_sgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebak_work$descriptor() {
        return LAPACKE_dgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dgebak_work$handle() {
        return LAPACKE_dgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dgebak_work$address() {
        return LAPACKE_dgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebak_work$descriptor() {
        return LAPACKE_cgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cgebak_work$handle() {
        return LAPACKE_cgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cgebak_work$address() {
        return LAPACKE_cgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebak_work$descriptor() {
        return LAPACKE_zgebak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zgebak_work$handle() {
        return LAPACKE_zgebak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zgebak_work$address() {
        return LAPACKE_zgebak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zgebak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zgebak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebak_work", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebal_work$descriptor() {
        return LAPACKE_sgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_sgebal_work$handle() {
        return LAPACKE_sgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_sgebal_work$address() {
        return LAPACKE_sgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebal_work(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_sgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_sgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebal_work$descriptor() {
        return LAPACKE_dgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dgebal_work$handle() {
        return LAPACKE_dgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dgebal_work$address() {
        return LAPACKE_dgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebal_work(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_dgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_dgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebal_work$descriptor() {
        return LAPACKE_cgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_cgebal_work$handle() {
        return LAPACKE_cgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_cgebal_work$address() {
        return LAPACKE_cgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_cgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_cgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebal_work$descriptor() {
        return LAPACKE_zgebal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_zgebal_work$handle() {
        return LAPACKE_zgebal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_zgebal_work$address() {
        return LAPACKE_zgebal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_zgebal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_zgebal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebal_work", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebrd_work$descriptor() {
        return LAPACKE_sgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgebrd_work$handle() {
        return LAPACKE_sgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgebrd_work$address() {
        return LAPACKE_sgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebrd_work$descriptor() {
        return LAPACKE_dgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgebrd_work$handle() {
        return LAPACKE_dgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgebrd_work$address() {
        return LAPACKE_dgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebrd_work$descriptor() {
        return LAPACKE_cgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgebrd_work$handle() {
        return LAPACKE_cgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgebrd_work$address() {
        return LAPACKE_cgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebrd_work$descriptor() {
        return LAPACKE_zgebrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgebrd_work$handle() {
        return LAPACKE_zgebrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgebrd_work$address() {
        return LAPACKE_zgebrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgebrd_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgebrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebrd_work", matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgecon_work$descriptor() {
        return LAPACKE_sgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgecon_work$handle() {
        return LAPACKE_sgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgecon_work$address() {
        return LAPACKE_sgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgecon_work(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgecon_work$descriptor() {
        return LAPACKE_dgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgecon_work$handle() {
        return LAPACKE_dgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgecon_work$address() {
        return LAPACKE_dgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgecon_work(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgecon_work$descriptor() {
        return LAPACKE_cgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgecon_work$handle() {
        return LAPACKE_cgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgecon_work$address() {
        return LAPACKE_cgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgecon_work(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgecon_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgecon_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgecon_work$descriptor() {
        return LAPACKE_zgecon_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgecon_work$handle() {
        return LAPACKE_zgecon_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgecon_work$address() {
        return LAPACKE_zgecon_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgecon_work(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgecon_work(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgecon_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgecon_work", matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequ_work$descriptor() {
        return LAPACKE_sgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequ_work$handle() {
        return LAPACKE_sgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequ_work$address() {
        return LAPACKE_sgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequ_work$descriptor() {
        return LAPACKE_dgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequ_work$handle() {
        return LAPACKE_dgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequ_work$address() {
        return LAPACKE_dgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequ_work$descriptor() {
        return LAPACKE_cgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequ_work$handle() {
        return LAPACKE_cgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequ_work$address() {
        return LAPACKE_cgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequ_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeequ_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequ_work$descriptor() {
        return LAPACKE_zgeequ_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequ_work$handle() {
        return LAPACKE_zgeequ_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequ_work$address() {
        return LAPACKE_zgeequ_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequ_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequ_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequ_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequb_work$descriptor() {
        return LAPACKE_sgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequb_work$handle() {
        return LAPACKE_sgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequb_work$address() {
        return LAPACKE_sgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequb_work$descriptor() {
        return LAPACKE_dgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequb_work$handle() {
        return LAPACKE_dgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequb_work$address() {
        return LAPACKE_dgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequb_work$descriptor() {
        return LAPACKE_cgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequb_work$handle() {
        return LAPACKE_cgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequb_work$address() {
        return LAPACKE_cgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequb_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeequb_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequb_work$descriptor() {
        return LAPACKE_zgeequb_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequb_work$handle() {
        return LAPACKE_zgeequb_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequb_work$address() {
        return LAPACKE_zgeequb_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequb_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequb_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequb_work", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgees_work$descriptor() {
        return LAPACKE_sgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgees_work$handle() {
        return LAPACKE_sgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgees_work$address() {
        return LAPACKE_sgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgees_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgees_work$descriptor() {
        return LAPACKE_dgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgees_work$handle() {
        return LAPACKE_dgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgees_work$address() {
        return LAPACKE_dgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgees_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgees_work$descriptor() {
        return LAPACKE_cgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgees_work$handle() {
        return LAPACKE_cgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgees_work$address() {
        return LAPACKE_cgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgees_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgees_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgees_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgees_work$descriptor() {
        return LAPACKE_zgees_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgees_work$handle() {
        return LAPACKE_zgees_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgees_work$address() {
        return LAPACKE_zgees_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgees_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgees_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgees_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgees_work", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeesx_work$descriptor() {
        return LAPACKE_sgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeesx_work$handle() {
        return LAPACKE_sgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeesx_work$address() {
        return LAPACKE_sgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeesx_work$descriptor() {
        return LAPACKE_dgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeesx_work$handle() {
        return LAPACKE_dgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeesx_work$address() {
        return LAPACKE_dgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeesx_work$descriptor() {
        return LAPACKE_cgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeesx_work$handle() {
        return LAPACKE_cgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeesx_work$address() {
        return LAPACKE_cgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeesx_work$descriptor() {
        return LAPACKE_zgeesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeesx_work$handle() {
        return LAPACKE_zgeesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeesx_work$address() {
        return LAPACKE_zgeesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeesx_work(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgeesx_work(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgeesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeesx_work", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeev_work$descriptor() {
        return LAPACKE_sgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeev_work$handle() {
        return LAPACKE_sgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeev_work$address() {
        return LAPACKE_sgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeev_work$descriptor() {
        return LAPACKE_dgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeev_work$handle() {
        return LAPACKE_dgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeev_work$address() {
        return LAPACKE_dgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeev_work$descriptor() {
        return LAPACKE_cgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeev_work$handle() {
        return LAPACKE_cgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeev_work$address() {
        return LAPACKE_cgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeev_work$descriptor() {
        return LAPACKE_zgeev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeev_work$handle() {
        return LAPACKE_zgeev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeev_work$address() {
        return LAPACKE_zgeev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeev_work", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeevx_work$descriptor() {
        return LAPACKE_sgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeevx_work$handle() {
        return LAPACKE_sgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeevx_work$address() {
        return LAPACKE_sgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeevx_work$descriptor() {
        return LAPACKE_dgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeevx_work$handle() {
        return LAPACKE_dgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeevx_work$address() {
        return LAPACKE_dgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeevx_work$descriptor() {
        return LAPACKE_cgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeevx_work$handle() {
        return LAPACKE_cgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeevx_work$address() {
        return LAPACKE_cgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeevx_work$descriptor() {
        return LAPACKE_zgeevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeevx_work$handle() {
        return LAPACKE_zgeevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeevx_work$address() {
        return LAPACKE_zgeevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgehrd_work$descriptor() {
        return LAPACKE_sgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgehrd_work$handle() {
        return LAPACKE_sgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgehrd_work$address() {
        return LAPACKE_sgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgehrd_work$descriptor() {
        return LAPACKE_dgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgehrd_work$handle() {
        return LAPACKE_dgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgehrd_work$address() {
        return LAPACKE_dgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgehrd_work$descriptor() {
        return LAPACKE_cgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgehrd_work$handle() {
        return LAPACKE_cgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgehrd_work$address() {
        return LAPACKE_cgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgehrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgehrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgehrd_work$descriptor() {
        return LAPACKE_zgehrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgehrd_work$handle() {
        return LAPACKE_zgehrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgehrd_work$address() {
        return LAPACKE_zgehrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgehrd_work(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgehrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgehrd_work", matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgejsv_work$descriptor() {
        return LAPACKE_sgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgejsv_work$handle() {
        return LAPACKE_sgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgejsv_work$address() {
        return LAPACKE_sgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgejsv_work$descriptor() {
        return LAPACKE_dgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgejsv_work$handle() {
        return LAPACKE_dgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgejsv_work$address() {
        return LAPACKE_dgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgejsv_work$descriptor() {
        return LAPACKE_cgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgejsv_work$handle() {
        return LAPACKE_cgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgejsv_work$address() {
        return LAPACKE_cgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *work, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment work, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgejsv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgejsv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgejsv_work$descriptor() {
        return LAPACKE_zgejsv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgejsv_work$handle() {
        return LAPACKE_zgejsv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgejsv_work$address() {
        return LAPACKE_zgejsv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgejsv_work(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *work, int lrwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgejsv_work(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment work, int lrwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgejsv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgejsv_work", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork, work, lrwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq2_work$descriptor() {
        return LAPACKE_sgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgelq2_work$handle() {
        return LAPACKE_sgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgelq2_work$address() {
        return LAPACKE_sgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq2_work$descriptor() {
        return LAPACKE_dgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgelq2_work$handle() {
        return LAPACKE_dgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgelq2_work$address() {
        return LAPACKE_dgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq2_work$descriptor() {
        return LAPACKE_cgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgelq2_work$handle() {
        return LAPACKE_cgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgelq2_work$address() {
        return LAPACKE_cgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelq2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq2_work$descriptor() {
        return LAPACKE_zgelq2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgelq2_work$handle() {
        return LAPACKE_zgelq2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgelq2_work$address() {
        return LAPACKE_zgelq2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgelq2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zgelq2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelqf_work$descriptor() {
        return LAPACKE_sgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelqf_work$handle() {
        return LAPACKE_sgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelqf_work$address() {
        return LAPACKE_sgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelqf_work$descriptor() {
        return LAPACKE_dgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelqf_work$handle() {
        return LAPACKE_dgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelqf_work$address() {
        return LAPACKE_dgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelqf_work$descriptor() {
        return LAPACKE_cgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelqf_work$handle() {
        return LAPACKE_cgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelqf_work$address() {
        return LAPACKE_cgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelqf_work$descriptor() {
        return LAPACKE_zgelqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelqf_work$handle() {
        return LAPACKE_zgelqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelqf_work$address() {
        return LAPACKE_zgelqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgelqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgelqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgels_work$descriptor() {
        return LAPACKE_sgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgels_work$handle() {
        return LAPACKE_sgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgels_work$address() {
        return LAPACKE_sgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgels_work(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgels_work$descriptor() {
        return LAPACKE_dgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgels_work$handle() {
        return LAPACKE_dgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgels_work$address() {
        return LAPACKE_dgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgels_work(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgels_work$descriptor() {
        return LAPACKE_cgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgels_work$handle() {
        return LAPACKE_cgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgels_work$address() {
        return LAPACKE_cgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgels_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgels_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgels_work$descriptor() {
        return LAPACKE_zgels_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgels_work$handle() {
        return LAPACKE_zgels_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgels_work$address() {
        return LAPACKE_zgels_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgels_work(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgels_work(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgels_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgels_work", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsd_work$descriptor() {
        return LAPACKE_sgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelsd_work$handle() {
        return LAPACKE_sgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelsd_work$address() {
        return LAPACKE_sgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsd_work$descriptor() {
        return LAPACKE_dgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelsd_work$handle() {
        return LAPACKE_dgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelsd_work$address() {
        return LAPACKE_dgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsd_work$descriptor() {
        return LAPACKE_cgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelsd_work$handle() {
        return LAPACKE_cgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelsd_work$address() {
        return LAPACKE_cgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelsd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsd_work$descriptor() {
        return LAPACKE_zgelsd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelsd_work$handle() {
        return LAPACKE_zgelsd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelsd_work$address() {
        return LAPACKE_zgelsd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgelsd_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgelsd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsd_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelss_work$descriptor() {
        return LAPACKE_sgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelss_work$handle() {
        return LAPACKE_sgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelss_work$address() {
        return LAPACKE_sgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelss_work$descriptor() {
        return LAPACKE_dgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelss_work$handle() {
        return LAPACKE_dgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelss_work$address() {
        return LAPACKE_dgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelss_work$descriptor() {
        return LAPACKE_cgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelss_work$handle() {
        return LAPACKE_cgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelss_work$address() {
        return LAPACKE_cgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelss_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelss_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelss_work$descriptor() {
        return LAPACKE_zgelss_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelss_work$handle() {
        return LAPACKE_zgelss_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelss_work$address() {
        return LAPACKE_zgelss_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgelss_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgelss_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelss_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsy_work$descriptor() {
        return LAPACKE_sgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgelsy_work$handle() {
        return LAPACKE_sgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgelsy_work$address() {
        return LAPACKE_sgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsy_work$descriptor() {
        return LAPACKE_dgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgelsy_work$handle() {
        return LAPACKE_dgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgelsy_work$address() {
        return LAPACKE_dgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsy_work$descriptor() {
        return LAPACKE_cgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgelsy_work$handle() {
        return LAPACKE_cgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgelsy_work$address() {
        return LAPACKE_cgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsy_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelsy_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsy_work$descriptor() {
        return LAPACKE_zgelsy_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgelsy_work$handle() {
        return LAPACKE_zgelsy_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgelsy_work$address() {
        return LAPACKE_zgelsy_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgelsy_work(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgelsy_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsy_work", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqlf_work$descriptor() {
        return LAPACKE_sgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqlf_work$handle() {
        return LAPACKE_sgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqlf_work$address() {
        return LAPACKE_sgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqlf_work$descriptor() {
        return LAPACKE_dgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqlf_work$handle() {
        return LAPACKE_dgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqlf_work$address() {
        return LAPACKE_dgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqlf_work$descriptor() {
        return LAPACKE_cgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqlf_work$handle() {
        return LAPACKE_cgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqlf_work$address() {
        return LAPACKE_cgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqlf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqlf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqlf_work$descriptor() {
        return LAPACKE_zgeqlf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqlf_work$handle() {
        return LAPACKE_zgeqlf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqlf_work$address() {
        return LAPACKE_zgeqlf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqlf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqlf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqlf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqp3_work$descriptor() {
        return LAPACKE_sgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqp3_work$handle() {
        return LAPACKE_sgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqp3_work$address() {
        return LAPACKE_sgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqp3_work$descriptor() {
        return LAPACKE_dgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqp3_work$handle() {
        return LAPACKE_dgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqp3_work$address() {
        return LAPACKE_dgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqp3_work$descriptor() {
        return LAPACKE_cgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqp3_work$handle() {
        return LAPACKE_cgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqp3_work$address() {
        return LAPACKE_cgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqp3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqp3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqp3_work$descriptor() {
        return LAPACKE_zgeqp3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqp3_work$handle() {
        return LAPACKE_zgeqp3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqp3_work$address() {
        return LAPACKE_zgeqp3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgeqp3_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeqp3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqp3_work", matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqpf_work$descriptor() {
        return LAPACKE_sgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqpf_work$handle() {
        return LAPACKE_sgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqpf_work$address() {
        return LAPACKE_sgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqpf_work$descriptor() {
        return LAPACKE_dgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqpf_work$handle() {
        return LAPACKE_dgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqpf_work$address() {
        return LAPACKE_dgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqpf_work$descriptor() {
        return LAPACKE_cgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqpf_work$handle() {
        return LAPACKE_cgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqpf_work$address() {
        return LAPACKE_cgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqpf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqpf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqpf_work$descriptor() {
        return LAPACKE_zgeqpf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqpf_work$handle() {
        return LAPACKE_zgeqpf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqpf_work$address() {
        return LAPACKE_zgeqpf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgeqpf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgeqpf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqpf_work", matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr2_work$descriptor() {
        return LAPACKE_sgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr2_work$handle() {
        return LAPACKE_sgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr2_work$address() {
        return LAPACKE_sgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work)
     * }
     */
    public static int LAPACKE_sgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_sgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr2_work$descriptor() {
        return LAPACKE_dgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr2_work$handle() {
        return LAPACKE_dgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr2_work$address() {
        return LAPACKE_dgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work)
     * }
     */
    public static int LAPACKE_dgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_dgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr2_work$descriptor() {
        return LAPACKE_cgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr2_work$handle() {
        return LAPACKE_cgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr2_work$address() {
        return LAPACKE_cgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work)
     * }
     */
    public static int LAPACKE_cgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_cgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqr2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr2_work$descriptor() {
        return LAPACKE_zgeqr2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr2_work$handle() {
        return LAPACKE_zgeqr2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr2_work$address() {
        return LAPACKE_zgeqr2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work)
     * }
     */
    public static int LAPACKE_zgeqr2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work) {
        var mh$ = LAPACKE_zgeqr2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr2_work", matrix_layout, m, n, a, lda, tau, work);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrf_work$descriptor() {
        return LAPACKE_sgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrf_work$handle() {
        return LAPACKE_sgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrf_work$address() {
        return LAPACKE_sgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrf_work$descriptor() {
        return LAPACKE_dgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrf_work$handle() {
        return LAPACKE_dgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrf_work$address() {
        return LAPACKE_dgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrf_work$descriptor() {
        return LAPACKE_cgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrf_work$handle() {
        return LAPACKE_cgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrf_work$address() {
        return LAPACKE_cgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrf_work$descriptor() {
        return LAPACKE_zgeqrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrf_work$handle() {
        return LAPACKE_zgeqrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrf_work$address() {
        return LAPACKE_zgeqrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrfp_work$descriptor() {
        return LAPACKE_sgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrfp_work$handle() {
        return LAPACKE_sgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrfp_work$address() {
        return LAPACKE_sgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrfp_work$descriptor() {
        return LAPACKE_dgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrfp_work$handle() {
        return LAPACKE_dgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrfp_work$address() {
        return LAPACKE_dgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrfp_work$descriptor() {
        return LAPACKE_cgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrfp_work$handle() {
        return LAPACKE_cgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrfp_work$address() {
        return LAPACKE_cgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrfp_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrfp_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrfp_work$descriptor() {
        return LAPACKE_zgeqrfp_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrfp_work$handle() {
        return LAPACKE_zgeqrfp_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrfp_work$address() {
        return LAPACKE_zgeqrfp_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgeqrfp_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgeqrfp_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrfp_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfs_work$descriptor() {
        return LAPACKE_sgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerfs_work$handle() {
        return LAPACKE_sgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerfs_work$address() {
        return LAPACKE_sgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfs_work$descriptor() {
        return LAPACKE_dgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerfs_work$handle() {
        return LAPACKE_dgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerfs_work$address() {
        return LAPACKE_dgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfs_work$descriptor() {
        return LAPACKE_cgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerfs_work$handle() {
        return LAPACKE_cgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerfs_work$address() {
        return LAPACKE_cgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerfs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfs_work$descriptor() {
        return LAPACKE_zgerfs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerfs_work$handle() {
        return LAPACKE_zgerfs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerfs_work$address() {
        return LAPACKE_zgerfs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgerfs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgerfs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfs_work", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfsx_work$descriptor() {
        return LAPACKE_sgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerfsx_work$handle() {
        return LAPACKE_sgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerfsx_work$address() {
        return LAPACKE_sgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfsx_work$descriptor() {
        return LAPACKE_dgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerfsx_work$handle() {
        return LAPACKE_dgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerfsx_work$address() {
        return LAPACKE_dgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfsx_work$descriptor() {
        return LAPACKE_cgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerfsx_work$handle() {
        return LAPACKE_cgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerfsx_work$address() {
        return LAPACKE_cgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfsx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerfsx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfsx_work$descriptor() {
        return LAPACKE_zgerfsx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerfsx_work$handle() {
        return LAPACKE_zgerfsx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerfsx_work$address() {
        return LAPACKE_zgerfsx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx_work(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgerfsx_work(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgerfsx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfsx_work", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerqf_work$descriptor() {
        return LAPACKE_sgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgerqf_work$handle() {
        return LAPACKE_sgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgerqf_work$address() {
        return LAPACKE_sgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, float *a, int lda, float *tau, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerqf_work$descriptor() {
        return LAPACKE_dgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgerqf_work$handle() {
        return LAPACKE_dgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgerqf_work$address() {
        return LAPACKE_dgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, double *a, int lda, double *tau, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerqf_work$descriptor() {
        return LAPACKE_cgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgerqf_work$handle() {
        return LAPACKE_cgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgerqf_work$address() {
        return LAPACKE_cgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerqf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerqf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerqf_work$descriptor() {
        return LAPACKE_zgerqf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgerqf_work$handle() {
        return LAPACKE_zgerqf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgerqf_work$address() {
        return LAPACKE_zgerqf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgerqf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgerqf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerqf_work", matrix_layout, m, n, a, lda, tau, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesdd_work$descriptor() {
        return LAPACKE_sgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesdd_work$handle() {
        return LAPACKE_sgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesdd_work$address() {
        return LAPACKE_sgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesdd_work(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesdd_work$descriptor() {
        return LAPACKE_dgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesdd_work$handle() {
        return LAPACKE_dgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesdd_work$address() {
        return LAPACKE_dgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesdd_work(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesdd_work$descriptor() {
        return LAPACKE_cgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesdd_work$handle() {
        return LAPACKE_cgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesdd_work$address() {
        return LAPACKE_cgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesdd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesdd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesdd_work$descriptor() {
        return LAPACKE_zgesdd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesdd_work$handle() {
        return LAPACKE_zgesdd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesdd_work$address() {
        return LAPACKE_zgesdd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesdd_work(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgesdd_work(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgesdd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesdd_work", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesv_work$descriptor() {
        return LAPACKE_sgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgesv_work$handle() {
        return LAPACKE_sgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgesv_work$address() {
        return LAPACKE_sgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesv_work$descriptor() {
        return LAPACKE_dgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgesv_work$handle() {
        return LAPACKE_dgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgesv_work$address() {
        return LAPACKE_dgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesv_work$descriptor() {
        return LAPACKE_cgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgesv_work$handle() {
        return LAPACKE_cgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgesv_work$address() {
        return LAPACKE_cgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesv_work$descriptor() {
        return LAPACKE_zgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgesv_work$handle() {
        return LAPACKE_zgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgesv_work$address() {
        return LAPACKE_zgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsgesv_work$descriptor() {
        return LAPACKE_dsgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsgesv_work$handle() {
        return LAPACKE_dsgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsgesv_work$address() {
        return LAPACKE_dsgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, double *work, float *swork, int *iter)
     * }
     */
    public static int LAPACKE_dsgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment iter) {
        var mh$ = LAPACKE_dsgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcgesv_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zcgesv_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcgesv_work$descriptor() {
        return LAPACKE_zcgesv_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcgesv_work$handle() {
        return LAPACKE_zcgesv_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcgesv_work$address() {
        return LAPACKE_zcgesv_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter)
     * }
     */
    public static int LAPACKE_zcgesv_work(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter) {
        var mh$ = LAPACKE_zcgesv_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcgesv_work", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, rwork, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, work, swork, rwork, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvd_work$descriptor() {
        return LAPACKE_sgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvd_work$handle() {
        return LAPACKE_sgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvd_work$address() {
        return LAPACKE_sgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvd_work$descriptor() {
        return LAPACKE_dgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvd_work$handle() {
        return LAPACKE_dgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvd_work$address() {
        return LAPACKE_dgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvd_work$descriptor() {
        return LAPACKE_cgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvd_work$handle() {
        return LAPACKE_cgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvd_work$address() {
        return LAPACKE_cgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvd_work$descriptor() {
        return LAPACKE_zgesvd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvd_work$handle() {
        return LAPACKE_zgesvd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvd_work$address() {
        return LAPACKE_zgesvd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvd_work(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvd_work(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvd_work", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdx_work$descriptor() {
        return LAPACKE_sgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdx_work$handle() {
        return LAPACKE_sgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdx_work$address() {
        return LAPACKE_sgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, float *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdx_work$descriptor() {
        return LAPACKE_dgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdx_work$handle() {
        return LAPACKE_dgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdx_work$address() {
        return LAPACKE_dgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, double *work, int lwork, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdx_work$descriptor() {
        return LAPACKE_cgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdx_work$handle() {
        return LAPACKE_cgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdx_work$address() {
        return LAPACKE_cgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, _Complex float *work, int lwork, float *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_cgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_cgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvdx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdx_work$descriptor() {
        return LAPACKE_zgesvdx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdx_work$handle() {
        return LAPACKE_zgesvdx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdx_work$address() {
        return LAPACKE_zgesvdx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx_work(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, _Complex double *work, int lwork, double *rwork, int *iwork)
     * }
     */
    public static int LAPACKE_zgesvdx_work(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork) {
        var mh$ = LAPACKE_zgesvdx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdx_work", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, work, lwork, rwork, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdq_work$descriptor() {
        return LAPACKE_sgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdq_work$handle() {
        return LAPACKE_sgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdq_work$address() {
        return LAPACKE_sgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank, int *iwork, int liwork, float *work, int lwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_sgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment work, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_sgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdq_work$descriptor() {
        return LAPACKE_dgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdq_work$handle() {
        return LAPACKE_dgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdq_work$address() {
        return LAPACKE_dgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank, int *iwork, int liwork, double *work, int lwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_dgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment work, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_dgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdq_work$descriptor() {
        return LAPACKE_cgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdq_work$handle() {
        return LAPACKE_cgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdq_work$address() {
        return LAPACKE_cgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank, int *iwork, int liwork, _Complex float *cwork, int lcwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment cwork, int lcwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdq_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvdq_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdq_work$descriptor() {
        return LAPACKE_zgesvdq_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdq_work$handle() {
        return LAPACKE_zgesvdq_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdq_work$address() {
        return LAPACKE_zgesvdq_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq_work(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank, int *iwork, int liwork, _Complex double *cwork, int lcwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zgesvdq_work(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank, MemorySegment iwork, int liwork, MemorySegment cwork, int lcwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zgesvdq_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdq_work", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvj_work$descriptor() {
        return LAPACKE_sgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvj_work$handle() {
        return LAPACKE_sgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvj_work$address() {
        return LAPACKE_sgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvj_work$descriptor() {
        return LAPACKE_dgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvj_work$handle() {
        return LAPACKE_dgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvj_work$address() {
        return LAPACKE_dgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvj_work$descriptor() {
        return LAPACKE_cgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvj_work$handle() {
        return LAPACKE_cgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvj_work$address() {
        return LAPACKE_cgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, _Complex float *cwork, int lwork, float *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_cgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_cgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvj_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvj_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvj_work$descriptor() {
        return LAPACKE_zgesvj_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvj_work$handle() {
        return LAPACKE_zgesvj_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvj_work$address() {
        return LAPACKE_zgesvj_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvj_work(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, _Complex double *cwork, int lwork, double *rwork, int lrwork)
     * }
     */
    public static int LAPACKE_zgesvj_work(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment cwork, int lwork, MemorySegment rwork, int lrwork) {
        var mh$ = LAPACKE_zgesvj_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvj_work", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, cwork, lwork, rwork, lrwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvx_work$descriptor() {
        return LAPACKE_sgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvx_work$handle() {
        return LAPACKE_sgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvx_work$address() {
        return LAPACKE_sgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvx_work$descriptor() {
        return LAPACKE_dgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvx_work$handle() {
        return LAPACKE_dgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvx_work$address() {
        return LAPACKE_dgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvx_work$descriptor() {
        return LAPACKE_cgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvx_work$handle() {
        return LAPACKE_cgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvx_work$address() {
        return LAPACKE_cgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvx_work$descriptor() {
        return LAPACKE_zgesvx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvx_work$handle() {
        return LAPACKE_zgesvx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvx_work$address() {
        return LAPACKE_zgesvx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvxx_work$descriptor() {
        return LAPACKE_sgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_sgesvxx_work$handle() {
        return LAPACKE_sgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_sgesvxx_work$address() {
        return LAPACKE_sgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, float *work, int *iwork)
     * }
     */
    public static int LAPACKE_sgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_sgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvxx_work$descriptor() {
        return LAPACKE_dgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MethodHandle LAPACKE_dgesvxx_work$handle() {
        return LAPACKE_dgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static MemorySegment LAPACKE_dgesvxx_work$address() {
        return LAPACKE_dgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, double *work, int *iwork)
     * }
     */
    public static int LAPACKE_dgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment iwork) {
        var mh$ = LAPACKE_dgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvxx_work$descriptor() {
        return LAPACKE_cgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cgesvxx_work$handle() {
        return LAPACKE_cgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cgesvxx_work$address() {
        return LAPACKE_cgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params, _Complex float *work, float *rwork)
     * }
     */
    public static int LAPACKE_cgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_cgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvxx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvxx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvxx_work$descriptor() {
        return LAPACKE_zgesvxx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zgesvxx_work$handle() {
        return LAPACKE_zgesvxx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zgesvxx_work$address() {
        return LAPACKE_zgesvxx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx_work(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params, _Complex double *work, double *rwork)
     * }
     */
    public static int LAPACKE_zgesvxx_work(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params, MemorySegment work, MemorySegment rwork) {
        var mh$ = LAPACKE_zgesvxx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvxx_work", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetf2_work$descriptor() {
        return LAPACKE_sgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetf2_work$handle() {
        return LAPACKE_sgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetf2_work$address() {
        return LAPACKE_sgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetf2_work$descriptor() {
        return LAPACKE_dgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetf2_work$handle() {
        return LAPACKE_dgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetf2_work$address() {
        return LAPACKE_dgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetf2_work$descriptor() {
        return LAPACKE_cgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetf2_work$handle() {
        return LAPACKE_cgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetf2_work$address() {
        return LAPACKE_cgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetf2_work$descriptor() {
        return LAPACKE_zgetf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetf2_work$handle() {
        return LAPACKE_zgetf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetf2_work$address() {
        return LAPACKE_zgetf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf_work$descriptor() {
        return LAPACKE_sgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf_work$handle() {
        return LAPACKE_sgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf_work$address() {
        return LAPACKE_sgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf_work$descriptor() {
        return LAPACKE_dgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf_work$handle() {
        return LAPACKE_dgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf_work$address() {
        return LAPACKE_dgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf_work$descriptor() {
        return LAPACKE_cgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf_work$handle() {
        return LAPACKE_cgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf_work$address() {
        return LAPACKE_cgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrf_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf_work$descriptor() {
        return LAPACKE_zgetrf_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf_work$handle() {
        return LAPACKE_zgetrf_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf_work$address() {
        return LAPACKE_zgetrf_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf2_work$descriptor() {
        return LAPACKE_sgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf2_work$handle() {
        return LAPACKE_sgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf2_work$address() {
        return LAPACKE_sgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf2_work$descriptor() {
        return LAPACKE_dgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf2_work$handle() {
        return LAPACKE_dgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf2_work$address() {
        return LAPACKE_dgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf2_work$descriptor() {
        return LAPACKE_cgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf2_work$handle() {
        return LAPACKE_cgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf2_work$address() {
        return LAPACKE_cgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf2_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrf2_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf2_work$descriptor() {
        return LAPACKE_zgetrf2_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf2_work$handle() {
        return LAPACKE_zgetrf2_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf2_work$address() {
        return LAPACKE_zgetrf2_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf2_work(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf2_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf2_work", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetri_work$descriptor() {
        return LAPACKE_sgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgetri_work$handle() {
        return LAPACKE_sgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgetri_work$address() {
        return LAPACKE_sgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetri_work(int matrix_layout, int n, float *a, int lda, const int *ipiv, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetri_work$descriptor() {
        return LAPACKE_dgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgetri_work$handle() {
        return LAPACKE_dgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgetri_work$address() {
        return LAPACKE_dgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetri_work(int matrix_layout, int n, double *a, int lda, const int *ipiv, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetri_work$descriptor() {
        return LAPACKE_cgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgetri_work$handle() {
        return LAPACKE_cgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgetri_work$address() {
        return LAPACKE_cgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetri_work(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetri_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetri_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetri_work$descriptor() {
        return LAPACKE_zgetri_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgetri_work$handle() {
        return LAPACKE_zgetri_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgetri_work$address() {
        return LAPACKE_zgetri_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetri_work(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgetri_work(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgetri_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetri_work", matrix_layout, n, a, lda, ipiv, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrs_work$descriptor() {
        return LAPACKE_sgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgetrs_work$handle() {
        return LAPACKE_sgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgetrs_work$address() {
        return LAPACKE_sgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrs_work(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrs_work$descriptor() {
        return LAPACKE_dgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgetrs_work$handle() {
        return LAPACKE_dgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgetrs_work$address() {
        return LAPACKE_dgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrs_work(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrs_work$descriptor() {
        return LAPACKE_cgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgetrs_work$handle() {
        return LAPACKE_cgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgetrs_work$address() {
        return LAPACKE_cgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrs_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrs_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrs_work$descriptor() {
        return LAPACKE_zgetrs_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgetrs_work$handle() {
        return LAPACKE_zgetrs_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgetrs_work$address() {
        return LAPACKE_zgetrs_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrs_work(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgetrs_work(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgetrs_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrs_work", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbak_work$descriptor() {
        return LAPACKE_sggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sggbak_work$handle() {
        return LAPACKE_sggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sggbak_work$address() {
        return LAPACKE_sggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbak_work$descriptor() {
        return LAPACKE_dggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dggbak_work$handle() {
        return LAPACKE_dggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dggbak_work$address() {
        return LAPACKE_dggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbak_work$descriptor() {
        return LAPACKE_cggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cggbak_work$handle() {
        return LAPACKE_cggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cggbak_work$address() {
        return LAPACKE_cggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbak_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggbak_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbak_work$descriptor() {
        return LAPACKE_zggbak_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zggbak_work$handle() {
        return LAPACKE_zggbak_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zggbak_work$address() {
        return LAPACKE_zggbak_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbak_work(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zggbak_work(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zggbak_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbak_work", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbal_work$descriptor() {
        return LAPACKE_sggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MethodHandle LAPACKE_sggbal_work$handle() {
        return LAPACKE_sggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MemorySegment LAPACKE_sggbal_work$address() {
        return LAPACKE_sggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbal_work(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static int LAPACKE_sggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_sggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbal_work$descriptor() {
        return LAPACKE_dggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MethodHandle LAPACKE_dggbal_work$handle() {
        return LAPACKE_dggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MemorySegment LAPACKE_dggbal_work$address() {
        return LAPACKE_dggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbal_work(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static int LAPACKE_dggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_dggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbal_work$descriptor() {
        return LAPACKE_cggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MethodHandle LAPACKE_cggbal_work$handle() {
        return LAPACKE_cggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static MemorySegment LAPACKE_cggbal_work$address() {
        return LAPACKE_cggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbal_work(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work)
     * }
     */
    public static int LAPACKE_cggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_cggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbal_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggbal_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbal_work$descriptor() {
        return LAPACKE_zggbal_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MethodHandle LAPACKE_zggbal_work$handle() {
        return LAPACKE_zggbal_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static MemorySegment LAPACKE_zggbal_work$address() {
        return LAPACKE_zggbal_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbal_work(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work)
     * }
     */
    public static int LAPACKE_zggbal_work(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work) {
        var mh$ = LAPACKE_zggbal_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbal_work", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges_work$descriptor() {
        return LAPACKE_sgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgges_work$handle() {
        return LAPACKE_sgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgges_work$address() {
        return LAPACKE_sgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges_work$descriptor() {
        return LAPACKE_dgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgges_work$handle() {
        return LAPACKE_dgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgges_work$address() {
        return LAPACKE_dgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges_work$descriptor() {
        return LAPACKE_cgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgges_work$handle() {
        return LAPACKE_cgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgges_work$address() {
        return LAPACKE_cgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgges_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges_work$descriptor() {
        return LAPACKE_zgges_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgges_work$handle() {
        return LAPACKE_zgges_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgges_work$address() {
        return LAPACKE_zgges_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgges_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgges_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges3_work$descriptor() {
        return LAPACKE_sgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sgges3_work$handle() {
        return LAPACKE_sgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sgges3_work$address() {
        return LAPACKE_sgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_sgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges3_work$descriptor() {
        return LAPACKE_dgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dgges3_work$handle() {
        return LAPACKE_dgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dgges3_work$address() {
        return LAPACKE_dgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *work, int lwork, int *bwork)
     * }
     */
    public static int LAPACKE_dgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges3_work$descriptor() {
        return LAPACKE_cgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cgges3_work$handle() {
        return LAPACKE_cgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cgges3_work$address() {
        return LAPACKE_cgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, _Complex float *work, int lwork, float *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_cgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgges3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges3_work$descriptor() {
        return LAPACKE_zgges3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zgges3_work$handle() {
        return LAPACKE_zgges3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zgges3_work$address() {
        return LAPACKE_zgges3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges3_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, _Complex double *work, int lwork, double *rwork, int *bwork)
     * }
     */
    public static int LAPACKE_zgges3_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zgges3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges3_work", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, work, lwork, rwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggesx_work$descriptor() {
        return LAPACKE_sggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sggesx_work$handle() {
        return LAPACKE_sggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sggesx_work$address() {
        return LAPACKE_sggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_sggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggesx_work$descriptor() {
        return LAPACKE_dggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dggesx_work$handle() {
        return LAPACKE_dggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dggesx_work$address() {
        return LAPACKE_dggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_dggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggesx_work$descriptor() {
        return LAPACKE_cggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cggesx_work$handle() {
        return LAPACKE_cggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cggesx_work$address() {
        return LAPACKE_cggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_cggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggesx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggesx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggesx_work$descriptor() {
        return LAPACKE_zggesx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zggesx_work$handle() {
        return LAPACKE_zggesx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zggesx_work$address() {
        return LAPACKE_zggesx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggesx_work(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int liwork, int *bwork)
     * }
     */
    public static int LAPACKE_zggesx_work(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, int liwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zggesx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggesx_work", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev_work$descriptor() {
        return LAPACKE_sggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggev_work$handle() {
        return LAPACKE_sggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggev_work$address() {
        return LAPACKE_sggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev_work$descriptor() {
        return LAPACKE_dggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggev_work$handle() {
        return LAPACKE_dggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggev_work$address() {
        return LAPACKE_dggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev_work$descriptor() {
        return LAPACKE_cggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cggev_work$handle() {
        return LAPACKE_cggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cggev_work$address() {
        return LAPACKE_cggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggev_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev_work$descriptor() {
        return LAPACKE_zggev_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zggev_work$handle() {
        return LAPACKE_zggev_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zggev_work$address() {
        return LAPACKE_zggev_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zggev_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zggev_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev3_work$descriptor() {
        return LAPACKE_sggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggev3_work$handle() {
        return LAPACKE_sggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggev3_work$address() {
        return LAPACKE_sggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev3_work(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev3_work$descriptor() {
        return LAPACKE_dggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggev3_work$handle() {
        return LAPACKE_dggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggev3_work$address() {
        return LAPACKE_dggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev3_work(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev3_work$descriptor() {
        return LAPACKE_cggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MethodHandle LAPACKE_cggev3_work$handle() {
        return LAPACKE_cggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static MemorySegment LAPACKE_cggev3_work$address() {
        return LAPACKE_cggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, _Complex float *work, int lwork, float *rwork)
     * }
     */
    public static int LAPACKE_cggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_cggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggev3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev3_work$descriptor() {
        return LAPACKE_zggev3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MethodHandle LAPACKE_zggev3_work$handle() {
        return LAPACKE_zggev3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static MemorySegment LAPACKE_zggev3_work$address() {
        return LAPACKE_zggev3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev3_work(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, _Complex double *work, int lwork, double *rwork)
     * }
     */
    public static int LAPACKE_zggev3_work(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment work, int lwork, MemorySegment rwork) {
        var mh$ = LAPACKE_zggev3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev3_work", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, work, lwork, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggevx_work$descriptor() {
        return LAPACKE_sggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_sggevx_work$handle() {
        return LAPACKE_sggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_sggevx_work$address() {
        return LAPACKE_sggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_sggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_sggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggevx_work$descriptor() {
        return LAPACKE_dggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_dggevx_work$handle() {
        return LAPACKE_dggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_dggevx_work$address() {
        return LAPACKE_dggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, int lwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_dggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_dggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggevx_work$descriptor() {
        return LAPACKE_cggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_cggevx_work$handle() {
        return LAPACKE_cggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_cggevx_work$address() {
        return LAPACKE_cggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, int lwork, float *rwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_cggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_cggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggevx_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggevx_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggevx_work$descriptor() {
        return LAPACKE_zggevx_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static MethodHandle LAPACKE_zggevx_work$handle() {
        return LAPACKE_zggevx_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static MemorySegment LAPACKE_zggevx_work$address() {
        return LAPACKE_zggevx_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggevx_work(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, int lwork, double *rwork, int *iwork, int *bwork)
     * }
     */
    public static int LAPACKE_zggevx_work(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, int lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment bwork) {
        var mh$ = LAPACKE_zggevx_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggevx_work", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, bwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggglm_work$descriptor() {
        return LAPACKE_sggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sggglm_work$handle() {
        return LAPACKE_sggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sggglm_work$address() {
        return LAPACKE_sggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggglm_work$descriptor() {
        return LAPACKE_dggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dggglm_work$handle() {
        return LAPACKE_dggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dggglm_work$address() {
        return LAPACKE_dggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggglm_work$descriptor() {
        return LAPACKE_cggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cggglm_work$handle() {
        return LAPACKE_cggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cggglm_work$address() {
        return LAPACKE_cggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggglm_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggglm_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggglm_work$descriptor() {
        return LAPACKE_zggglm_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zggglm_work$handle() {
        return LAPACKE_zggglm_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zggglm_work$address() {
        return LAPACKE_zggglm_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zggglm_work(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zggglm_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggglm_work", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghrd_work$descriptor() {
        return LAPACKE_sgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghrd_work$handle() {
        return LAPACKE_sgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghrd_work$address() {
        return LAPACKE_sgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghrd_work$descriptor() {
        return LAPACKE_dgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghrd_work$handle() {
        return LAPACKE_dgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghrd_work$address() {
        return LAPACKE_dgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghrd_work$descriptor() {
        return LAPACKE_cgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghrd_work$handle() {
        return LAPACKE_cgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghrd_work$address() {
        return LAPACKE_cgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghrd_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgghrd_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghrd_work$descriptor() {
        return LAPACKE_zgghrd_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghrd_work$handle() {
        return LAPACKE_zgghrd_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghrd_work$address() {
        return LAPACKE_zgghrd_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghrd_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghrd_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghrd_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghrd_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghd3_work$descriptor() {
        return LAPACKE_sgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgghd3_work$handle() {
        return LAPACKE_sgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgghd3_work$address() {
        return LAPACKE_sgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghd3_work$descriptor() {
        return LAPACKE_dgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgghd3_work$handle() {
        return LAPACKE_dgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgghd3_work$address() {
        return LAPACKE_dgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghd3_work$descriptor() {
        return LAPACKE_cgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgghd3_work$handle() {
        return LAPACKE_cgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgghd3_work$address() {
        return LAPACKE_cgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghd3_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgghd3_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghd3_work$descriptor() {
        return LAPACKE_zgghd3_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_zgghd3_work$handle() {
        return LAPACKE_zgghd3_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_zgghd3_work$address() {
        return LAPACKE_zgghd3_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghd3_work(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz, _Complex double *work, int lwork)
     * }
     */
    public static int LAPACKE_zgghd3_work(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_zgghd3_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghd3_work", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgglse_work$descriptor() {
        return LAPACKE_sgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_sgglse_work$handle() {
        return LAPACKE_sgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_sgglse_work$address() {
        return LAPACKE_sgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x, float *work, int lwork)
     * }
     */
    public static int LAPACKE_sgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_sgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgglse_work$descriptor() {
        return LAPACKE_dgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_dgglse_work$handle() {
        return LAPACKE_dgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_dgglse_work$address() {
        return LAPACKE_dgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x, double *work, int lwork)
     * }
     */
    public static int LAPACKE_dgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_dgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgglse_work {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgglse_work");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC, Linker.Option.critical(true));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgglse_work$descriptor() {
        return LAPACKE_cgglse_work.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static MethodHandle LAPACKE_cgglse_work$handle() {
        return LAPACKE_cgglse_work.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static MemorySegment LAPACKE_cgglse_work$address() {
        return LAPACKE_cgglse_work.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x, _Complex float *work, int lwork)
     * }
     */
    public static int LAPACKE_cgglse_work(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x, MemorySegment work, int lwork) {
        var mh$ = LAPACKE_cgglse_work.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgglse_work", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x, work, lwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

