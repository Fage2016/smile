// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class lapacke_h_3 extends lapacke_h_4 {

    lapacke_h_3() {
        // Should not be called directly
    }

    private static class slansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansy_$descriptor() {
        return slansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansy_$handle() {
        return slansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansy_$address() {
        return slansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansy_(const char *norm, const char *uplo, const int *n, const float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float slansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = slansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansy_$descriptor() {
        return zlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansy_$handle() {
        return zlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansy_$address() {
        return zlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansy_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double zlansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = zlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantb_$descriptor() {
        return clantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantb_$handle() {
        return clantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantb_$address() {
        return clantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = clantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantb_$descriptor() {
        return dlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantb_$handle() {
        return dlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantb_$address() {
        return dlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = dlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantb_$descriptor() {
        return slantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantb_$handle() {
        return slantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantb_$address() {
        return slantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = slantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlantb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantb_$descriptor() {
        return zlantb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantb_$handle() {
        return zlantb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantb_$address() {
        return zlantb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantb_(const char *norm, const char *uplo, const char *diag, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantb_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = zlantb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantb_", norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, k, AB, ldab, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantp_$descriptor() {
        return clantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantp_$handle() {
        return clantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantp_$address() {
        return clantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = clantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantp_$descriptor() {
        return dlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantp_$handle() {
        return dlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantp_$address() {
        return dlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = dlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantp_$descriptor() {
        return slantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantp_$handle() {
        return slantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantp_$address() {
        return slantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantp_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = slantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlantp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantp_$descriptor() {
        return zlantp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantp_$handle() {
        return zlantp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantp_$address() {
        return zlantp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantp_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantp_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment work, long x6, long x7, long x8) {
        var mh$ = zlantp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantp_", norm, uplo, diag, n, AP, work, x6, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, n, AP, work, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clantr_$descriptor() {
        return clantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clantr_$handle() {
        return clantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clantr_$address() {
        return clantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static float clantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = clantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlantr_$descriptor() {
        return dlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlantr_$handle() {
        return dlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlantr_$address() {
        return dlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static double dlantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = dlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slantr_$descriptor() {
        return slantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slantr_$handle() {
        return slantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slantr_$address() {
        return slantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const float *A, const int *lda, float *work, size_t, size_t, size_t)
     * }
     */
    public static float slantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = slantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (float)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlantr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlantr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlantr_$descriptor() {
        return zlantr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlantr_$handle() {
        return zlantr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlantr_$address() {
        return zlantr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlantr_(const char *norm, const char *uplo, const char *diag, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t, size_t)
     * }
     */
    public static double zlantr_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x8, long x9, long x10) {
        var mh$ = zlantr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlantr_", norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
            }
            return (double)mh$.invokeExact(norm, uplo, diag, m, n, A, lda, work, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor clapmr_$descriptor() {
        return clapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle clapmr_$handle() {
        return clapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment clapmr_$address() {
        return clapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clapmr_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static void clapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = clapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor dlapmr_$descriptor() {
        return dlapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle dlapmr_$handle() {
        return dlapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment dlapmr_$address() {
        return dlapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlapmr_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static void dlapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = dlapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor slapmr_$descriptor() {
        return slapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle slapmr_$handle() {
        return slapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment slapmr_$address() {
        return slapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slapmr_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static void slapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = slapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapmr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlapmr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor zlapmr_$descriptor() {
        return zlapmr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle zlapmr_$handle() {
        return zlapmr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment zlapmr_$address() {
        return zlapmr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlapmr_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static void zlapmr_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = zlapmr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapmr_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor clapmt_$descriptor() {
        return clapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle clapmt_$handle() {
        return clapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment clapmt_$address() {
        return clapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clapmt_(const int *forwrd, const int *m, const int *n, _Complex float *X, const int *ldx, int *K)
     * }
     */
    public static void clapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = clapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor dlapmt_$descriptor() {
        return dlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle dlapmt_$handle() {
        return dlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment dlapmt_$address() {
        return dlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlapmt_(const int *forwrd, const int *m, const int *n, double *X, const int *ldx, int *K)
     * }
     */
    public static void dlapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = dlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor slapmt_$descriptor() {
        return slapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle slapmt_$handle() {
        return slapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment slapmt_$address() {
        return slapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slapmt_(const int *forwrd, const int *m, const int *n, float *X, const int *ldx, int *K)
     * }
     */
    public static void slapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = slapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlapmt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlapmt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static FunctionDescriptor zlapmt_$descriptor() {
        return zlapmt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MethodHandle zlapmt_$handle() {
        return zlapmt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static MemorySegment zlapmt_$address() {
        return zlapmt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlapmt_(const int *forwrd, const int *m, const int *n, _Complex double *X, const int *ldx, int *K)
     * }
     */
    public static void zlapmt_(MemorySegment forwrd, MemorySegment m, MemorySegment n, MemorySegment X, MemorySegment ldx, MemorySegment K) {
        var mh$ = zlapmt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlapmt_", forwrd, m, n, X, ldx, K);
            }
            mh$.invokeExact(forwrd, m, n, X, ldx, K);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static FunctionDescriptor dlapy2_$descriptor() {
        return dlapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static MethodHandle dlapy2_$handle() {
        return dlapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static MemorySegment dlapy2_$address() {
        return dlapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlapy2_(const double *x, const double *y)
     * }
     */
    public static double dlapy2_(MemorySegment x, MemorySegment y) {
        var mh$ = dlapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy2_", x, y);
            }
            return (double)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slapy2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static FunctionDescriptor slapy2_$descriptor() {
        return slapy2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static MethodHandle slapy2_$handle() {
        return slapy2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static MemorySegment slapy2_$address() {
        return slapy2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slapy2_(const float *x, const float *y)
     * }
     */
    public static float slapy2_(MemorySegment x, MemorySegment y) {
        var mh$ = slapy2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy2_", x, y);
            }
            return (float)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static FunctionDescriptor dlapy3_$descriptor() {
        return dlapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static MethodHandle dlapy3_$handle() {
        return dlapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static MemorySegment dlapy3_$address() {
        return dlapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlapy3_(const double *x, const double *y, const double *z)
     * }
     */
    public static double dlapy3_(MemorySegment x, MemorySegment y, MemorySegment z) {
        var mh$ = dlapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlapy3_", x, y, z);
            }
            return (double)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slapy3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slapy3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static FunctionDescriptor slapy3_$descriptor() {
        return slapy3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static MethodHandle slapy3_$handle() {
        return slapy3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static MemorySegment slapy3_$address() {
        return slapy3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slapy3_(const float *x, const float *y, const float *z)
     * }
     */
    public static float slapy3_(MemorySegment x, MemorySegment y, MemorySegment z) {
        var mh$ = slapy3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slapy3_", x, y, z);
            }
            return (float)mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static FunctionDescriptor clarcm_$descriptor() {
        return clarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MethodHandle clarcm_$handle() {
        return clarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MemorySegment clarcm_$address() {
        return clarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarcm_(const int *m, const int *n, const float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static void clarcm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = clarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarcm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarcm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarcm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static FunctionDescriptor zlarcm_$descriptor() {
        return zlarcm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MethodHandle zlarcm_$handle() {
        return zlarcm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MemorySegment zlarcm_$address() {
        return zlarcm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarcm_(const int *m, const int *n, const double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static void zlarcm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = zlarcm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarcm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static FunctionDescriptor clarf_$descriptor() {
        return clarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MethodHandle clarf_$handle() {
        return clarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MemorySegment clarf_$address() {
        return clarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarf_(const char *side, const int *m, const int *n, const _Complex float *V, const int *incv, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static void clarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = clarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlarf_$descriptor() {
        return dlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MethodHandle dlarf_$handle() {
        return dlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MemorySegment dlarf_$address() {
        return dlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarf_(const char *side, const int *m, const int *n, const double *V, const int *incv, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static void dlarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = dlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slarf_$descriptor() {
        return slarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MethodHandle slarf_$handle() {
        return slarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MemorySegment slarf_$address() {
        return slarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarf_(const char *side, const int *m, const int *n, const float *V, const int *incv, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static void slarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = slarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlarf_$descriptor() {
        return zlarf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MethodHandle zlarf_$handle() {
        return zlarf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MemorySegment zlarf_$address() {
        return zlarf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarf_(const char *side, const int *m, const int *n, const _Complex double *V, const int *incv, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static void zlarf_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment incv, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x9) {
        var mh$ = zlarf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarf_", side, m, n, V, incv, tau, C, ldc, work, x9);
            }
            mh$.invokeExact(side, m, n, V, incv, tau, C, ldc, work, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clarfb_$descriptor() {
        return clarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clarfb_$handle() {
        return clarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clarfb_$address() {
        return clarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void clarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = clarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlarfb_$descriptor() {
        return dlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlarfb_$handle() {
        return dlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlarfb_$address() {
        return dlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dlarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = dlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slarfb_$descriptor() {
        return slarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slarfb_$handle() {
        return slarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slarfb_$address() {
        return slarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void slarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = slarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlarfb_$descriptor() {
        return zlarfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlarfb_$handle() {
        return zlarfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlarfb_$address() {
        return zlarfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zlarfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment ldwork, long x15, long x16, long x17, long x18) {
        var mh$ = zlarfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfb_", side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, V, ldv, T, ldt, C, ldc, work, ldwork, x15, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor clarfg_$descriptor() {
        return clarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static MethodHandle clarfg_$handle() {
        return clarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static MemorySegment clarfg_$address() {
        return clarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfg_(const int *n, _Complex float *alpha, _Complex float *X, const int *incx, _Complex float *tau)
     * }
     */
    public static void clarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = clarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static FunctionDescriptor dlarfg_$descriptor() {
        return dlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static MethodHandle dlarfg_$handle() {
        return dlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static MemorySegment dlarfg_$address() {
        return dlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfg_(const int *n, double *alpha, double *X, const int *incx, double *tau)
     * }
     */
    public static void dlarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = dlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static FunctionDescriptor slarfg_$descriptor() {
        return slarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static MethodHandle slarfg_$handle() {
        return slarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static MemorySegment slarfg_$address() {
        return slarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfg_(const int *n, float *alpha, float *X, const int *incx, float *tau)
     * }
     */
    public static void slarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = slarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfg_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarfg_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor zlarfg_$descriptor() {
        return zlarfg_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static MethodHandle zlarfg_$handle() {
        return zlarfg_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static MemorySegment zlarfg_$address() {
        return zlarfg_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfg_(const int *n, _Complex double *alpha, _Complex double *X, const int *incx, _Complex double *tau)
     * }
     */
    public static void zlarfg_(MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment tau) {
        var mh$ = zlarfg_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfg_", n, alpha, X, incx, tau);
            }
            mh$.invokeExact(n, alpha, X, incx, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clarft_$descriptor() {
        return clarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle clarft_$handle() {
        return clarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment clarft_$address() {
        return clarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex float *V, const int *ldv, const _Complex float *tau, _Complex float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void clarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = clarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlarft_$descriptor() {
        return dlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle dlarft_$handle() {
        return dlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment dlarft_$address() {
        return dlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarft_(const char *direct, const char *storev, const int *n, const int *k, const double *V, const int *ldv, const double *tau, double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void dlarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = dlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slarft_$descriptor() {
        return slarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle slarft_$handle() {
        return slarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment slarft_$address() {
        return slarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarft_(const char *direct, const char *storev, const int *n, const int *k, const float *V, const int *ldv, const float *tau, float *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void slarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = slarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarft_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarft_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlarft_$descriptor() {
        return zlarft_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MethodHandle zlarft_$handle() {
        return zlarft_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static MemorySegment zlarft_$address() {
        return zlarft_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarft_(const char *direct, const char *storev, const int *n, const int *k, const _Complex double *V, const int *ldv, const _Complex double *tau, _Complex double *T, const int *ldt, size_t, size_t)
     * }
     */
    public static void zlarft_(MemorySegment direct, MemorySegment storev, MemorySegment n, MemorySegment k, MemorySegment V, MemorySegment ldv, MemorySegment tau, MemorySegment T, MemorySegment ldt, long x9, long x10) {
        var mh$ = zlarft_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarft_", direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
            }
            mh$.invokeExact(direct, storev, n, k, V, ldv, tau, T, ldt, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static FunctionDescriptor clarfx_$descriptor() {
        return clarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MethodHandle clarfx_$handle() {
        return clarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static MemorySegment clarfx_$address() {
        return clarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarfx_(const char *side, const int *m, const int *n, const _Complex float *V, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, size_t)
     * }
     */
    public static void clarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = clarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlarfx_$descriptor() {
        return dlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MethodHandle dlarfx_$handle() {
        return dlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static MemorySegment dlarfx_$address() {
        return dlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarfx_(const char *side, const int *m, const int *n, const double *V, const double *tau, double *C, const int *ldc, double *work, size_t)
     * }
     */
    public static void dlarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = dlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slarfx_$descriptor() {
        return slarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MethodHandle slarfx_$handle() {
        return slarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static MemorySegment slarfx_$address() {
        return slarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarfx_(const char *side, const int *m, const int *n, const float *V, const float *tau, float *C, const int *ldc, float *work, size_t)
     * }
     */
    public static void slarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = slarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarfx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarfx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlarfx_$descriptor() {
        return zlarfx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MethodHandle zlarfx_$handle() {
        return zlarfx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static MemorySegment zlarfx_$address() {
        return zlarfx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarfx_(const char *side, const int *m, const int *n, const _Complex double *V, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, size_t)
     * }
     */
    public static void zlarfx_(MemorySegment side, MemorySegment m, MemorySegment n, MemorySegment V, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, long x8) {
        var mh$ = zlarfx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarfx_", side, m, n, V, tau, C, ldc, work, x8);
            }
            mh$.invokeExact(side, m, n, V, tau, C, ldc, work, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static FunctionDescriptor clarnv_$descriptor() {
        return clarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static MethodHandle clarnv_$handle() {
        return clarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static MemorySegment clarnv_$address() {
        return clarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clarnv_(const int *idist, int *iseed, const int *n, _Complex float *X)
     * }
     */
    public static void clarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = clarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static FunctionDescriptor dlarnv_$descriptor() {
        return dlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static MethodHandle dlarnv_$handle() {
        return dlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static MemorySegment dlarnv_$address() {
        return dlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlarnv_(const int *idist, int *iseed, const int *n, double *X)
     * }
     */
    public static void dlarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = dlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static FunctionDescriptor slarnv_$descriptor() {
        return slarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static MethodHandle slarnv_$handle() {
        return slarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static MemorySegment slarnv_$address() {
        return slarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slarnv_(const int *idist, int *iseed, const int *n, float *X)
     * }
     */
    public static void slarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = slarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlarnv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlarnv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static FunctionDescriptor zlarnv_$descriptor() {
        return zlarnv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static MethodHandle zlarnv_$handle() {
        return zlarnv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static MemorySegment zlarnv_$address() {
        return zlarnv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlarnv_(const int *idist, int *iseed, const int *n, _Complex double *X)
     * }
     */
    public static void zlarnv_(MemorySegment idist, MemorySegment iseed, MemorySegment n, MemorySegment X) {
        var mh$ = zlarnv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlarnv_", idist, iseed, n, X);
            }
            mh$.invokeExact(idist, iseed, n, X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartgp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlartgp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static FunctionDescriptor dlartgp_$descriptor() {
        return dlartgp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static MethodHandle dlartgp_$handle() {
        return dlartgp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static MemorySegment dlartgp_$address() {
        return dlartgp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlartgp_(const double *f, const double *g, double *cs, double *sn, double *r)
     * }
     */
    public static void dlartgp_(MemorySegment f, MemorySegment g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = dlartgp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartgp_", f, g, cs, sn, r);
            }
            mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartgp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slartgp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static FunctionDescriptor slartgp_$descriptor() {
        return slartgp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static MethodHandle slartgp_$handle() {
        return slartgp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static MemorySegment slartgp_$address() {
        return slartgp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slartgp_(const float *f, const float *g, float *cs, float *sn, float *r)
     * }
     */
    public static void slartgp_(MemorySegment f, MemorySegment g, MemorySegment cs, MemorySegment sn, MemorySegment r) {
        var mh$ = slartgp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartgp_", f, g, cs, sn, r);
            }
            mh$.invokeExact(f, g, cs, sn, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlartgs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlartgs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static FunctionDescriptor dlartgs_$descriptor() {
        return dlartgs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static MethodHandle dlartgs_$handle() {
        return dlartgs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static MemorySegment dlartgs_$address() {
        return dlartgs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlartgs_(const double *x, const double *y, const double *sigma, double *cs, double *sn)
     * }
     */
    public static void dlartgs_(MemorySegment x, MemorySegment y, MemorySegment sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = dlartgs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlartgs_", x, y, sigma, cs, sn);
            }
            mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slartgs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slartgs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static FunctionDescriptor slartgs_$descriptor() {
        return slartgs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static MethodHandle slartgs_$handle() {
        return slartgs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static MemorySegment slartgs_$address() {
        return slartgs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slartgs_(const float *x, const float *y, const float *sigma, float *cs, float *sn)
     * }
     */
    public static void slartgs_(MemorySegment x, MemorySegment y, MemorySegment sigma, MemorySegment cs, MemorySegment sn) {
        var mh$ = slartgs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slartgs_", x, y, sigma, cs, sn);
            }
            mh$.invokeExact(x, y, sigma, cs, sn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor clascl_$descriptor() {
        return clascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle clascl_$handle() {
        return clascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment clascl_$address() {
        return clascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void clascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = clascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlascl_$descriptor() {
        return dlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dlascl_$handle() {
        return dlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dlascl_$address() {
        return dlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dlascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = dlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slascl_$descriptor() {
        return slascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle slascl_$handle() {
        return slascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment slascl_$address() {
        return slascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slascl_(const char *type, const int *kl, const int *ku, const float *cfrom, const float *cto, const int *m, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void slascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = slascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlascl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlascl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zlascl_$descriptor() {
        return zlascl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zlascl_$handle() {
        return zlascl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zlascl_$address() {
        return zlascl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlascl_(const char *type, const int *kl, const int *ku, const double *cfrom, const double *cto, const int *m, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zlascl_(MemorySegment type, MemorySegment kl, MemorySegment ku, MemorySegment cfrom, MemorySegment cto, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x10) {
        var mh$ = zlascl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlascl_", type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
            }
            mh$.invokeExact(type, kl, ku, cfrom, cto, m, n, A, lda, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("claset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor claset_$descriptor() {
        return claset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle claset_$handle() {
        return claset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment claset_$address() {
        return claset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claset_(const char *uplo, const int *m, const int *n, const _Complex float *alpha, const _Complex float *beta, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static void claset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = claset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor dlaset_$descriptor() {
        return dlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle dlaset_$handle() {
        return dlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment dlaset_$address() {
        return dlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlaset_(const char *uplo, const int *m, const int *n, const double *alpha, const double *beta, double *A, const int *lda, size_t)
     * }
     */
    public static void dlaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = dlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor slaset_$descriptor() {
        return slaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle slaset_$handle() {
        return slaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment slaset_$address() {
        return slaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slaset_(const char *uplo, const int *m, const int *n, const float *alpha, const float *beta, float *A, const int *lda, size_t)
     * }
     */
    public static void slaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = slaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaset_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlaset_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor zlaset_$descriptor() {
        return zlaset_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle zlaset_$handle() {
        return zlaset_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment zlaset_$address() {
        return zlaset_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaset_(const char *uplo, const int *m, const int *n, const _Complex double *alpha, const _Complex double *beta, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static void zlaset_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment beta, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = zlaset_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaset_", uplo, m, n, alpha, beta, A, lda, x7);
            }
            mh$.invokeExact(uplo, m, n, alpha, beta, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlasrt_$descriptor() {
        return dlasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static MethodHandle dlasrt_$handle() {
        return dlasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static MemorySegment dlasrt_$address() {
        return dlasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlasrt_(const char *id, const int *n, double *D, int *info, size_t)
     * }
     */
    public static void dlasrt_(MemorySegment id, MemorySegment n, MemorySegment D, MemorySegment info, long x4) {
        var mh$ = dlasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlasrt_", id, n, D, info, x4);
            }
            mh$.invokeExact(id, n, D, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slasrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slasrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slasrt_$descriptor() {
        return slasrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static MethodHandle slasrt_$handle() {
        return slasrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static MemorySegment slasrt_$address() {
        return slasrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slasrt_(const char *id, const int *n, float *D, int *info, size_t)
     * }
     */
    public static void slasrt_(MemorySegment id, MemorySegment n, MemorySegment D, MemorySegment info, long x4) {
        var mh$ = slasrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slasrt_", id, n, D, info, x4);
            }
            mh$.invokeExact(id, n, D, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class classq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("classq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor classq_$descriptor() {
        return classq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle classq_$handle() {
        return classq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment classq_$address() {
        return classq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void classq_(const int *n, const _Complex float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static void classq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = classq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("classq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor dlassq_$descriptor() {
        return dlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle dlassq_$handle() {
        return dlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment dlassq_$address() {
        return dlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlassq_(const int *n, const double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static void dlassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = dlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static FunctionDescriptor slassq_$descriptor() {
        return slassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MethodHandle slassq_$handle() {
        return slassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static MemorySegment slassq_$address() {
        return slassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slassq_(const int *n, const float *X, const int *incx, float *scale, float *sumsq)
     * }
     */
    public static void slassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = slassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlassq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlassq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static FunctionDescriptor zlassq_$descriptor() {
        return zlassq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MethodHandle zlassq_$handle() {
        return zlassq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static MemorySegment zlassq_$address() {
        return zlassq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlassq_(const int *n, const _Complex double *X, const int *incx, double *scale, double *sumsq)
     * }
     */
    public static void zlassq_(MemorySegment n, MemorySegment X, MemorySegment incx, MemorySegment scale, MemorySegment sumsq) {
        var mh$ = zlassq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlassq_", n, X, incx, scale, sumsq);
            }
            mh$.invokeExact(n, X, incx, scale, sumsq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("claswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor claswp_$descriptor() {
        return claswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle claswp_$handle() {
        return claswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment claswp_$address() {
        return claswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claswp_(const int *n, _Complex float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void claswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = claswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor dlaswp_$descriptor() {
        return dlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle dlaswp_$handle() {
        return dlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment dlaswp_$address() {
        return dlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlaswp_(const int *n, double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void dlaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = dlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor slaswp_$descriptor() {
        return slaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle slaswp_$handle() {
        return slaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment slaswp_$address() {
        return slaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slaswp_(const int *n, float *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void slaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = slaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaswp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlaswp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static FunctionDescriptor zlaswp_$descriptor() {
        return zlaswp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MethodHandle zlaswp_$handle() {
        return zlaswp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static MemorySegment zlaswp_$address() {
        return zlaswp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaswp_(const int *n, _Complex double *A, const int *lda, const int *k1, const int *k2, const int *ipiv, const int *incx)
     * }
     */
    public static void zlaswp_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment k1, MemorySegment k2, MemorySegment ipiv, MemorySegment incx) {
        var mh$ = zlaswp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaswp_", n, A, lda, k1, k2, ipiv, incx);
            }
            mh$.invokeExact(n, A, lda, k1, k2, ipiv, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clatms_$descriptor() {
        return clatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle clatms_$handle() {
        return clatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment clatms_$address() {
        return clatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, _Complex float *A, const int *lda, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void clatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = clatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlatms_$descriptor() {
        return dlatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dlatms_$handle() {
        return dlatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dlatms_$address() {
        return dlatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, double *A, const int *lda, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dlatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = dlatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slatms_$descriptor() {
        return slatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle slatms_$handle() {
        return slatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment slatms_$address() {
        return slatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, float *D, const int *mode, const float *cond, const float *dmax, const int *kl, const int *ku, const char *pack, float *A, const int *lda, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void slatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = slatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlatms_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlatms_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlatms_$descriptor() {
        return zlatms_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zlatms_$handle() {
        return zlatms_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zlatms_$address() {
        return zlatms_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlatms_(const int *m, const int *n, const char *dist, int *iseed, const char *sym, double *D, const int *mode, const double *cond, const double *dmax, const int *kl, const int *ku, const char *pack, _Complex double *A, const int *lda, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zlatms_(MemorySegment m, MemorySegment n, MemorySegment dist, MemorySegment iseed, MemorySegment sym, MemorySegment D, MemorySegment mode, MemorySegment cond, MemorySegment dmax, MemorySegment kl, MemorySegment ku, MemorySegment pack, MemorySegment A, MemorySegment lda, MemorySegment work, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = zlatms_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlatms_", m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
            }
            mh$.invokeExact(m, n, dist, iseed, sym, D, mode, cond, dmax, kl, ku, pack, A, lda, work, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor clauum_$descriptor() {
        return clauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle clauum_$handle() {
        return clauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment clauum_$address() {
        return clauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clauum_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void clauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = clauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dlauum_$descriptor() {
        return dlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dlauum_$handle() {
        return dlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dlauum_$address() {
        return dlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlauum_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dlauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor slauum_$descriptor() {
        return slauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle slauum_$handle() {
        return slauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment slauum_$address() {
        return slauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slauum_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void slauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = slauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlauum_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlauum_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zlauum_$descriptor() {
        return zlauum_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zlauum_$handle() {
        return zlauum_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zlauum_$address() {
        return zlauum_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlauum_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zlauum_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zlauum_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlauum_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilaver_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ilaver_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static FunctionDescriptor ilaver_$descriptor() {
        return ilaver_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MethodHandle ilaver_$handle() {
        return ilaver_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static MemorySegment ilaver_$address() {
        return ilaver_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ilaver_(int *vers_major, int *vers_minor, int *vers_patch)
     * }
     */
    public static void ilaver_(MemorySegment vers_major, MemorySegment vers_minor, MemorySegment vers_patch) {
        var mh$ = ilaver_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilaver_", vers_major, vers_minor, vers_patch);
            }
            mh$.invokeExact(vers_major, vers_minor, vers_patch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dopgtr_$descriptor() {
        return dopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dopgtr_$handle() {
        return dopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dopgtr_$address() {
        return dopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dopgtr_(const char *uplo, const int *n, const double *AP, const double *tau, double *Q, const int *ldq, double *work, int *info, size_t)
     * }
     */
    public static void dopgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sopgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sopgtr_$descriptor() {
        return sopgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sopgtr_$handle() {
        return sopgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sopgtr_$address() {
        return sopgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sopgtr_(const char *uplo, const int *n, const float *AP, const float *tau, float *Q, const int *ldq, float *work, int *info, size_t)
     * }
     */
    public static void sopgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = sopgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dopmtr_$descriptor() {
        return dopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dopmtr_$handle() {
        return dopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dopmtr_$address() {
        return dopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *AP, const double *tau, double *C, const int *ldc, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dopmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dopmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sopmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sopmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sopmtr_$descriptor() {
        return sopmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sopmtr_$handle() {
        return sopmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sopmtr_$address() {
        return sopmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sopmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *AP, const float *tau, float *C, const int *ldc, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sopmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = sopmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sopmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorbdb_$descriptor() {
        return dorbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dorbdb_$handle() {
        return dorbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dorbdb_$address() {
        return dorbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *phi, double *TAUP1, double *TAUP2, double *TAUQ1, double *TAUQ2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dorbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = dorbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorbdb_$descriptor() {
        return sorbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sorbdb_$handle() {
        return sorbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sorbdb_$address() {
        return sorbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *phi, float *TAUP1, float *TAUP2, float *TAUQ1, float *TAUQ2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sorbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = sorbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorcsd_$descriptor() {
        return dorcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dorcsd_$handle() {
        return dorcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dorcsd_$address() {
        return dorcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X12, const int *ldx12, double *X21, const int *ldx21, double *X22, const int *ldx22, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dorcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x30, long x31, long x32, long x33, long x34, long x35) {
        var mh$ = dorcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorcsd_$descriptor() {
        return sorcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sorcsd_$handle() {
        return sorcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sorcsd_$address() {
        return sorcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X12, const int *ldx12, float *X21, const int *ldx21, float *X22, const int *ldx22, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sorcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x30, long x31, long x32, long x33, long x34, long x35) {
        var mh$ = sorcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, iwork, info, x30, x31, x32, x33, x34, x35);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorcsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorcsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dorcsd2by1_$descriptor() {
        return dorcsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dorcsd2by1_$handle() {
        return dorcsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dorcsd2by1_$address() {
        return dorcsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, double *X11, const int *ldx11, double *X21, const int *ldx21, double *theta, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dorcsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dorcsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorcsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorcsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorcsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sorcsd2by1_$descriptor() {
        return sorcsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sorcsd2by1_$handle() {
        return sorcsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sorcsd2by1_$address() {
        return sorcsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorcsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, float *X11, const int *ldx11, float *X21, const int *ldx21, float *theta, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sorcsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sorcsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorcsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dorgbr_$descriptor() {
        return dorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dorgbr_$handle() {
        return dorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dorgbr_$address() {
        return dorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgbr_(const char *vect, const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dorgbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = dorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sorgbr_$descriptor() {
        return sorgbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sorgbr_$handle() {
        return sorgbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sorgbr_$address() {
        return sorgbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgbr_(const char *vect, const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sorgbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = sorgbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorghr_$descriptor() {
        return dorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorghr_$handle() {
        return dorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorghr_$address() {
        return dorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorghr_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorghr_$descriptor() {
        return sorghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorghr_$handle() {
        return sorghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorghr_$address() {
        return sorghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorghr_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorglq_$descriptor() {
        return dorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorglq_$handle() {
        return dorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorglq_$address() {
        return dorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorglq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorglq_$descriptor() {
        return sorglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorglq_$handle() {
        return sorglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorglq_$address() {
        return sorglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorglq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgql_$descriptor() {
        return dorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgql_$handle() {
        return dorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgql_$address() {
        return dorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgql_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgql_$descriptor() {
        return sorgql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgql_$handle() {
        return sorgql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgql_$address() {
        return sorgql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgql_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgqr_$descriptor() {
        return dorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgqr_$handle() {
        return dorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgqr_$address() {
        return dorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgqr_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgqr_$descriptor() {
        return sorgqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgqr_$handle() {
        return sorgqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgqr_$address() {
        return sorgqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgqr_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgrq_$descriptor() {
        return dorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgrq_$handle() {
        return dorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgrq_$address() {
        return dorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgrq_(const int *m, const int *n, const int *k, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgrq_$descriptor() {
        return sorgrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgrq_$handle() {
        return sorgrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgrq_$address() {
        return sorgrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgrq_(const int *m, const int *n, const int *k, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dorgtr_$descriptor() {
        return dorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dorgtr_$handle() {
        return dorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dorgtr_$address() {
        return dorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgtr_(const char *uplo, const int *n, double *A, const int *lda, const double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dorgtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sorgtr_$descriptor() {
        return sorgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sorgtr_$handle() {
        return sorgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sorgtr_$address() {
        return sorgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgtr_(const char *uplo, const int *n, float *A, const int *lda, const float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sorgtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = sorgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dorgtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dorgtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dorgtsqr_row_$descriptor() {
        return dorgtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dorgtsqr_row_$handle() {
        return dorgtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dorgtsqr_row_$address() {
        return dorgtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, double *A, const int *lda, const double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static void dorgtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dorgtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dorgtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sorgtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sorgtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sorgtsqr_row_$descriptor() {
        return sorgtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sorgtsqr_row_$handle() {
        return sorgtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sorgtsqr_row_$address() {
        return sorgtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sorgtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, float *A, const int *lda, const float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static void sorgtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sorgtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sorgtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormbr_$descriptor() {
        return dormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dormbr_$handle() {
        return dormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dormbr_$address() {
        return dormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dormbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = dormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormbr_$descriptor() {
        return sormbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sormbr_$handle() {
        return sormbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sormbr_$address() {
        return sormbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sormbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = sormbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormhr_$descriptor() {
        return dormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormhr_$handle() {
        return dormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormhr_$address() {
        return dormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormhr_$descriptor() {
        return sormhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormhr_$handle() {
        return sormhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormhr_$address() {
        return sormhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sormhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormlq_$descriptor() {
        return dormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormlq_$handle() {
        return dormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormlq_$address() {
        return dormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormlq_$descriptor() {
        return sormlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormlq_$handle() {
        return sormlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormlq_$address() {
        return sormlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormql_$descriptor() {
        return dormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormql_$handle() {
        return dormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormql_$address() {
        return dormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormql_$descriptor() {
        return sormql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormql_$handle() {
        return sormql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormql_$address() {
        return sormql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormqr_$descriptor() {
        return dormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormqr_$handle() {
        return dormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormqr_$address() {
        return dormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormqr_$descriptor() {
        return sormqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormqr_$handle() {
        return sormqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormqr_$address() {
        return sormqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormrq_$descriptor() {
        return dormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormrq_$handle() {
        return dormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormrq_$address() {
        return dormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormrq_$descriptor() {
        return sormrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormrq_$handle() {
        return sormrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormrq_$address() {
        return sormrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = sormrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormrz_$descriptor() {
        return dormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dormrz_$handle() {
        return dormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dormrz_$address() {
        return dormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dormrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormrz_$descriptor() {
        return sormrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sormrz_$handle() {
        return sormrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sormrz_$address() {
        return sormrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sormrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sormrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dormtr_$descriptor() {
        return dormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dormtr_$handle() {
        return dormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dormtr_$address() {
        return dormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const double *A, const int *lda, const double *tau, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dormtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = dormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dormtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sormtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sormtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sormtr_$descriptor() {
        return sormtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sormtr_$handle() {
        return sormtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sormtr_$address() {
        return sormtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sormtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const float *A, const int *lda, const float *tau, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sormtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = sormtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sormtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbcon_$descriptor() {
        return cpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpbcon_$handle() {
        return cpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpbcon_$address() {
        return cpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbcon_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10) {
        var mh$ = cpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbcon_$descriptor() {
        return dpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpbcon_$handle() {
        return dpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpbcon_$address() {
        return dpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbcon_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = dpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbcon_$descriptor() {
        return spbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spbcon_$handle() {
        return spbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spbcon_$address() {
        return spbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbcon_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = spbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbcon_$descriptor() {
        return zpbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpbcon_$handle() {
        return zpbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpbcon_$address() {
        return zpbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbcon_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpbcon_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10) {
        var mh$ = zpbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbcon_", uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, anorm, rcond, work, rwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbequ_$descriptor() {
        return cpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle cpbequ_$handle() {
        return cpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment cpbequ_$address() {
        return cpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbequ_(const char *uplo, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void cpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = cpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbequ_$descriptor() {
        return dpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle dpbequ_$handle() {
        return dpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment dpbequ_$address() {
        return dpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbequ_(const char *uplo, const int *n, const int *kd, const double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void dpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = dpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbequ_$descriptor() {
        return spbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle spbequ_$handle() {
        return spbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment spbequ_$address() {
        return spbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbequ_(const char *uplo, const int *n, const int *kd, const float *AB, const int *ldab, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void spbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = spbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbequ_$descriptor() {
        return zpbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle zpbequ_$handle() {
        return zpbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment zpbequ_$address() {
        return zpbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbequ_(const char *uplo, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void zpbequ_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x9) {
        var mh$ = zpbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbequ_", uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, S, scond, amax, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbrfs_$descriptor() {
        return cpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpbrfs_$handle() {
        return cpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpbrfs_$address() {
        return cpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbrfs_$descriptor() {
        return dpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpbrfs_$handle() {
        return dpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpbrfs_$address() {
        return dpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbrfs_$descriptor() {
        return spbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spbrfs_$handle() {
        return spbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spbrfs_$address() {
        return spbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = spbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbrfs_$descriptor() {
        return zpbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpbrfs_$handle() {
        return zpbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpbrfs_$address() {
        return zpbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbrfs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpbrfs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zpbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbrfs_", uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbstf_$descriptor() {
        return cpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle cpbstf_$handle() {
        return cpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment cpbstf_$address() {
        return cpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbstf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void cpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = cpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbstf_$descriptor() {
        return dpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle dpbstf_$handle() {
        return dpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment dpbstf_$address() {
        return dpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbstf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void dpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = dpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbstf_$descriptor() {
        return spbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle spbstf_$handle() {
        return spbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment spbstf_$address() {
        return spbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbstf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void spbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = spbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbstf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbstf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbstf_$descriptor() {
        return zpbstf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle zpbstf_$handle() {
        return zpbstf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment zpbstf_$address() {
        return zpbstf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbstf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void zpbstf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = zpbstf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbstf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbsv_$descriptor() {
        return cpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpbsv_$handle() {
        return cpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpbsv_$address() {
        return cpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbsv_$descriptor() {
        return dpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpbsv_$handle() {
        return dpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpbsv_$address() {
        return dpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbsv_$descriptor() {
        return spbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spbsv_$handle() {
        return spbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spbsv_$address() {
        return spbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = spbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbsv_$descriptor() {
        return zpbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpbsv_$handle() {
        return zpbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpbsv_$address() {
        return zpbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbsv_(const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpbsv_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zpbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsv_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpbsvx_$descriptor() {
        return cpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cpbsvx_$handle() {
        return cpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cpbsvx_$address() {
        return cpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpbsvx_$descriptor() {
        return dpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dpbsvx_$handle() {
        return dpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dpbsvx_$address() {
        return dpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spbsvx_$descriptor() {
        return spbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle spbsvx_$handle() {
        return spbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment spbsvx_$address() {
        return spbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void spbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = spbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpbsvx_$descriptor() {
        return zpbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zpbsvx_$handle() {
        return zpbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zpbsvx_$address() {
        return zpbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbsvx_(const char *fact, const char *uplo, const int *n, const int *kd, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zpbsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zpbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbsvx_", fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
            }
            mh$.invokeExact(fact, uplo, n, kd, nrhs, AB, ldab, AFB, ldafb, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbtrf_$descriptor() {
        return cpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle cpbtrf_$handle() {
        return cpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment cpbtrf_$address() {
        return cpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbtrf_(const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void cpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = cpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbtrf_$descriptor() {
        return dpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle dpbtrf_$handle() {
        return dpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment dpbtrf_$address() {
        return dpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbtrf_(const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void dpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = dpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbtrf_$descriptor() {
        return spbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle spbtrf_$handle() {
        return spbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment spbtrf_$address() {
        return spbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbtrf_(const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void spbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = spbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbtrf_$descriptor() {
        return zpbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MethodHandle zpbtrf_$handle() {
        return zpbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static MemorySegment zpbtrf_$address() {
        return zpbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbtrf_(const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, int *info, size_t)
     * }
     */
    public static void zpbtrf_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment info, long x6) {
        var mh$ = zpbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrf_", uplo, n, kd, AB, ldab, info, x6);
            }
            mh$.invokeExact(uplo, n, kd, AB, ldab, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpbtrs_$descriptor() {
        return cpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpbtrs_$handle() {
        return cpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpbtrs_$address() {
        return cpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpbtrs_$descriptor() {
        return dpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpbtrs_$handle() {
        return dpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpbtrs_$address() {
        return dpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spbtrs_$descriptor() {
        return spbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spbtrs_$handle() {
        return spbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spbtrs_$address() {
        return spbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = spbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpbtrs_$descriptor() {
        return zpbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpbtrs_$handle() {
        return zpbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpbtrs_$address() {
        return zpbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpbtrs_(const char *uplo, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpbtrs_(MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zpbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpbtrs_", uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, kd, nrhs, AB, ldab, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftrf_$descriptor() {
        return cpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftrf_$handle() {
        return cpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftrf_$address() {
        return cpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftrf_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static void cpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = cpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftrf_$descriptor() {
        return dpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftrf_$handle() {
        return dpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftrf_$address() {
        return dpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftrf_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static void dpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = dpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftrf_$descriptor() {
        return spftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftrf_$handle() {
        return spftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftrf_$address() {
        return spftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftrf_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static void spftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = spftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpftrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftrf_$descriptor() {
        return zpftrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftrf_$handle() {
        return zpftrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftrf_$address() {
        return zpftrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftrf_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static void zpftrf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = zpftrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrf_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftri_$descriptor() {
        return cpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftri_$handle() {
        return cpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftri_$address() {
        return cpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftri_(const char *transr, const char *uplo, const int *n, _Complex float *A, int *info, size_t, size_t)
     * }
     */
    public static void cpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = cpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftri_$descriptor() {
        return dpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftri_$handle() {
        return dpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftri_$address() {
        return dpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftri_(const char *transr, const char *uplo, const int *n, double *A, int *info, size_t, size_t)
     * }
     */
    public static void dpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = dpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftri_$descriptor() {
        return spftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftri_$handle() {
        return spftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftri_$address() {
        return spftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftri_(const char *transr, const char *uplo, const int *n, float *A, int *info, size_t, size_t)
     * }
     */
    public static void spftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = spftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftri_$descriptor() {
        return zpftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftri_$handle() {
        return zpftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftri_$address() {
        return zpftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftri_(const char *transr, const char *uplo, const int *n, _Complex double *A, int *info, size_t, size_t)
     * }
     */
    public static void zpftri_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment info, long x5, long x6) {
        var mh$ = zpftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftri_", transr, uplo, n, A, info, x5, x6);
            }
            mh$.invokeExact(transr, uplo, n, A, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cpftrs_$descriptor() {
        return cpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cpftrs_$handle() {
        return cpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cpftrs_$address() {
        return cpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, _Complex float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void cpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = cpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dpftrs_$descriptor() {
        return dpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dpftrs_$handle() {
        return dpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dpftrs_$address() {
        return dpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const double *A, double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void dpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = dpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor spftrs_$descriptor() {
        return spftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle spftrs_$handle() {
        return spftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment spftrs_$address() {
        return spftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const float *A, float *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void spftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = spftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpftrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpftrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zpftrs_$descriptor() {
        return zpftrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zpftrs_$handle() {
        return zpftrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zpftrs_$address() {
        return zpftrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpftrs_(const char *transr, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, _Complex double *B, const int *ldb, int *info, size_t, size_t)
     * }
     */
    public static void zpftrs_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8, long x9) {
        var mh$ = zpftrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpftrs_", transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
            }
            mh$.invokeExact(transr, uplo, n, nrhs, A, B, ldb, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpocon_$descriptor() {
        return cpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpocon_$handle() {
        return cpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpocon_$address() {
        return cpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpocon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = cpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpocon_", uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpocon_$descriptor() {
        return dpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpocon_$handle() {
        return dpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpocon_$address() {
        return dpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpocon_(const char *uplo, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpocon_", uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spocon_$descriptor() {
        return spocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spocon_$handle() {
        return spocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spocon_$address() {
        return spocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spocon_(const char *uplo, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = spocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spocon_", uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpocon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpocon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpocon_$descriptor() {
        return zpocon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpocon_$handle() {
        return zpocon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpocon_$address() {
        return zpocon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpocon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpocon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = zpocon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpocon_", uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cpoequ_$descriptor() {
        return cpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle cpoequ_$handle() {
        return cpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment cpoequ_$address() {
        return cpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpoequ_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void cpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = cpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dpoequ_$descriptor() {
        return dpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle dpoequ_$handle() {
        return dpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment dpoequ_$address() {
        return dpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpoequ_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void dpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = dpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor spoequ_$descriptor() {
        return spoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle spoequ_$handle() {
        return spoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment spoequ_$address() {
        return spoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spoequ_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void spoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = spoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpoequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zpoequ_$descriptor() {
        return zpoequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle zpoequ_$handle() {
        return zpoequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment zpoequ_$address() {
        return zpoequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpoequ_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void zpoequ_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = zpoequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequ_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cpoequb_$descriptor() {
        return cpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle cpoequb_$handle() {
        return cpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment cpoequb_$address() {
        return cpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpoequb_(const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void cpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = cpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dpoequb_$descriptor() {
        return dpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle dpoequb_$handle() {
        return dpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment dpoequb_$address() {
        return dpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpoequb_(const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void dpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = dpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor spoequb_$descriptor() {
        return spoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MethodHandle spoequb_$handle() {
        return spoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static MemorySegment spoequb_$address() {
        return spoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spoequb_(const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, int *info)
     * }
     */
    public static void spoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = spoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpoequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpoequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zpoequb_$descriptor() {
        return zpoequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MethodHandle zpoequb_$handle() {
        return zpoequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static MemorySegment zpoequb_$address() {
        return zpoequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpoequb_(const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, int *info)
     * }
     */
    public static void zpoequb_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info) {
        var mh$ = zpoequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpoequb_", n, A, lda, S, scond, amax, info);
            }
            mh$.invokeExact(n, A, lda, S, scond, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cporfs_$descriptor() {
        return cporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cporfs_$handle() {
        return cporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cporfs_$address() {
        return cporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = cporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dporfs_$descriptor() {
        return dporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dporfs_$handle() {
        return dporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dporfs_$address() {
        return dporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dporfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16) {
        var mh$ = dporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sporfs_$descriptor() {
        return sporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sporfs_$handle() {
        return sporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sporfs_$address() {
        return sporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sporfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16) {
        var mh$ = sporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zporfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zporfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zporfs_$descriptor() {
        return zporfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zporfs_$handle() {
        return zporfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zporfs_$address() {
        return zporfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zporfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zporfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = zporfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zporfs_", uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cporfsx_$descriptor() {
        return cporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cporfsx_$handle() {
        return cporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cporfsx_$address() {
        return cporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x23, long x24) {
        var mh$ = cporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dporfsx_$descriptor() {
        return dporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dporfsx_$handle() {
        return dporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dporfsx_$address() {
        return dporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24) {
        var mh$ = dporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sporfsx_$descriptor() {
        return sporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sporfsx_$handle() {
        return sporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sporfsx_$address() {
        return sporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24) {
        var mh$ = sporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zporfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zporfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zporfsx_$descriptor() {
        return zporfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zporfsx_$handle() {
        return zporfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zporfsx_$address() {
        return zporfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zporfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zporfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x23, long x24) {
        var mh$ = zporfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zporfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cposv_$descriptor() {
        return cposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cposv_$handle() {
        return cposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cposv_$address() {
        return cposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dposv_$descriptor() {
        return dposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dposv_$handle() {
        return dposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dposv_$address() {
        return dposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sposv_$descriptor() {
        return sposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sposv_$handle() {
        return sposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sposv_$address() {
        return sposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = sposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zposv_$descriptor() {
        return zposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zposv_$handle() {
        return zposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zposv_$address() {
        return zposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposv_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsposv_$descriptor() {
        return dsposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static MethodHandle dsposv_$handle() {
        return dsposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static MemorySegment dsposv_$address() {
        return dsposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsposv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info, size_t)
     * }
     */
    public static void dsposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment iter, MemorySegment info, long x13) {
        var mh$ = dsposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsposv_", uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, iter, info, x13);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, iter, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcposv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zcposv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zcposv_$descriptor() {
        return zcposv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static MethodHandle zcposv_$handle() {
        return zcposv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static MemorySegment zcposv_$address() {
        return zcposv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zcposv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info, size_t)
     * }
     */
    public static void zcposv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter, MemorySegment info, long x14) {
        var mh$ = zcposv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcposv_", uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, rwork, iter, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, X, ldx, work, swork, rwork, iter, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cposvx_$descriptor() {
        return cposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cposvx_$handle() {
        return cposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cposvx_$address() {
        return cposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = cposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dposvx_$descriptor() {
        return dposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dposvx_$handle() {
        return dposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dposvx_$address() {
        return dposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sposvx_$descriptor() {
        return sposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sposvx_$handle() {
        return sposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sposvx_$address() {
        return sposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zposvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zposvx_$descriptor() {
        return zposvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zposvx_$handle() {
        return zposvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zposvx_$address() {
        return zposvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zposvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = zposvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cposvxx_$descriptor() {
        return cposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cposvxx_$handle() {
        return cposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cposvxx_$address() {
        return cposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dposvxx_$descriptor() {
        return dposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dposvxx_$handle() {
        return dposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dposvxx_$address() {
        return dposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sposvxx_$descriptor() {
        return sposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sposvxx_$handle() {
        return sposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sposvxx_$address() {
        return sposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = sposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zposvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zposvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zposvxx_$descriptor() {
        return zposvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zposvxx_$handle() {
        return zposvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zposvxx_$address() {
        return zposvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zposvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zposvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zposvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zposvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotf2_$descriptor() {
        return cpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotf2_$handle() {
        return cpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotf2_$address() {
        return cpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotf2_$descriptor() {
        return dpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotf2_$handle() {
        return dpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotf2_$address() {
        return dpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotf2_$descriptor() {
        return spotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotf2_$handle() {
        return spotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotf2_$address() {
        return spotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpotf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotf2_$descriptor() {
        return zpotf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotf2_$handle() {
        return zpotf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotf2_$address() {
        return zpotf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrf_$descriptor() {
        return cpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrf_$handle() {
        return cpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrf_$address() {
        return cpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrf_$descriptor() {
        return dpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrf_$handle() {
        return dpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrf_$address() {
        return dpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrf_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrf_$descriptor() {
        return spotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotrf_$handle() {
        return spotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotrf_$address() {
        return spotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrf_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpotrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrf_$descriptor() {
        return zpotrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrf_$handle() {
        return zpotrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrf_$address() {
        return zpotrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrf2_$descriptor() {
        return cpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrf2_$handle() {
        return cpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrf2_$address() {
        return cpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrf2_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrf2_$descriptor() {
        return dpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrf2_$handle() {
        return dpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrf2_$address() {
        return dpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrf2_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrf2_$descriptor() {
        return spotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotrf2_$handle() {
        return spotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotrf2_$address() {
        return spotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrf2_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpotrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrf2_$descriptor() {
        return zpotrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrf2_$handle() {
        return zpotrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrf2_$address() {
        return zpotrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrf2_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotrf2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrf2_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotri_$descriptor() {
        return cpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle cpotri_$handle() {
        return cpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment cpotri_$address() {
        return cpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotri_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void cpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = cpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotri_$descriptor() {
        return dpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dpotri_$handle() {
        return dpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dpotri_$address() {
        return dpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotri_(const char *uplo, const int *n, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = dpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotri_$descriptor() {
        return spotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle spotri_$handle() {
        return spotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment spotri_$address() {
        return spotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotri_(const char *uplo, const int *n, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void spotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = spotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpotri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotri_$descriptor() {
        return zpotri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle zpotri_$handle() {
        return zpotri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment zpotri_$address() {
        return zpotri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotri_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void zpotri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x5) {
        var mh$ = zpotri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotri_", uplo, n, A, lda, info, x5);
            }
            mh$.invokeExact(uplo, n, A, lda, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpotrs_$descriptor() {
        return cpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpotrs_$handle() {
        return cpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpotrs_$address() {
        return cpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpotrs_$descriptor() {
        return dpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpotrs_$handle() {
        return dpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpotrs_$address() {
        return dpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpotrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spotrs_$descriptor() {
        return spotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spotrs_$handle() {
        return spotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spotrs_$address() {
        return spotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spotrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = spotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpotrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpotrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpotrs_$descriptor() {
        return zpotrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpotrs_$handle() {
        return zpotrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpotrs_$address() {
        return zpotrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpotrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpotrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zpotrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpotrs_", uplo, n, nrhs, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppcon_$descriptor() {
        return cppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cppcon_$handle() {
        return cppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cppcon_$address() {
        return cppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppcon_(const char *uplo, const int *n, const _Complex float *AP, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x8) {
        var mh$ = cppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppcon_", uplo, n, AP, anorm, rcond, work, rwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, rwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppcon_$descriptor() {
        return dppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dppcon_$handle() {
        return dppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dppcon_$address() {
        return dppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppcon_(const char *uplo, const int *n, const double *AP, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x8) {
        var mh$ = dppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppcon_", uplo, n, AP, anorm, rcond, work, iwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, iwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppcon_$descriptor() {
        return sppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sppcon_$handle() {
        return sppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sppcon_$address() {
        return sppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppcon_(const char *uplo, const int *n, const float *AP, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x8) {
        var mh$ = sppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppcon_", uplo, n, AP, anorm, rcond, work, iwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, iwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zppcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppcon_$descriptor() {
        return zppcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zppcon_$handle() {
        return zppcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zppcon_$address() {
        return zppcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppcon_(const char *uplo, const int *n, const _Complex double *AP, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zppcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x8) {
        var mh$ = zppcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppcon_", uplo, n, AP, anorm, rcond, work, rwork, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, anorm, rcond, work, rwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppequ_$descriptor() {
        return cppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle cppequ_$handle() {
        return cppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment cppequ_$address() {
        return cppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppequ_(const char *uplo, const int *n, const _Complex float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void cppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = cppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppequ_$descriptor() {
        return dppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle dppequ_$handle() {
        return dppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment dppequ_$address() {
        return dppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppequ_(const char *uplo, const int *n, const double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void dppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = dppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppequ_$descriptor() {
        return sppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MethodHandle sppequ_$handle() {
        return sppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static MemorySegment sppequ_$address() {
        return sppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppequ_(const char *uplo, const int *n, const float *AP, float *S, float *scond, float *amax, int *info, size_t)
     * }
     */
    public static void sppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = sppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zppequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppequ_$descriptor() {
        return zppequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MethodHandle zppequ_$handle() {
        return zppequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static MemorySegment zppequ_$address() {
        return zppequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppequ_(const char *uplo, const int *n, const _Complex double *AP, double *S, double *scond, double *amax, int *info, size_t)
     * }
     */
    public static void zppequ_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment info, long x7) {
        var mh$ = zppequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppequ_", uplo, n, AP, S, scond, amax, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, S, scond, amax, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpprfs_$descriptor() {
        return cpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cpprfs_$handle() {
        return cpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cpprfs_$address() {
        return cpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14) {
        var mh$ = cpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpprfs_$descriptor() {
        return dpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dpprfs_$handle() {
        return dpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dpprfs_$address() {
        return dpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = dpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spprfs_$descriptor() {
        return spprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle spprfs_$handle() {
        return spprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment spprfs_$address() {
        return spprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void spprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = spprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpprfs_$descriptor() {
        return zpprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zpprfs_$handle() {
        return zpprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zpprfs_$address() {
        return zpprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zpprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14) {
        var mh$ = zpprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpprfs_", uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cppsv_$descriptor() {
        return cppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cppsv_$handle() {
        return cppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cppsv_$address() {
        return cppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = cppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dppsv_$descriptor() {
        return dppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dppsv_$handle() {
        return dppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dppsv_$address() {
        return dppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppsv_(const char *uplo, const int *n, const int *nrhs, double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = dppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sppsv_$descriptor() {
        return sppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sppsv_$handle() {
        return sppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sppsv_$address() {
        return sppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppsv_(const char *uplo, const int *n, const int *nrhs, float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = sppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zppsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zppsv_$descriptor() {
        return zppsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zppsv_$handle() {
        return zppsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zppsv_$address() {
        return zppsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zppsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = zppsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsv_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cppsvx_$descriptor() {
        return cppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cppsvx_$handle() {
        return cppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cppsvx_$address() {
        return cppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *AP, _Complex float *AFP, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = cppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dppsvx_$descriptor() {
        return dppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dppsvx_$handle() {
        return dppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dppsvx_$address() {
        return dppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *AP, double *AFP, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = dppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sppsvx_$descriptor() {
        return sppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sppsvx_$handle() {
        return sppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sppsvx_$address() {
        return sppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *AP, float *AFP, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = sppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zppsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zppsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zppsvx_$descriptor() {
        return zppsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zppsvx_$handle() {
        return zppsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zppsvx_$address() {
        return zppsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zppsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *AP, _Complex double *AFP, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zppsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = zppsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zppsvx_", fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, equed, S, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptrf_$descriptor() {
        return cpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle cpptrf_$handle() {
        return cpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment cpptrf_$address() {
        return cpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptrf_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void cpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = cpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptrf_$descriptor() {
        return dpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dpptrf_$handle() {
        return dpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dpptrf_$address() {
        return dpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptrf_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static void dpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = dpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptrf_$descriptor() {
        return spptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle spptrf_$handle() {
        return spptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment spptrf_$address() {
        return spptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptrf_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static void spptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = spptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptrf_$descriptor() {
        return zpptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle zpptrf_$handle() {
        return zpptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment zpptrf_$address() {
        return zpptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptrf_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void zpptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = zpptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrf_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptri_$descriptor() {
        return cpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle cpptri_$handle() {
        return cpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment cpptri_$address() {
        return cpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptri_(const char *uplo, const int *n, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void cpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = cpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptri_$descriptor() {
        return dpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dpptri_$handle() {
        return dpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dpptri_$address() {
        return dpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptri_(const char *uplo, const int *n, double *AP, int *info, size_t)
     * }
     */
    public static void dpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = dpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptri_$descriptor() {
        return spptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle spptri_$handle() {
        return spptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment spptri_$address() {
        return spptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptri_(const char *uplo, const int *n, float *AP, int *info, size_t)
     * }
     */
    public static void spptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = spptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptri_$descriptor() {
        return zpptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle zpptri_$handle() {
        return zpptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment zpptri_$address() {
        return zpptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptri_(const char *uplo, const int *n, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void zpptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment info, long x4) {
        var mh$ = zpptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptri_", uplo, n, AP, info, x4);
            }
            mh$.invokeExact(uplo, n, AP, info, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpptrs_$descriptor() {
        return cpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpptrs_$handle() {
        return cpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpptrs_$address() {
        return cpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = cpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpptrs_$descriptor() {
        return dpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dpptrs_$handle() {
        return dpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dpptrs_$address() {
        return dpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = dpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spptrs_$descriptor() {
        return spptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle spptrs_$handle() {
        return spptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment spptrs_$address() {
        return spptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void spptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = spptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpptrs_$descriptor() {
        return zpptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpptrs_$handle() {
        return zpptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpptrs_$address() {
        return zpptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x7) {
        var mh$ = zpptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpptrs_", uplo, n, nrhs, AP, B, ldb, info, x7);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, B, ldb, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpstrf_$descriptor() {
        return cpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cpstrf_$handle() {
        return cpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cpstrf_$address() {
        return cpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpstrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static void cpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = cpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpstrf_$descriptor() {
        return dpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dpstrf_$handle() {
        return dpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dpstrf_$address() {
        return dpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpstrf_(const char *uplo, const int *n, double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static void dpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = dpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spstrf_$descriptor() {
        return spstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle spstrf_$handle() {
        return spstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment spstrf_$address() {
        return spstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spstrf_(const char *uplo, const int *n, float *A, const int *lda, int *piv, int *rank, const float *tol, float *work, int *info, size_t)
     * }
     */
    public static void spstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = spstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpstrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpstrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpstrf_$descriptor() {
        return zpstrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zpstrf_$handle() {
        return zpstrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zpstrf_$address() {
        return zpstrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpstrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *piv, int *rank, const double *tol, double *work, int *info, size_t)
     * }
     */
    public static void zpstrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment piv, MemorySegment rank, MemorySegment tol, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zpstrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpstrf_", uplo, n, A, lda, piv, rank, tol, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, piv, rank, tol, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cptcon_$descriptor() {
        return cptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static MethodHandle cptcon_$handle() {
        return cptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static MemorySegment cptcon_$address() {
        return cptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptcon_(const int *n, const float *D, const _Complex float *E, const float *anorm, float *rcond, float *rwork, int *info)
     * }
     */
    public static void cptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment rwork, MemorySegment info) {
        var mh$ = cptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptcon_", n, D, E, anorm, rcond, rwork, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dptcon_$descriptor() {
        return dptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static MethodHandle dptcon_$handle() {
        return dptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static MemorySegment dptcon_$address() {
        return dptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptcon_(const int *n, const double *D, const double *E, const double *anorm, double *rcond, double *work, int *info)
     * }
     */
    public static void dptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info) {
        var mh$ = dptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptcon_", n, D, E, anorm, rcond, work, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sptcon_$descriptor() {
        return sptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static MethodHandle sptcon_$handle() {
        return sptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static MemorySegment sptcon_$address() {
        return sptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptcon_(const int *n, const float *D, const float *E, const float *anorm, float *rcond, float *work, int *info)
     * }
     */
    public static void sptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info) {
        var mh$ = sptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptcon_", n, D, E, anorm, rcond, work, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zptcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zptcon_$descriptor() {
        return zptcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static MethodHandle zptcon_$handle() {
        return zptcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static MemorySegment zptcon_$address() {
        return zptcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptcon_(const int *n, const double *D, const _Complex double *E, const double *anorm, double *rcond, double *rwork, int *info)
     * }
     */
    public static void zptcon_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment anorm, MemorySegment rcond, MemorySegment rwork, MemorySegment info) {
        var mh$ = zptcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptcon_", n, D, E, anorm, rcond, rwork, info);
            }
            mh$.invokeExact(n, D, E, anorm, rcond, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpteqr_$descriptor() {
        return cpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cpteqr_$handle() {
        return cpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cpteqr_$address() {
        return cpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void cpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dpteqr_$descriptor() {
        return dpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dpteqr_$handle() {
        return dpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dpteqr_$address() {
        return dpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor spteqr_$descriptor() {
        return spteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle spteqr_$handle() {
        return spteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment spteqr_$address() {
        return spteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void spteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = spteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpteqr_$descriptor() {
        return zpteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zpteqr_$handle() {
        return zpteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zpteqr_$address() {
        return zpteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void zpteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zpteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cptrfs_$descriptor() {
        return cptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cptrfs_$handle() {
        return cptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cptrfs_$address() {
        return cptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptrfs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, const float *DF, const _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cptrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = cptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptrfs_", uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dptrfs_$descriptor() {
        return dptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static MethodHandle dptrfs_$handle() {
        return dptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static MemorySegment dptrfs_$address() {
        return dptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptrfs_(const int *n, const int *nrhs, const double *D, const double *E, const double *DF, const double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *info)
     * }
     */
    public static void dptrfs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info) {
        var mh$ = dptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptrfs_", n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
            }
            mh$.invokeExact(n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sptrfs_$descriptor() {
        return sptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static MethodHandle sptrfs_$handle() {
        return sptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static MemorySegment sptrfs_$address() {
        return sptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptrfs_(const int *n, const int *nrhs, const float *D, const float *E, const float *DF, const float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *info)
     * }
     */
    public static void sptrfs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info) {
        var mh$ = sptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptrfs_", n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
            }
            mh$.invokeExact(n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zptrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zptrfs_$descriptor() {
        return zptrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zptrfs_$handle() {
        return zptrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zptrfs_$address() {
        return zptrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptrfs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, const double *DF, const _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zptrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16) {
        var mh$ = zptrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptrfs_", uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cptsv_$descriptor() {
        return cptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cptsv_$handle() {
        return cptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cptsv_$address() {
        return cptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptsv_(const int *n, const int *nrhs, float *D, _Complex float *E, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dptsv_$descriptor() {
        return dptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dptsv_$handle() {
        return dptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dptsv_$address() {
        return dptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptsv_(const int *n, const int *nrhs, double *D, double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static void dptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sptsv_$descriptor() {
        return sptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sptsv_$handle() {
        return sptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sptsv_$address() {
        return sptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptsv_(const int *n, const int *nrhs, float *D, float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static void sptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zptsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zptsv_$descriptor() {
        return zptsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zptsv_$handle() {
        return zptsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zptsv_$address() {
        return zptsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptsv_(const int *n, const int *nrhs, double *D, _Complex double *E, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zptsv_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zptsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsv_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cptsvx_$descriptor() {
        return cptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cptsvx_$handle() {
        return cptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cptsvx_$address() {
        return cptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const _Complex float *E, float *DF, _Complex float *EF, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dptsvx_$descriptor() {
        return dptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dptsvx_$handle() {
        return dptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dptsvx_$address() {
        return dptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const double *E, double *DF, double *EF, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *info, size_t)
     * }
     */
    public static void dptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info, long x16) {
        var mh$ = dptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sptsvx_$descriptor() {
        return sptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sptsvx_$handle() {
        return sptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sptsvx_$address() {
        return sptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sptsvx_(const char *fact, const int *n, const int *nrhs, const float *D, const float *E, float *DF, float *EF, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *info, size_t)
     * }
     */
    public static void sptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment info, long x16) {
        var mh$ = sptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, info, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zptsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zptsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zptsvx_$descriptor() {
        return zptsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zptsvx_$handle() {
        return zptsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zptsvx_$address() {
        return zptsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zptsvx_(const char *fact, const int *n, const int *nrhs, const double *D, const _Complex double *E, double *DF, _Complex double *EF, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zptsvx_(MemorySegment fact, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment DF, MemorySegment EF, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zptsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zptsvx_", fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(fact, n, nrhs, D, E, DF, EF, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static FunctionDescriptor cpttrf_$descriptor() {
        return cpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static MethodHandle cpttrf_$handle() {
        return cpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static MemorySegment cpttrf_$address() {
        return cpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpttrf_(const int *n, float *D, _Complex float *E, int *info)
     * }
     */
    public static void cpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = cpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static FunctionDescriptor dpttrf_$descriptor() {
        return dpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MethodHandle dpttrf_$handle() {
        return dpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MemorySegment dpttrf_$address() {
        return dpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpttrf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static void dpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = dpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static FunctionDescriptor spttrf_$descriptor() {
        return spttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MethodHandle spttrf_$handle() {
        return spttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MemorySegment spttrf_$address() {
        return spttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spttrf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static void spttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = spttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static FunctionDescriptor zpttrf_$descriptor() {
        return zpttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static MethodHandle zpttrf_$handle() {
        return zpttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static MemorySegment zpttrf_$address() {
        return zpttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpttrf_(const int *n, double *D, _Complex double *E, int *info)
     * }
     */
    public static void zpttrf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = zpttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cpttrs_$descriptor() {
        return cpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cpttrs_$handle() {
        return cpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cpttrs_$address() {
        return cpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cpttrs_(const char *uplo, const int *n, const int *nrhs, const float *D, const _Complex float *E, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cpttrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpttrs_", uplo, n, nrhs, D, E, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dpttrs_$descriptor() {
        return dpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dpttrs_$handle() {
        return dpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dpttrs_$address() {
        return dpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dpttrs_(const int *n, const int *nrhs, const double *D, const double *E, double *B, const int *ldb, int *info)
     * }
     */
    public static void dpttrs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dpttrs_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class spttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("spttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor spttrs_$descriptor() {
        return spttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle spttrs_$handle() {
        return spttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment spttrs_$address() {
        return spttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void spttrs_(const int *n, const int *nrhs, const float *D, const float *E, float *B, const int *ldb, int *info)
     * }
     */
    public static void spttrs_(MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = spttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("spttrs_", n, nrhs, D, E, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, D, E, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zpttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zpttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zpttrs_$descriptor() {
        return zpttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zpttrs_$handle() {
        return zpttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zpttrs_$address() {
        return zpttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zpttrs_(const char *uplo, const int *n, const int *nrhs, const double *D, const _Complex double *E, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zpttrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment D, MemorySegment E, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zpttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zpttrs_", uplo, n, nrhs, D, E, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, D, E, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbev_$descriptor() {
        return dsbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbev_$handle() {
        return dsbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbev_$address() {
        return dsbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbev_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = dsbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbev_$descriptor() {
        return ssbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbev_$handle() {
        return ssbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbev_$address() {
        return ssbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbev_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = ssbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbev_2stage_$descriptor() {
        return dsbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbev_2stage_$handle() {
        return dsbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbev_2stage_$address() {
        return dsbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbev_2stage_$descriptor() {
        return ssbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbev_2stage_$handle() {
        return ssbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbev_2stage_$address() {
        return ssbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevd_$descriptor() {
        return dsbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevd_$handle() {
        return dsbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevd_$address() {
        return dsbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevd_$descriptor() {
        return ssbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevd_$handle() {
        return ssbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevd_$address() {
        return ssbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevd_2stage_$descriptor() {
        return dsbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevd_2stage_$handle() {
        return dsbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevd_2stage_$address() {
        return dsbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevd_2stage_$descriptor() {
        return ssbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevd_2stage_$handle() {
        return ssbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevd_2stage_$address() {
        return ssbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevx_$descriptor() {
        return dsbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevx_$handle() {
        return dsbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevx_$address() {
        return dsbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = dsbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevx_$descriptor() {
        return ssbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevx_$handle() {
        return ssbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevx_$address() {
        return ssbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = ssbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbevx_2stage_$descriptor() {
        return dsbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbevx_2stage_$handle() {
        return dsbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbevx_2stage_$address() {
        return dsbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dsbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbevx_2stage_$descriptor() {
        return ssbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbevx_2stage_$handle() {
        return ssbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbevx_2stage_$address() {
        return ssbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = ssbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgst_$descriptor() {
        return dsbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgst_$handle() {
        return dsbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgst_$address() {
        return dsbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, const double *BB, const int *ldbb, double *X, const int *ldx, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment info, long x13, long x14) {
        var mh$ = dsbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgst_$descriptor() {
        return ssbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgst_$handle() {
        return ssbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgst_$address() {
        return ssbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, const float *BB, const int *ldbb, float *X, const int *ldx, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment info, long x13, long x14) {
        var mh$ = ssbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgv_$descriptor() {
        return dsbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgv_$handle() {
        return dsbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgv_$address() {
        return dsbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dsbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgv_$descriptor() {
        return ssbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgv_$handle() {
        return ssbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgv_$address() {
        return ssbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = ssbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgvd_$descriptor() {
        return dsbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgvd_$handle() {
        return dsbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgvd_$address() {
        return dsbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x17, long x18) {
        var mh$ = dsbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgvd_$descriptor() {
        return ssbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgvd_$handle() {
        return ssbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgvd_$address() {
        return ssbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x17, long x18) {
        var mh$ = ssbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, iwork, liwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbgvx_$descriptor() {
        return dsbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsbgvx_$handle() {
        return dsbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsbgvx_$address() {
        return dsbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, double *AB, const int *ldab, double *BB, const int *ldbb, double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dsbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbgvx_$descriptor() {
        return ssbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssbgvx_$handle() {
        return ssbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssbgvx_$address() {
        return ssbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, float *AB, const int *ldab, float *BB, const int *ldbb, float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ssbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsbtrd_$descriptor() {
        return dsbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsbtrd_$handle() {
        return dsbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsbtrd_$address() {
        return dsbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dsbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = dsbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssbtrd_$descriptor() {
        return ssbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssbtrd_$handle() {
        return ssbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssbtrd_$address() {
        return ssbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *work, int *info, size_t, size_t)
     * }
     */
    public static void ssbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = ssbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsfrk_$descriptor() {
        return dsfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsfrk_$handle() {
        return dsfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsfrk_$address() {
        return dsfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const double *A, const int *lda, const double *beta, double *C, size_t, size_t, size_t)
     * }
     */
    public static void dsfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = dsfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssfrk_$descriptor() {
        return ssfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssfrk_$handle() {
        return ssfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssfrk_$address() {
        return ssfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const float *A, const int *lda, const float *beta, float *C, size_t, size_t, size_t)
     * }
     */
    public static void ssfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = ssfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cspcon_$descriptor() {
        return cspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cspcon_$handle() {
        return cspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cspcon_$address() {
        return cspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspcon_$descriptor() {
        return dspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dspcon_$handle() {
        return dspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dspcon_$address() {
        return dspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspcon_(const char *uplo, const int *n, const double *AP, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspcon_", uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspcon_$descriptor() {
        return sspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sspcon_$handle() {
        return sspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sspcon_$address() {
        return sspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspcon_(const char *uplo, const int *n, const float *AP, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = sspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspcon_", uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zspcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zspcon_$descriptor() {
        return zspcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zspcon_$handle() {
        return zspcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zspcon_$address() {
        return zspcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zspcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zspcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspev_$descriptor() {
        return dspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspev_$handle() {
        return dspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspev_$address() {
        return dspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspev_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dspev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x9, long x10) {
        var mh$ = dspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspev_", jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspev_$descriptor() {
        return sspev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspev_$handle() {
        return sspev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspev_$address() {
        return sspev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspev_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sspev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x9, long x10) {
        var mh$ = sspev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspev_", jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspevd_$descriptor() {
        return dspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspevd_$handle() {
        return dspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspevd_$address() {
        return dspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspevd_(const char *jobz, const char *uplo, const int *n, double *AP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dspevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x12, long x13) {
        var mh$ = dspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspevd_$descriptor() {
        return sspevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspevd_$handle() {
        return sspevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspevd_$address() {
        return sspevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspevd_(const char *jobz, const char *uplo, const int *n, float *AP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sspevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x12, long x13) {
        var mh$ = sspevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, iwork, liwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspevx_$descriptor() {
        return dspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dspevx_$handle() {
        return dspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dspevx_$address() {
        return dspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dspevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = dspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspevx_$descriptor() {
        return sspevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sspevx_$handle() {
        return sspevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sspevx_$address() {
        return sspevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sspevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = sspevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspgst_$descriptor() {
        return dspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static MethodHandle dspgst_$handle() {
        return dspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static MemorySegment dspgst_$address() {
        return dspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgst_(const int *itype, const char *uplo, const int *n, double *AP, const double *BP, int *info, size_t)
     * }
     */
    public static void dspgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = dspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspgst_$descriptor() {
        return sspgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static MethodHandle sspgst_$handle() {
        return sspgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static MemorySegment sspgst_$address() {
        return sspgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgst_(const int *itype, const char *uplo, const int *n, float *AP, const float *BP, int *info, size_t)
     * }
     */
    public static void sspgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = sspgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgv_$descriptor() {
        return dspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspgv_$handle() {
        return dspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspgv_$address() {
        return dspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dspgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = dspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgv_$descriptor() {
        return sspgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspgv_$handle() {
        return sspgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspgv_$address() {
        return sspgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sspgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x11, long x12) {
        var mh$ = sspgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgvd_$descriptor() {
        return dspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspgvd_$handle() {
        return dspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspgvd_$address() {
        return dspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *AP, double *BP, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dspgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgvd_$descriptor() {
        return sspgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspgvd_$handle() {
        return sspgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspgvd_$address() {
        return sspgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *AP, float *BP, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sspgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = sspgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspgvx_$descriptor() {
        return dspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dspgvx_$handle() {
        return dspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dspgvx_$address() {
        return dspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *AP, double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dspgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspgvx_$descriptor() {
        return sspgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sspgvx_$handle() {
        return sspgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sspgvx_$address() {
        return sspgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *AP, float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sspgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sspgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csprfs_$descriptor() {
        return csprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle csprfs_$handle() {
        return csprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment csprfs_$address() {
        return csprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void csprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = csprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsprfs_$descriptor() {
        return dsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsprfs_$handle() {
        return dsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsprfs_$address() {
        return dsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsprfs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const double *AFP, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = dsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssprfs_$descriptor() {
        return ssprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssprfs_$handle() {
        return ssprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssprfs_$address() {
        return ssprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssprfs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const float *AFP, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = ssprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsprfs_$descriptor() {
        return zsprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsprfs_$handle() {
        return zsprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsprfs_$address() {
        return zsprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zsprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zsprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cspsv_$descriptor() {
        return cspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cspsv_$handle() {
        return cspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cspsv_$address() {
        return cspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = cspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dspsv_$descriptor() {
        return dspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dspsv_$handle() {
        return dspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dspsv_$address() {
        return dspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspsv_(const char *uplo, const int *n, const int *nrhs, double *AP, int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sspsv_$descriptor() {
        return sspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sspsv_$handle() {
        return sspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sspsv_$address() {
        return sspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspsv_(const char *uplo, const int *n, const int *nrhs, float *AP, int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = sspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zspsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zspsv_$descriptor() {
        return zspsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zspsv_$handle() {
        return zspsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zspsv_$address() {
        return zspsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zspsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zspsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cspsvx_$descriptor() {
        return cspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cspsvx_$handle() {
        return cspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cspsvx_$address() {
        return cspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dspsvx_$descriptor() {
        return dspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dspsvx_$handle() {
        return dspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dspsvx_$address() {
        return dspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *AP, double *AFP, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18) {
        var mh$ = dspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sspsvx_$descriptor() {
        return sspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sspsvx_$handle() {
        return sspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sspsvx_$address() {
        return sspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *AP, float *AFP, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18) {
        var mh$ = sspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zspsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zspsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zspsvx_$descriptor() {
        return zspsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zspsvx_$handle() {
        return zspsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zspsvx_$address() {
        return zspsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zspsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zspsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zspsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zspsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrd_$descriptor() {
        return dsptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrd_$handle() {
        return dsptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrd_$address() {
        return dsptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrd_(const char *uplo, const int *n, double *AP, double *D, double *E, double *tau, int *info, size_t)
     * }
     */
    public static void dsptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = dsptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrd_$descriptor() {
        return ssptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrd_$handle() {
        return ssptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrd_$address() {
        return ssptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrd_(const char *uplo, const int *n, float *AP, float *D, float *E, float *tau, int *info, size_t)
     * }
     */
    public static void ssptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = ssptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptrf_$descriptor() {
        return csptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle csptrf_$handle() {
        return csptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment csptrf_$address() {
        return csptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void csptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = csptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrf_$descriptor() {
        return dsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrf_$handle() {
        return dsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrf_$address() {
        return dsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrf_(const char *uplo, const int *n, double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void dsptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = dsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrf_$descriptor() {
        return ssptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrf_$handle() {
        return ssptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrf_$address() {
        return ssptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrf_(const char *uplo, const int *n, float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void ssptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = ssptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptrf_$descriptor() {
        return zsptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle zsptrf_$handle() {
        return zsptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment zsptrf_$address() {
        return zsptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void zsptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = zsptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptri_$descriptor() {
        return csptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csptri_$handle() {
        return csptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csptri_$address() {
        return csptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = csptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptri_$descriptor() {
        return dsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsptri_$handle() {
        return dsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsptri_$address() {
        return dsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptri_(const char *uplo, const int *n, double *AP, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static void dsptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = dsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptri_$descriptor() {
        return ssptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssptri_$handle() {
        return ssptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssptri_$address() {
        return ssptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptri_(const char *uplo, const int *n, float *AP, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static void ssptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = ssptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptri_$descriptor() {
        return zsptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsptri_$handle() {
        return zsptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsptri_$address() {
        return zsptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = zsptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csptrs_$descriptor() {
        return csptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csptrs_$handle() {
        return csptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csptrs_$address() {
        return csptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = csptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsptrs_$descriptor() {
        return dsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsptrs_$handle() {
        return dsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsptrs_$address() {
        return dsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsptrs_(const char *uplo, const int *n, const int *nrhs, const double *AP, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssptrs_$descriptor() {
        return ssptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssptrs_$handle() {
        return ssptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssptrs_$address() {
        return ssptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssptrs_(const char *uplo, const int *n, const int *nrhs, const float *AP, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = ssptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsptrs_$descriptor() {
        return zsptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsptrs_$handle() {
        return zsptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsptrs_$address() {
        return zsptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zsptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstebz_$descriptor() {
        return dstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstebz_$handle() {
        return dstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstebz_$address() {
        return dstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstebz_(const char *range, const char *order, const int *n, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, const double *D, const double *E, int *m, int *nsplit, double *W, int *IBLOCK, int *ISPLIT, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dstebz_(MemorySegment range, MemorySegment order, MemorySegment n, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment nsplit, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = dstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstebz_", range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
            }
            mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstebz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstebz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstebz_$descriptor() {
        return sstebz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstebz_$handle() {
        return sstebz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstebz_$address() {
        return sstebz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstebz_(const char *range, const char *order, const int *n, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, const float *D, const float *E, int *m, int *nsplit, float *W, int *IBLOCK, int *ISPLIT, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sstebz_(MemorySegment range, MemorySegment order, MemorySegment n, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment nsplit, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment work, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = sstebz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstebz_", range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
            }
            mh$.invokeExact(range, order, n, vl, vu, il, iu, abstol, D, E, m, nsplit, W, IBLOCK, ISPLIT, work, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cstedc_$descriptor() {
        return cstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle cstedc_$handle() {
        return cstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment cstedc_$address() {
        return cstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstedc_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void cstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13) {
        var mh$ = cstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstedc_", compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstedc_$descriptor() {
        return dstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle dstedc_$handle() {
        return dstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment dstedc_$address() {
        return dstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstedc_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void dstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = dstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstedc_", compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstedc_$descriptor() {
        return sstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle sstedc_$handle() {
        return sstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment sstedc_$address() {
        return sstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstedc_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void sstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = sstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstedc_", compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstedc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zstedc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zstedc_$descriptor() {
        return zstedc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle zstedc_$handle() {
        return zstedc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment zstedc_$address() {
        return zstedc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstedc_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void zstedc_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13) {
        var mh$ = zstedc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstedc_", compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cstegr_$descriptor() {
        return cstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cstegr_$handle() {
        return cstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cstegr_$address() {
        return cstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = cstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstegr_$descriptor() {
        return dstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstegr_$handle() {
        return dstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstegr_$address() {
        return dstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = dstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstegr_$descriptor() {
        return sstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstegr_$handle() {
        return sstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstegr_$address() {
        return sstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstegr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = sstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstegr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zstegr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zstegr_$descriptor() {
        return zstegr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zstegr_$handle() {
        return zstegr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zstegr_$address() {
        return zstegr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstegr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zstegr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = zstegr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstegr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor cstein_$descriptor() {
        return cstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle cstein_$handle() {
        return cstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment cstein_$address() {
        return cstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, _Complex float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void cstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = cstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor dstein_$descriptor() {
        return dstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle dstein_$handle() {
        return dstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment dstein_$address() {
        return dstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void dstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = dstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor sstein_$descriptor() {
        return sstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle sstein_$handle() {
        return sstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment sstein_$address() {
        return sstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstein_(const int *n, const float *D, const float *E, const int *m, const float *W, const int *IBLOCK, const int *ISPLIT, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void sstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = sstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zstein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static FunctionDescriptor zstein_$descriptor() {
        return zstein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MethodHandle zstein_$handle() {
        return zstein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static MemorySegment zstein_$address() {
        return zstein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstein_(const int *n, const double *D, const double *E, const int *m, const double *W, const int *IBLOCK, const int *ISPLIT, _Complex double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info)
     * }
     */
    public static void zstein_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment m, MemorySegment W, MemorySegment IBLOCK, MemorySegment ISPLIT, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info) {
        var mh$ = zstein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstein_", n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
            }
            mh$.invokeExact(n, D, E, m, W, IBLOCK, ISPLIT, Z, ldz, work, iwork, IFAIL, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cstemr_$descriptor() {
        return cstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cstemr_$handle() {
        return cstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cstemr_$address() {
        return cstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, _Complex float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = cstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstemr_$descriptor() {
        return dstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstemr_$handle() {
        return dstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstemr_$address() {
        return dstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = dstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstemr_$descriptor() {
        return sstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstemr_$handle() {
        return sstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstemr_$address() {
        return sstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstemr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, int *m, float *W, float *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = sstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zstemr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zstemr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zstemr_$descriptor() {
        return zstemr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zstemr_$handle() {
        return zstemr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zstemr_$address() {
        return zstemr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zstemr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, int *m, double *W, _Complex double *Z, const int *ldz, const int *nzc, int *ISUPPZ, int *tryrac, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zstemr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment nzc, MemorySegment ISUPPZ, MemorySegment tryrac, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22) {
        var mh$ = zstemr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zstemr_", jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, m, W, Z, ldz, nzc, ISUPPZ, tryrac, work, lwork, iwork, liwork, info, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csteqr_$descriptor() {
        return csteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csteqr_$handle() {
        return csteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csteqr_$address() {
        return csteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csteqr_(const char *compz, const int *n, float *D, float *E, _Complex float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void csteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = csteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsteqr_$descriptor() {
        return dsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsteqr_$handle() {
        return dsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsteqr_$address() {
        return dsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsteqr_(const char *compz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dsteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssteqr_$descriptor() {
        return ssteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssteqr_$handle() {
        return ssteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssteqr_$address() {
        return ssteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssteqr_(const char *compz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void ssteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = ssteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsteqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsteqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsteqr_$descriptor() {
        return zsteqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsteqr_$handle() {
        return zsteqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsteqr_$address() {
        return zsteqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsteqr_(const char *compz, const int *n, double *D, double *E, _Complex double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void zsteqr_(MemorySegment compz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zsteqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsteqr_", compz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(compz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static FunctionDescriptor dsterf_$descriptor() {
        return dsterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MethodHandle dsterf_$handle() {
        return dsterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static MemorySegment dsterf_$address() {
        return dsterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsterf_(const int *n, double *D, double *E, int *info)
     * }
     */
    public static void dsterf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = dsterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsterf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssterf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssterf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static FunctionDescriptor ssterf_$descriptor() {
        return ssterf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MethodHandle ssterf_$handle() {
        return ssterf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static MemorySegment ssterf_$address() {
        return ssterf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssterf_(const int *n, float *D, float *E, int *info)
     * }
     */
    public static void ssterf_(MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment info) {
        var mh$ = ssterf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssterf_", n, D, E, info);
            }
            mh$.invokeExact(n, D, E, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstev_$descriptor() {
        return dstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dstev_$handle() {
        return dstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dstev_$address() {
        return dstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstev_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, int *info, size_t)
     * }
     */
    public static void dstev_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = dstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstev_", jobz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstev_$descriptor() {
        return sstev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sstev_$handle() {
        return sstev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sstev_$address() {
        return sstev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstev_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, int *info, size_t)
     * }
     */
    public static void sstev_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = sstev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstev_", jobz, n, D, E, Z, ldz, work, info, x8);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dstevd_$descriptor() {
        return dstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle dstevd_$handle() {
        return dstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment dstevd_$address() {
        return dstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevd_(const char *jobz, const int *n, double *D, double *E, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void dstevd_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = dstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevd_", jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sstevd_$descriptor() {
        return sstevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MethodHandle sstevd_$handle() {
        return sstevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static MemorySegment sstevd_$address() {
        return sstevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevd_(const char *jobz, const int *n, float *D, float *E, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t)
     * }
     */
    public static void sstevd_(MemorySegment jobz, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11) {
        var mh$ = sstevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevd_", jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
            }
            mh$.invokeExact(jobz, n, D, E, Z, ldz, work, lwork, iwork, liwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstevr_$descriptor() {
        return dstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstevr_$handle() {
        return dstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstevr_$address() {
        return dstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevr_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dstevr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = dstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstevr_$descriptor() {
        return sstevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstevr_$handle() {
        return sstevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstevr_$address() {
        return sstevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevr_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void sstevr_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x20, long x21) {
        var mh$ = sstevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevr_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dstevx_$descriptor() {
        return dstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dstevx_$handle() {
        return dstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dstevx_$address() {
        return dstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dstevx_(const char *jobz, const char *range, const int *n, double *D, double *E, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static void dstevx_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19) {
        var mh$ = dstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dstevx_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sstevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sstevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sstevx_$descriptor() {
        return sstevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sstevx_$handle() {
        return sstevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sstevx_$address() {
        return sstevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sstevx_(const char *jobz, const char *range, const int *n, float *D, float *E, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, int *iwork, int *IFAIL, int *info, size_t, size_t)
     * }
     */
    public static void sstevx_(MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x18, long x19) {
        var mh$ = sstevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sstevx_", jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
            }
            mh$.invokeExact(jobz, range, n, D, E, vl, vu, il, iu, abstol, m, W, Z, ldz, work, iwork, IFAIL, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csycon_$descriptor() {
        return csycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csycon_$handle() {
        return csycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csycon_$address() {
        return csycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csycon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = csycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsycon_$descriptor() {
        return dsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsycon_$handle() {
        return dsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsycon_$address() {
        return dsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsycon_(const char *uplo, const int *n, const double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = dsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssycon_$descriptor() {
        return ssycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssycon_$handle() {
        return ssycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssycon_$address() {
        return ssycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssycon_(const char *uplo, const int *n, const float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10) {
        var mh$ = ssycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, iwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsycon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsycon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsycon_$descriptor() {
        return zsycon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsycon_$handle() {
        return zsycon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsycon_$address() {
        return zsycon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsycon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsycon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zsycon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsycon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csycon_3_$descriptor() {
        return csycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csycon_3_$handle() {
        return csycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csycon_3_$address() {
        return csycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csycon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = csycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsycon_3_$descriptor() {
        return dsycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsycon_3_$handle() {
        return dsycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsycon_3_$address() {
        return dsycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsycon_3_(const char *uplo, const int *n, const double *A, const int *lda, const double *E, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11) {
        var mh$ = dsycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssycon_3_$descriptor() {
        return ssycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssycon_3_$handle() {
        return ssycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssycon_3_$address() {
        return ssycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssycon_3_(const char *uplo, const int *n, const float *A, const int *lda, const float *E, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11) {
        var mh$ = ssycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, iwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsycon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsycon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsycon_3_$descriptor() {
        return zsycon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsycon_3_$handle() {
        return zsycon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsycon_3_$address() {
        return zsycon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsycon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsycon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zsycon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsycon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csyconv_$descriptor() {
        return csyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csyconv_$handle() {
        return csyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csyconv_$address() {
        return csyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyconv_(const char *uplo, const char *way, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *E, int *info, size_t, size_t)
     * }
     */
    public static void csyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = csyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyconv_$descriptor() {
        return dsyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyconv_$handle() {
        return dsyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyconv_$address() {
        return dsyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyconv_(const char *uplo, const char *way, const int *n, double *A, const int *lda, const int *ipiv, double *E, int *info, size_t, size_t)
     * }
     */
    public static void dsyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = dsyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyconv_$descriptor() {
        return ssyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyconv_$handle() {
        return ssyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyconv_$address() {
        return ssyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyconv_(const char *uplo, const char *way, const int *n, float *A, const int *lda, const int *ipiv, float *E, int *info, size_t, size_t)
     * }
     */
    public static void ssyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = ssyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyconv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyconv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsyconv_$descriptor() {
        return zsyconv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsyconv_$handle() {
        return zsyconv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsyconv_$address() {
        return zsyconv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyconv_(const char *uplo, const char *way, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *E, int *info, size_t, size_t)
     * }
     */
    public static void zsyconv_(MemorySegment uplo, MemorySegment way, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment E, MemorySegment info, long x8, long x9) {
        var mh$ = zsyconv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyconv_", uplo, way, n, A, lda, ipiv, E, info, x8, x9);
            }
            mh$.invokeExact(uplo, way, n, A, lda, ipiv, E, info, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csyequb_$descriptor() {
        return csyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csyequb_$handle() {
        return csyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csyequb_$address() {
        return csyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = csyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsyequb_$descriptor() {
        return dsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsyequb_$handle() {
        return dsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsyequb_$address() {
        return dsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyequb_(const char *uplo, const int *n, const double *A, const int *lda, double *S, double *scond, double *amax, double *work, int *info, size_t)
     * }
     */
    public static void dsyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = dsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssyequb_$descriptor() {
        return ssyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssyequb_$handle() {
        return ssyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssyequb_$address() {
        return ssyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyequb_(const char *uplo, const int *n, const float *A, const int *lda, float *S, float *scond, float *amax, float *work, int *info, size_t)
     * }
     */
    public static void ssyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = ssyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsyequb_$descriptor() {
        return zsyequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsyequb_$handle() {
        return zsyequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsyequb_$address() {
        return zsyequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsyequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zsyequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyev_$descriptor() {
        return dsyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyev_$handle() {
        return dsyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyev_$address() {
        return dsyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyev_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = dsyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyev_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyev_$descriptor() {
        return ssyev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyev_$handle() {
        return ssyev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyev_$address() {
        return ssyev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyev_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = ssyev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyev_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyev_2stage_$descriptor() {
        return dsyev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyev_2stage_$handle() {
        return dsyev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyev_2stage_$address() {
        return dsyev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyev_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = dsyev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyev_2stage_$descriptor() {
        return ssyev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyev_2stage_$handle() {
        return ssyev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyev_2stage_$address() {
        return ssyev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyev_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9, long x10) {
        var mh$ = ssyev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, info, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevd_$descriptor() {
        return dsyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevd_$handle() {
        return dsyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevd_$address() {
        return dsyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevd_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = dsyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevd_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevd_$descriptor() {
        return ssyevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevd_$handle() {
        return ssyevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevd_$address() {
        return ssyevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevd_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = ssyevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevd_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevd_2stage_$descriptor() {
        return dsyevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevd_2stage_$handle() {
        return dsyevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevd_2stage_$address() {
        return dsyevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevd_2stage_(const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = dsyevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevd_2stage_$descriptor() {
        return ssyevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevd_2stage_$handle() {
        return ssyevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevd_2stage_$address() {
        return ssyevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevd_2stage_(const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x11, long x12) {
        var mh$ = ssyevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, iwork, liwork, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevr_$descriptor() {
        return dsyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevr_$handle() {
        return dsyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevr_$address() {
        return dsyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevr_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dsyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevr_$descriptor() {
        return ssyevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevr_$handle() {
        return ssyevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevr_$address() {
        return ssyevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevr_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = ssyevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevr_2stage_$descriptor() {
        return dsyevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevr_2stage_$handle() {
        return dsyevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevr_2stage_$address() {
        return dsyevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, int *ISUPPZ, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dsyevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevr_2stage_$descriptor() {
        return ssyevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevr_2stage_$handle() {
        return ssyevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevr_2stage_$address() {
        return ssyevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, int *ISUPPZ, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = ssyevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, iwork, liwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevx_$descriptor() {
        return dsyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevx_$handle() {
        return dsyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevx_$address() {
        return dsyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevx_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dsyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevx_$descriptor() {
        return ssyevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevx_$handle() {
        return ssyevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevx_$address() {
        return ssyevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevx_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = ssyevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyevx_2stage_$descriptor() {
        return dsyevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsyevx_2stage_$handle() {
        return dsyevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsyevx_2stage_$address() {
        return dsyevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsyevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dsyevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyevx_2stage_$descriptor() {
        return ssyevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssyevx_2stage_$handle() {
        return ssyevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssyevx_2stage_$address() {
        return ssyevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssyevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = ssyevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsygst_$descriptor() {
        return dsygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsygst_$handle() {
        return dsygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsygst_$address() {
        return dsygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygst_(const int *itype, const char *uplo, const int *n, double *A, const int *lda, const double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsygst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = dsygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssygst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssygst_$descriptor() {
        return ssygst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssygst_$handle() {
        return ssygst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssygst_$address() {
        return ssygst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygst_(const int *itype, const char *uplo, const int *n, float *A, const int *lda, const float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssygst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = ssygst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygv_$descriptor() {
        return dsygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygv_$handle() {
        return dsygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygv_$address() {
        return dsygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygv_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssygv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygv_$descriptor() {
        return ssygv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygv_$handle() {
        return ssygv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygv_$address() {
        return ssygv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygv_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssygv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsygv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygv_2stage_$descriptor() {
        return dsygv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygv_2stage_$handle() {
        return dsygv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygv_2stage_$address() {
        return dsygv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = dsygv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssygv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygv_2stage_$descriptor() {
        return ssygv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygv_2stage_$handle() {
        return ssygv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygv_2stage_$address() {
        return ssygv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12, long x13) {
        var mh$ = ssygv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygvd_$descriptor() {
        return dsygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsygvd_$handle() {
        return dsygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsygvd_$address() {
        return dsygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, double *W, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dsygvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = dsygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssygvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygvd_$descriptor() {
        return ssygvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssygvd_$handle() {
        return ssygvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssygvd_$address() {
        return ssygvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygvd_(const int *itype, const char *jobz, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, float *W, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void ssygvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = ssygvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsygvx_$descriptor() {
        return dsygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsygvx_$handle() {
        return dsygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsygvx_$address() {
        return dsygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, double *Z, const int *ldz, double *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsygvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dsygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsygvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssygvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssygvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssygvx_$descriptor() {
        return ssygvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssygvx_$handle() {
        return ssygvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssygvx_$address() {
        return ssygvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssygvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, float *Z, const int *ldz, float *work, const int *lwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssygvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = ssygvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssygvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor csyr_$descriptor() {
        return csyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle csyr_$handle() {
        return csyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment csyr_$address() {
        return csyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyr_(const char *uplo, const int *n, const _Complex float *alpha, const _Complex float *X, const int *incx, _Complex float *A, const int *lda, size_t)
     * }
     */
    public static void csyr_(MemorySegment uplo, MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = csyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyr_", uplo, n, alpha, X, incx, A, lda, x7);
            }
            mh$.invokeExact(uplo, n, alpha, X, incx, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static FunctionDescriptor zsyr_$descriptor() {
        return zsyr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MethodHandle zsyr_$handle() {
        return zsyr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static MemorySegment zsyr_$address() {
        return zsyr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyr_(const char *uplo, const int *n, const _Complex double *alpha, const _Complex double *X, const int *incx, _Complex double *A, const int *lda, size_t)
     * }
     */
    public static void zsyr_(MemorySegment uplo, MemorySegment n, MemorySegment alpha, MemorySegment X, MemorySegment incx, MemorySegment A, MemorySegment lda, long x7) {
        var mh$ = zsyr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyr_", uplo, n, alpha, X, incx, A, lda, x7);
            }
            mh$.invokeExact(uplo, n, alpha, X, incx, A, lda, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csyrfs_$descriptor() {
        return csyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle csyrfs_$handle() {
        return csyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment csyrfs_$address() {
        return csyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void csyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = csyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsyrfs_$descriptor() {
        return dsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsyrfs_$handle() {
        return dsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsyrfs_$address() {
        return dsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyrfs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dsyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssyrfs_$descriptor() {
        return ssyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssyrfs_$handle() {
        return ssyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssyrfs_$address() {
        return ssyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyrfs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void ssyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = ssyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsyrfs_$descriptor() {
        return zsyrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsyrfs_$handle() {
        return zsyrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsyrfs_$address() {
        return zsyrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyrfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zsyrfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zsyrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csyrfsx_$descriptor() {
        return csyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csyrfsx_$handle() {
        return csyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csyrfsx_$address() {
        return csyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void csyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = csyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsyrfsx_$descriptor() {
        return dsyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsyrfsx_$handle() {
        return dsyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsyrfsx_$address() {
        return dsyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *S, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dsyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25) {
        var mh$ = dsyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssyrfsx_$descriptor() {
        return ssyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssyrfsx_$handle() {
        return ssyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssyrfsx_$address() {
        return ssyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *S, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ssyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25) {
        var mh$ = ssyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsyrfsx_$descriptor() {
        return zsyrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsyrfsx_$handle() {
        return zsyrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsyrfsx_$address() {
        return zsyrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyrfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zsyrfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = zsyrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyrfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_$descriptor() {
        return csysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_$handle() {
        return csysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_$address() {
        return csysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_$descriptor() {
        return dsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_$handle() {
        return dsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_$address() {
        return dsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_$descriptor() {
        return ssysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_$handle() {
        return ssysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_$address() {
        return ssysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_$descriptor() {
        return zsysv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_$handle() {
        return zsysv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_$address() {
        return zsysv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_aa_$descriptor() {
        return csysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_aa_$handle() {
        return csysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_aa_$address() {
        return csysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_aa_$descriptor() {
        return dsysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_aa_$handle() {
        return dsysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_aa_$address() {
        return dsysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_aa_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_aa_$descriptor() {
        return ssysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_aa_$handle() {
        return ssysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_aa_$address() {
        return ssysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_aa_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_aa_$descriptor() {
        return zsysv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_aa_$handle() {
        return zsysv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_aa_$address() {
        return zsysv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_aa_2stage_$descriptor() {
        return csysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_aa_2stage_$handle() {
        return csysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_aa_2stage_$address() {
        return csysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = csysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_aa_2stage_$descriptor() {
        return dsysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_aa_2stage_$handle() {
        return dsysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_aa_2stage_$address() {
        return dsysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = dsysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_aa_2stage_$descriptor() {
        return ssysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_aa_2stage_$handle() {
        return ssysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_aa_2stage_$address() {
        return ssysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = ssysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_aa_2stage_$descriptor() {
        return zsysv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_aa_2stage_$handle() {
        return zsysv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_aa_2stage_$address() {
        return zsysv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = zsysv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_rk_$descriptor() {
        return csysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_rk_$handle() {
        return csysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_rk_$address() {
        return csysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = csysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_rk_$descriptor() {
        return dsysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_rk_$handle() {
        return dsysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_rk_$address() {
        return dsysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_rk_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *E, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = dsysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_rk_$descriptor() {
        return ssysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_rk_$handle() {
        return ssysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_rk_$address() {
        return ssysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_rk_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *E, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = ssysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_rk_$descriptor() {
        return zsysv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_rk_$handle() {
        return zsysv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_rk_$address() {
        return zsysv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = zsysv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csysv_rook_$descriptor() {
        return csysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csysv_rook_$handle() {
        return csysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csysv_rook_$address() {
        return csysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsysv_rook_$descriptor() {
        return dsysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsysv_rook_$handle() {
        return dsysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsysv_rook_$address() {
        return dsysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysv_rook_(const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssysv_rook_$descriptor() {
        return ssysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssysv_rook_$handle() {
        return ssysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssysv_rook_$address() {
        return ssysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysv_rook_(const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsysv_rook_$descriptor() {
        return zsysv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsysv_rook_$handle() {
        return zsysv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsysv_rook_$address() {
        return zsysv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsysv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsysv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csysvx_$descriptor() {
        return csysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle csysvx_$handle() {
        return csysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment csysvx_$address() {
        return csysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void csysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = csysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsysvx_$descriptor() {
        return dsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsysvx_$handle() {
        return dsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsysvx_$address() {
        return dsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dsysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = dsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssysvx_$descriptor() {
        return ssysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssysvx_$handle() {
        return ssysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssysvx_$address() {
        return ssysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ssysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ssysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsysvx_$descriptor() {
        return zsysvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zsysvx_$handle() {
        return zsysvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zsysvx_$address() {
        return zsysvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zsysvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = zsysvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor csysvxx_$descriptor() {
        return csysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle csysvxx_$handle() {
        return csysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment csysvxx_$address() {
        return csysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void csysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = csysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsysvxx_$descriptor() {
        return dsysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dsysvxx_$handle() {
        return dsysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dsysvxx_$address() {
        return dsysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *S, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dsysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = dsysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssysvxx_$descriptor() {
        return ssysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ssysvxx_$handle() {
        return ssysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ssysvxx_$address() {
        return ssysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *S, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ssysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = ssysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsysvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsysvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zsysvxx_$descriptor() {
        return zsysvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zsysvxx_$handle() {
        return zsysvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zsysvxx_$address() {
        return zsysvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsysvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zsysvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zsysvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsysvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor csyswapr_$descriptor() {
        return csyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle csyswapr_$handle() {
        return csyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment csyswapr_$address() {
        return csyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csyswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void csyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = csyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor dsyswapr_$descriptor() {
        return dsyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle dsyswapr_$handle() {
        return dsyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment dsyswapr_$address() {
        return dsyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsyswapr_(const char *uplo, const int *n, double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void dsyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = dsyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor ssyswapr_$descriptor() {
        return ssyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle ssyswapr_$handle() {
        return ssyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment ssyswapr_$address() {
        return ssyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssyswapr_(const char *uplo, const int *n, float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void ssyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = ssyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsyswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsyswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor zsyswapr_$descriptor() {
        return zsyswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle zsyswapr_$handle() {
        return zsyswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment zsyswapr_$address() {
        return zsyswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsyswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void zsyswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = zsyswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsyswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrd_$descriptor() {
        return dsytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrd_$handle() {
        return dsytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrd_$address() {
        return dsytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrd_(const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = dsytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrd_$descriptor() {
        return ssytrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrd_$handle() {
        return ssytrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrd_$address() {
        return ssytrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrd_(const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = ssytrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dsytrd_2stage_$descriptor() {
        return dsytrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dsytrd_2stage_$handle() {
        return dsytrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dsytrd_2stage_$address() {
        return dsytrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrd_2stage_(const char *vect, const char *uplo, const int *n, double *A, const int *lda, double *D, double *E, double *tau, double *HOUS2, const int *lhous2, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dsytrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = dsytrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ssytrd_2stage_$descriptor() {
        return ssytrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ssytrd_2stage_$handle() {
        return ssytrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ssytrd_2stage_$address() {
        return ssytrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrd_2stage_(const char *vect, const char *uplo, const int *n, float *A, const int *lda, float *D, float *E, float *tau, float *HOUS2, const int *lhous2, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ssytrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = ssytrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_$descriptor() {
        return csytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_$handle() {
        return csytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_$address() {
        return csytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_$descriptor() {
        return dsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_$handle() {
        return dsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_$address() {
        return dsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_$descriptor() {
        return ssytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_$handle() {
        return ssytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_$address() {
        return ssytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_$descriptor() {
        return zsytrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_$handle() {
        return zsytrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_$address() {
        return zsytrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_aa_$descriptor() {
        return csytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_aa_$handle() {
        return csytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_aa_$address() {
        return csytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_aa_$descriptor() {
        return dsytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_aa_$handle() {
        return dsytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_aa_$address() {
        return dsytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_aa_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_aa_$descriptor() {
        return ssytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_aa_$handle() {
        return ssytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_aa_$address() {
        return ssytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_aa_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_aa_$descriptor() {
        return zsytrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_aa_$handle() {
        return zsytrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_aa_$address() {
        return zsytrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_aa_2stage_$descriptor() {
        return csytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_aa_2stage_$handle() {
        return csytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_aa_2stage_$address() {
        return csytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_aa_2stage_$descriptor() {
        return dsytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_aa_2stage_$handle() {
        return dsytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_aa_2stage_$address() {
        return dsytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_aa_2stage_(const char *uplo, const int *n, double *A, const int *lda, double *TB, const int *ltb, int *ipiv, int *ipiv2, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_aa_2stage_$descriptor() {
        return ssytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_aa_2stage_$handle() {
        return ssytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_aa_2stage_$address() {
        return ssytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_aa_2stage_(const char *uplo, const int *n, float *A, const int *lda, float *TB, const int *ltb, int *ipiv, int *ipiv2, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_aa_2stage_$descriptor() {
        return zsytrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_aa_2stage_$handle() {
        return zsytrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_aa_2stage_$address() {
        return zsytrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsytrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_rk_$descriptor() {
        return csytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_rk_$handle() {
        return csytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_rk_$address() {
        return csytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = csytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_rk_$descriptor() {
        return dsytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_rk_$handle() {
        return dsytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_rk_$address() {
        return dsytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_rk_(const char *uplo, const int *n, double *A, const int *lda, double *E, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = dsytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_rk_$descriptor() {
        return ssytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_rk_$handle() {
        return ssytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_rk_$address() {
        return ssytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_rk_(const char *uplo, const int *n, float *A, const int *lda, float *E, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = ssytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_rk_$descriptor() {
        return zsytrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_rk_$handle() {
        return zsytrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_rk_$address() {
        return zsytrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zsytrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrf_rook_$descriptor() {
        return csytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrf_rook_$handle() {
        return csytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrf_rook_$address() {
        return csytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrf_rook_$descriptor() {
        return dsytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrf_rook_$handle() {
        return dsytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrf_rook_$address() {
        return dsytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrf_rook_(const char *uplo, const int *n, double *A, const int *lda, int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrf_rook_$descriptor() {
        return ssytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrf_rook_$handle() {
        return ssytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrf_rook_$address() {
        return ssytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrf_rook_(const char *uplo, const int *n, float *A, const int *lda, int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrf_rook_$descriptor() {
        return zsytrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrf_rook_$handle() {
        return zsytrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrf_rook_$address() {
        return zsytrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri_$descriptor() {
        return csytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csytri_$handle() {
        return csytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csytri_$address() {
        return csytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = csytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri_$descriptor() {
        return dsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri_$handle() {
        return dsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri_$address() {
        return dsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, int *info, size_t)
     * }
     */
    public static void dsytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = dsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri_$descriptor() {
        return ssytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri_$handle() {
        return ssytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri_$address() {
        return ssytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, int *info, size_t)
     * }
     */
    public static void ssytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = ssytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri_$descriptor() {
        return zsytri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri_$handle() {
        return zsytri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri_$address() {
        return zsytri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsytri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = zsytri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri2_$descriptor() {
        return csytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytri2_$handle() {
        return csytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytri2_$address() {
        return csytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = csytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri2_$descriptor() {
        return dsytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri2_$handle() {
        return dsytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri2_$address() {
        return dsytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri2_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = dsytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri2_$descriptor() {
        return ssytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri2_$handle() {
        return ssytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri2_$address() {
        return ssytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri2_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = ssytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri2_$descriptor() {
        return zsytri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri2_$handle() {
        return zsytri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri2_$address() {
        return zsytri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zsytri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri2x_$descriptor() {
        return csytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle csytri2x_$handle() {
        return csytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment csytri2x_$address() {
        return csytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void csytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = csytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri2x_$descriptor() {
        return dsytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri2x_$handle() {
        return dsytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri2x_$address() {
        return dsytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri2x_(const char *uplo, const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void dsytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = dsytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri2x_$descriptor() {
        return ssytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri2x_$handle() {
        return ssytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri2x_$address() {
        return ssytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri2x_(const char *uplo, const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void ssytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = ssytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri2x_$descriptor() {
        return zsytri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri2x_$handle() {
        return zsytri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri2x_$address() {
        return zsytri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void zsytri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = zsytri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytri_3_$descriptor() {
        return csytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytri_3_$handle() {
        return csytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytri_3_$address() {
        return csytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = csytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytri_3_$descriptor() {
        return dsytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytri_3_$handle() {
        return dsytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytri_3_$address() {
        return dsytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytri_3_(const char *uplo, const int *n, double *A, const int *lda, const double *E, const int *ipiv, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = dsytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytri_3_$descriptor() {
        return ssytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytri_3_$handle() {
        return ssytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytri_3_$address() {
        return ssytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytri_3_(const char *uplo, const int *n, float *A, const int *lda, const float *E, const int *ipiv, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = ssytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytri_3_$descriptor() {
        return zsytri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytri_3_$handle() {
        return zsytri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytri_3_$address() {
        return zsytri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zsytri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_$descriptor() {
        return csytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_$handle() {
        return csytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_$address() {
        return csytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = csytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_$descriptor() {
        return dsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_$handle() {
        return dsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_$address() {
        return dsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_$descriptor() {
        return ssytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_$handle() {
        return ssytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_$address() {
        return ssytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = ssytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_$descriptor() {
        return zsytrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_$handle() {
        return zsytrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_$address() {
        return zsytrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zsytrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs2_$descriptor() {
        return csytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs2_$handle() {
        return csytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs2_$address() {
        return csytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static void csytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = csytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs2_$descriptor() {
        return dsytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs2_$handle() {
        return dsytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs2_$address() {
        return dsytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs2_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, int *info, size_t)
     * }
     */
    public static void dsytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = dsytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs2_$descriptor() {
        return ssytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs2_$handle() {
        return ssytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs2_$address() {
        return ssytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs2_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, int *info, size_t)
     * }
     */
    public static void ssytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = ssytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs2_$descriptor() {
        return zsytrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs2_$handle() {
        return zsytrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs2_$address() {
        return zsytrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zsytrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zsytrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_3_$descriptor() {
        return csytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_3_$handle() {
        return csytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_3_$address() {
        return csytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = csytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_3_$descriptor() {
        return dsytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_3_$handle() {
        return dsytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_3_$address() {
        return dsytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_3_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const double *E, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = dsytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_3_$descriptor() {
        return ssytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_3_$handle() {
        return ssytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_3_$address() {
        return ssytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_3_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const float *E, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = ssytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_3_$descriptor() {
        return zsytrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_3_$handle() {
        return zsytrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_3_$address() {
        return zsytrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = zsytrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_aa_$descriptor() {
        return csytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_aa_$handle() {
        return csytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_aa_$address() {
        return csytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void csytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = csytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_aa_$descriptor() {
        return dsytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_aa_$handle() {
        return dsytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_aa_$address() {
        return dsytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dsytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dsytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_aa_$descriptor() {
        return ssytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_aa_$handle() {
        return ssytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_aa_$address() {
        return ssytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_aa_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void ssytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = ssytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_aa_$descriptor() {
        return zsytrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_aa_$handle() {
        return zsytrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_aa_$address() {
        return zsytrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zsytrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zsytrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_aa_2stage_$descriptor() {
        return csytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_aa_2stage_$handle() {
        return csytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_aa_2stage_$address() {
        return csytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = csytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_aa_2stage_$descriptor() {
        return dsytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_aa_2stage_$handle() {
        return dsytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_aa_2stage_$address() {
        return dsytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, double *TB, const int *ltb, const int *ipiv, const int *ipiv2, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = dsytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_aa_2stage_$descriptor() {
        return ssytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_aa_2stage_$handle() {
        return ssytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_aa_2stage_$address() {
        return ssytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, float *TB, const int *ltb, const int *ipiv, const int *ipiv2, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = ssytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_aa_2stage_$descriptor() {
        return zsytrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_aa_2stage_$handle() {
        return zsytrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_aa_2stage_$address() {
        return zsytrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = zsytrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor csytrs_rook_$descriptor() {
        return csytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle csytrs_rook_$handle() {
        return csytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment csytrs_rook_$address() {
        return csytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void csytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void csytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = csytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dsytrs_rook_$descriptor() {
        return dsytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dsytrs_rook_$handle() {
        return dsytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dsytrs_rook_$address() {
        return dsytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dsytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dsytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ssytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ssytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ssytrs_rook_$descriptor() {
        return ssytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle ssytrs_rook_$handle() {
        return ssytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment ssytrs_rook_$address() {
        return ssytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ssytrs_rook_(const char *uplo, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void ssytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = ssytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ssytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zsytrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zsytrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zsytrs_rook_$descriptor() {
        return zsytrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zsytrs_rook_$handle() {
        return zsytrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zsytrs_rook_$address() {
        return zsytrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zsytrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zsytrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zsytrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zsytrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbcon_$descriptor() {
        return ctbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbcon_$handle() {
        return ctbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbcon_$address() {
        return ctbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex float *AB, const int *ldab, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ctbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbcon_$descriptor() {
        return dtbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbcon_$handle() {
        return dtbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbcon_$address() {
        return dtbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const double *AB, const int *ldab, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dtbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbcon_$descriptor() {
        return stbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbcon_$handle() {
        return stbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbcon_$address() {
        return stbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const float *AB, const int *ldab, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = stbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, iwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbcon_$descriptor() {
        return ztbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbcon_$handle() {
        return ztbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbcon_$address() {
        return ztbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbcon_(const char *norm, const char *uplo, const char *diag, const int *n, const int *kd, const _Complex double *AB, const int *ldab, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ztbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbcon_", norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
            }
            mh$.invokeExact(norm, uplo, diag, n, kd, AB, ldab, rcond, work, rwork, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbrfs_$descriptor() {
        return ctbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbrfs_$handle() {
        return ctbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbrfs_$address() {
        return ctbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = ctbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbrfs_$descriptor() {
        return dtbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbrfs_$handle() {
        return dtbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbrfs_$address() {
        return dtbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = dtbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbrfs_$descriptor() {
        return stbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbrfs_$handle() {
        return stbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbrfs_$address() {
        return stbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = stbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbrfs_$descriptor() {
        return ztbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbrfs_$handle() {
        return ztbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbrfs_$address() {
        return ztbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = ztbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbrfs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctbtrs_$descriptor() {
        return ctbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctbtrs_$handle() {
        return ctbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctbtrs_$address() {
        return ctbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex float *AB, const int *ldab, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ctbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtbtrs_$descriptor() {
        return dtbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtbtrs_$handle() {
        return dtbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtbtrs_$address() {
        return dtbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const double *AB, const int *ldab, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = dtbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stbtrs_$descriptor() {
        return stbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stbtrs_$handle() {
        return stbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stbtrs_$address() {
        return stbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const float *AB, const int *ldab, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = stbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztbtrs_$descriptor() {
        return ztbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztbtrs_$handle() {
        return ztbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztbtrs_$address() {
        return ztbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztbtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *kd, const int *nrhs, const _Complex double *AB, const int *ldab, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztbtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment kd, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = ztbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztbtrs_", uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
            }
            mh$.invokeExact(uplo, trans, diag, n, kd, nrhs, AB, ldab, B, ldb, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfsm_$descriptor() {
        return ctfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctfsm_$handle() {
        return ctfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctfsm_$address() {
        return ctfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex float *alpha, const _Complex float *A, _Complex float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ctfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = ctfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfsm_$descriptor() {
        return dtfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtfsm_$handle() {
        return dtfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtfsm_$address() {
        return dtfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const double *alpha, const double *A, double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dtfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = dtfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfsm_$descriptor() {
        return stfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stfsm_$handle() {
        return stfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stfsm_$address() {
        return stfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const float *alpha, const float *A, float *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void stfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = stfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfsm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztfsm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfsm_$descriptor() {
        return ztfsm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztfsm_$handle() {
        return ztfsm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztfsm_$address() {
        return ztfsm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfsm_(const char *transr, const char *side, const char *uplo, const char *trans, const char *diag, const int *m, const int *n, const _Complex double *alpha, const _Complex double *A, _Complex double *B, const int *ldb, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ztfsm_(MemorySegment transr, MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment m, MemorySegment n, MemorySegment alpha, MemorySegment A, MemorySegment B, MemorySegment ldb, long x11, long x12, long x13, long x14, long x15) {
        var mh$ = ztfsm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfsm_", transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
            }
            mh$.invokeExact(transr, side, uplo, trans, diag, m, n, alpha, A, B, ldb, x11, x12, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctftri_$descriptor() {
        return ctftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctftri_$handle() {
        return ctftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctftri_$address() {
        return ctftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = ctftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtftri_$descriptor() {
        return dtftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtftri_$handle() {
        return dtftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtftri_$address() {
        return dtftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtftri_(const char *transr, const char *uplo, const char *diag, const int *n, double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = dtftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stftri_$descriptor() {
        return stftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stftri_$handle() {
        return stftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stftri_$address() {
        return stftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stftri_(const char *transr, const char *uplo, const char *diag, const int *n, float *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = stftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztftri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztftri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztftri_$descriptor() {
        return ztftri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztftri_$handle() {
        return ztftri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztftri_$address() {
        return ztftri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztftri_(const char *transr, const char *uplo, const char *diag, const int *n, _Complex double *A, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztftri_(MemorySegment transr, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment info, long x6, long x7, long x8) {
        var mh$ = ztftri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztftri_", transr, uplo, diag, n, A, info, x6, x7, x8);
            }
            mh$.invokeExact(transr, uplo, diag, n, A, info, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfttp_$descriptor() {
        return ctfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctfttp_$handle() {
        return ctfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctfttp_$address() {
        return ctfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfttp_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static void ctfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = ctfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfttp_$descriptor() {
        return dtfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtfttp_$handle() {
        return dtfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtfttp_$address() {
        return dtfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfttp_(const char *transr, const char *uplo, const int *n, const double *ARF, double *AP, int *info, size_t, size_t)
     * }
     */
    public static void dtfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = dtfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfttp_$descriptor() {
        return stfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stfttp_$handle() {
        return stfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stfttp_$address() {
        return stfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfttp_(const char *transr, const char *uplo, const int *n, const float *ARF, float *AP, int *info, size_t, size_t)
     * }
     */
    public static void stfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = stfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztfttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfttp_$descriptor() {
        return ztfttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztfttp_$handle() {
        return ztfttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztfttp_$address() {
        return ztfttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfttp_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static void ztfttp_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment AP, MemorySegment info, long x6, long x7) {
        var mh$ = ztfttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttp_", transr, uplo, n, ARF, AP, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, ARF, AP, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctfttr_$descriptor() {
        return ctfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctfttr_$handle() {
        return ctfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctfttr_$address() {
        return ctfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctfttr_(const char *transr, const char *uplo, const int *n, const _Complex float *ARF, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ctfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = ctfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtfttr_$descriptor() {
        return dtfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtfttr_$handle() {
        return dtfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtfttr_$address() {
        return dtfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtfttr_(const char *transr, const char *uplo, const int *n, const double *ARF, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void dtfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = dtfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stfttr_$descriptor() {
        return stfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stfttr_$handle() {
        return stfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stfttr_$address() {
        return stfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stfttr_(const char *transr, const char *uplo, const int *n, const float *ARF, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void stfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = stfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztfttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztfttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztfttr_$descriptor() {
        return ztfttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztfttr_$handle() {
        return ztfttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztfttr_$address() {
        return ztfttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztfttr_(const char *transr, const char *uplo, const int *n, const _Complex double *ARF, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ztfttr_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment ARF, MemorySegment A, MemorySegment lda, MemorySegment info, long x7, long x8) {
        var mh$ = ztfttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztfttr_", transr, uplo, n, ARF, A, lda, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, ARF, A, lda, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgevc_$descriptor() {
        return ctgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctgevc_$handle() {
        return ctgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctgevc_$address() {
        return ctgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex float *S, const int *lds, const _Complex float *P, const int *ldp, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = ctgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgevc_$descriptor() {
        return dtgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtgevc_$handle() {
        return dtgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtgevc_$address() {
        return dtgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgevc_(const char *side, const char *howmny, const int *select, const int *n, const double *S, const int *lds, const double *P, const int *ldp, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x16, long x17) {
        var mh$ = dtgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgevc_$descriptor() {
        return stgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stgevc_$handle() {
        return stgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stgevc_$address() {
        return stgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgevc_(const char *side, const char *howmny, const int *select, const int *n, const float *S, const int *lds, const float *P, const int *ldp, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x16, long x17) {
        var mh$ = stgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgevc_$descriptor() {
        return ztgevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztgevc_$handle() {
        return ztgevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztgevc_$address() {
        return ztgevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgevc_(const char *side, const char *howmny, const int *select, const int *n, const _Complex double *S, const int *lds, const _Complex double *P, const int *ldp, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztgevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment S, MemorySegment lds, MemorySegment P, MemorySegment ldp, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = ztgevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgevc_", side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, S, lds, P, ldp, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static FunctionDescriptor ctgexc_$descriptor() {
        return ctgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MethodHandle ctgexc_$handle() {
        return ctgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MemorySegment ctgexc_$address() {
        return ctgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgexc_(const int *wantq, const int *wantz, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static void ctgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment info) {
        var mh$ = ctgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dtgexc_$descriptor() {
        return dtgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dtgexc_$handle() {
        return dtgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dtgexc_$address() {
        return dtgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgexc_(const int *wantq, const int *wantz, const int *n, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *ifst, int *ilst, double *work, const int *lwork, int *info)
     * }
     */
    public static void dtgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dtgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor stgexc_$descriptor() {
        return stgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle stgexc_$handle() {
        return stgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment stgexc_$address() {
        return stgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgexc_(const int *wantq, const int *wantz, const int *n, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *ifst, int *ilst, float *work, const int *lwork, int *info)
     * }
     */
    public static void stgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = stgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static FunctionDescriptor ztgexc_$descriptor() {
        return ztgexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MethodHandle ztgexc_$handle() {
        return ztgexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static MemorySegment ztgexc_$address() {
        return ztgexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgexc_(const int *wantq, const int *wantz, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, const int *ifst, int *ilst, int *info)
     * }
     */
    public static void ztgexc_(MemorySegment wantq, MemorySegment wantz, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment ifst, MemorySegment ilst, MemorySegment info) {
        var mh$ = ztgexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgexc_", wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
            }
            mh$.invokeExact(wantq, wantz, n, A, lda, B, ldb, Q, ldq, Z, ldz, ifst, ilst, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor ctgsen_$descriptor() {
        return ctgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle ctgsen_$handle() {
        return ctgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment ctgsen_$address() {
        return ctgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, _Complex float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void ctgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = ctgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor dtgsen_$descriptor() {
        return dtgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle dtgsen_$handle() {
        return dtgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment dtgsen_$address() {
        return dtgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void dtgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = dtgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor stgsen_$descriptor() {
        return stgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle stgsen_$handle() {
        return stgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment stgsen_$address() {
        return stgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, int *m, float *pl, float *pr, float *DIF, float *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void stgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = stgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alphar, alphai, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static FunctionDescriptor ztgsen_$descriptor() {
        return ztgsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MethodHandle ztgsen_$handle() {
        return ztgsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static MemorySegment ztgsen_$address() {
        return ztgsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsen_(const int *ijob, const int *wantq, const int *wantz, const int *select, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *m, double *pl, double *pr, double *DIF, _Complex double *work, const int *lwork, int *iwork, const int *liwork, int *info)
     * }
     */
    public static void ztgsen_(MemorySegment ijob, MemorySegment wantq, MemorySegment wantz, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment m, MemorySegment pl, MemorySegment pr, MemorySegment DIF, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info) {
        var mh$ = ztgsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsen_", ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
            }
            mh$.invokeExact(ijob, wantq, wantz, select, n, A, lda, B, ldb, alpha, beta, Q, ldq, Z, ldz, m, pl, pr, DIF, work, lwork, iwork, liwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgsja_$descriptor() {
        return ctgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctgsja_$handle() {
        return ctgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctgsja_$address() {
        return ctgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ctgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgsja_$descriptor() {
        return dtgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtgsja_$handle() {
        return dtgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtgsja_$address() {
        return dtgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dtgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgsja_$descriptor() {
        return stgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stgsja_$handle() {
        return stgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stgsja_$address() {
        return stgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = stgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsja_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgsja_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgsja_$descriptor() {
        return ztgsja_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztgsja_$handle() {
        return ztgsja_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztgsja_$address() {
        return ztgsja_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsja_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, const int *k, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, int *ncycle, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztgsja_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment ncycle, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = ztgsja_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsja_", jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, k, l, A, lda, B, ldb, tola, tolb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, ncycle, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctgsna_$descriptor() {
        return ctgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctgsna_$handle() {
        return ctgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctgsna_$address() {
        return ctgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, _Complex float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ctgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ctgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtgsna_$descriptor() {
        return dtgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtgsna_$handle() {
        return dtgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtgsna_$address() {
        return dtgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsna_(const char *job, const char *howmny, const int *select, const int *n, const double *A, const int *lda, const double *B, const int *ldb, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dtgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = dtgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stgsna_$descriptor() {
        return stgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stgsna_$handle() {
        return stgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stgsna_$address() {
        return stgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsna_(const char *job, const char *howmny, const int *select, const int *n, const float *A, const int *lda, const float *B, const int *ldb, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *DIF, const int *mm, int *m, float *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void stgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = stgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztgsna_$descriptor() {
        return ztgsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztgsna_$handle() {
        return ztgsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztgsna_$address() {
        return ztgsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *DIF, const int *mm, int *m, _Complex double *work, const int *lwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void ztgsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment DIF, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x20, long x21) {
        var mh$ = ztgsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsna_", job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
            }
            mh$.invokeExact(job, howmny, select, n, A, lda, B, ldb, VL, ldvl, VR, ldvr, S, DIF, mm, m, work, lwork, iwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctgsyl_$descriptor() {
        return ctgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ctgsyl_$handle() {
        return ctgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ctgsyl_$address() {
        return ctgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, const _Complex float *D, const int *ldd, const _Complex float *E, const int *lde, _Complex float *F, const int *ldf, float *dif, float *scale, _Complex float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void ctgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = ctgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtgsyl_$descriptor() {
        return dtgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dtgsyl_$handle() {
        return dtgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dtgsyl_$address() {
        return dtgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, const double *D, const int *ldd, const double *E, const int *lde, double *F, const int *ldf, double *dif, double *scale, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void dtgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = dtgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor stgsyl_$descriptor() {
        return stgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle stgsyl_$handle() {
        return stgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment stgsyl_$address() {
        return stgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, const float *D, const int *ldd, const float *E, const int *lde, float *F, const int *ldf, float *dif, float *scale, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void stgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = stgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztgsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztgsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztgsyl_$descriptor() {
        return ztgsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle ztgsyl_$handle() {
        return ztgsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment ztgsyl_$address() {
        return ztgsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztgsyl_(const char *trans, const int *ijob, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, const _Complex double *D, const int *ldd, const _Complex double *E, const int *lde, _Complex double *F, const int *ldf, double *dif, double *scale, _Complex double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void ztgsyl_(MemorySegment trans, MemorySegment ijob, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment D, MemorySegment ldd, MemorySegment E, MemorySegment lde, MemorySegment F, MemorySegment ldf, MemorySegment dif, MemorySegment scale, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x22) {
        var mh$ = ztgsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztgsyl_", trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
            }
            mh$.invokeExact(trans, ijob, m, n, A, lda, B, ldb, C, ldc, D, ldd, E, lde, F, ldf, dif, scale, work, lwork, iwork, info, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpcon_$descriptor() {
        return ctpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctpcon_$handle() {
        return ctpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctpcon_$address() {
        return ctpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *AP, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ctpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpcon_", norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpcon_$descriptor() {
        return dtpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtpcon_$handle() {
        return dtpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtpcon_$address() {
        return dtpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *AP, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = dtpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpcon_", norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpcon_$descriptor() {
        return stpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stpcon_$handle() {
        return stpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stpcon_$address() {
        return stpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *AP, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = stpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcon_", norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, iwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpcon_$descriptor() {
        return ztpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztpcon_$handle() {
        return ztpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztpcon_$address() {
        return ztpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *AP, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztpcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ztpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpcon_", norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
            }
            mh$.invokeExact(norm, uplo, diag, n, AP, rcond, work, rwork, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor ctplqt_$descriptor() {
        return ctplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle ctplqt_$handle() {
        return ctplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment ctplqt_$address() {
        return ctplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void ctplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ctplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dtplqt_$descriptor() {
        return dtplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dtplqt_$handle() {
        return dtplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dtplqt_$address() {
        return dtplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtplqt_(const int *m, const int *n, const int *l, const int *mb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dtplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dtplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor stplqt_$descriptor() {
        return stplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle stplqt_$handle() {
        return stplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment stplqt_$address() {
        return stplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stplqt_(const int *m, const int *n, const int *l, const int *mb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void stplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = stplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztplqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztplqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor ztplqt_$descriptor() {
        return ztplqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle ztplqt_$handle() {
        return ztplqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment ztplqt_$address() {
        return ztplqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztplqt_(const int *m, const int *n, const int *l, const int *mb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void ztplqt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment mb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ztplqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztplqt_", m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, mb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ctplqt2_$descriptor() {
        return ctplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ctplqt2_$handle() {
        return ctplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ctplqt2_$address() {
        return ctplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctplqt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void ctplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ctplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dtplqt2_$descriptor() {
        return dtplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dtplqt2_$handle() {
        return dtplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dtplqt2_$address() {
        return dtplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtplqt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static void dtplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dtplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor stplqt2_$descriptor() {
        return stplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle stplqt2_$handle() {
        return stplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment stplqt2_$address() {
        return stplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stplqt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static void stplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = stplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztplqt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztplqt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ztplqt2_$descriptor() {
        return ztplqt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ztplqt2_$handle() {
        return ztplqt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ztplqt2_$address() {
        return ztplqt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztplqt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void ztplqt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ztplqt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztplqt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpmlqt_$descriptor() {
        return ctpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpmlqt_$handle() {
        return ctpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpmlqt_$address() {
        return ctpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void ctpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ctpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpmlqt_$descriptor() {
        return dtpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpmlqt_$handle() {
        return dtpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpmlqt_$address() {
        return dtpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = dtpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpmlqt_$descriptor() {
        return stpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpmlqt_$handle() {
        return stpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpmlqt_$address() {
        return stpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = stpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpmlqt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpmlqt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpmlqt_$descriptor() {
        return ztpmlqt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpmlqt_$handle() {
        return ztpmlqt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpmlqt_$address() {
        return ztpmlqt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpmlqt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *mb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void ztpmlqt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment mb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ztpmlqt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpmlqt_", side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, mb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpmqrt_$descriptor() {
        return ctpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpmqrt_$handle() {
        return ctpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpmqrt_$address() {
        return ctpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void ctpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ctpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpmqrt_$descriptor() {
        return dtpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpmqrt_$handle() {
        return dtpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpmqrt_$address() {
        return dtpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = dtpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpmqrt_$descriptor() {
        return stpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpmqrt_$handle() {
        return stpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpmqrt_$address() {
        return stpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, int *info, size_t, size_t)
     * }
     */
    public static void stpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = stpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpmqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpmqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpmqrt_$descriptor() {
        return ztpmqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpmqrt_$handle() {
        return ztpmqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpmqrt_$address() {
        return ztpmqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpmqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void ztpmqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x17, long x18) {
        var mh$ = ztpmqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpmqrt_", side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
            }
            mh$.invokeExact(side, trans, m, n, k, l, nb, V, ldv, T, ldt, A, lda, B, ldb, work, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor ctpqrt_$descriptor() {
        return ctpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle ctpqrt_$handle() {
        return ctpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment ctpqrt_$address() {
        return ctpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void ctpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ctpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dtpqrt_$descriptor() {
        return dtpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dtpqrt_$handle() {
        return dtpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dtpqrt_$address() {
        return dtpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpqrt_(const int *m, const int *n, const int *l, const int *nb, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dtpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dtpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor stpqrt_$descriptor() {
        return stpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle stpqrt_$handle() {
        return stpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment stpqrt_$address() {
        return stpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpqrt_(const int *m, const int *n, const int *l, const int *nb, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void stpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = stpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor ztpqrt_$descriptor() {
        return ztpqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle ztpqrt_$handle() {
        return ztpqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment ztpqrt_$address() {
        return ztpqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpqrt_(const int *m, const int *n, const int *l, const int *nb, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void ztpqrt_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = ztpqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpqrt_", m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, l, nb, A, lda, B, ldb, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ctpqrt2_$descriptor() {
        return ctpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ctpqrt2_$handle() {
        return ctpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ctpqrt2_$address() {
        return ctpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpqrt2_(const int *m, const int *n, const int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void ctpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ctpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dtpqrt2_$descriptor() {
        return dtpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dtpqrt2_$handle() {
        return dtpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dtpqrt2_$address() {
        return dtpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpqrt2_(const int *m, const int *n, const int *l, double *A, const int *lda, double *B, const int *ldb, double *T, const int *ldt, int *info)
     * }
     */
    public static void dtpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dtpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor stpqrt2_$descriptor() {
        return stpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle stpqrt2_$handle() {
        return stpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment stpqrt2_$address() {
        return stpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpqrt2_(const int *m, const int *n, const int *l, float *A, const int *lda, float *B, const int *ldb, float *T, const int *ldt, int *info)
     * }
     */
    public static void stpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = stpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor ztpqrt2_$descriptor() {
        return ztpqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle ztpqrt2_$handle() {
        return ztpqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment ztpqrt2_$address() {
        return ztpqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpqrt2_(const int *m, const int *n, const int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void ztpqrt2_(MemorySegment m, MemorySegment n, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = ztpqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpqrt2_", m, n, l, A, lda, B, ldb, T, ldt, info);
            }
            mh$.invokeExact(m, n, l, A, lda, B, ldb, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctprfb_$descriptor() {
        return ctprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctprfb_$handle() {
        return ctprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctprfb_$address() {
        return ctprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ctprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = ctprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtprfb_$descriptor() {
        return dtprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtprfb_$handle() {
        return dtprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtprfb_$address() {
        return dtprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const double *V, const int *ldv, const double *T, const int *ldt, double *A, const int *lda, double *B, const int *ldb, double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dtprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = dtprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stprfb_$descriptor() {
        return stprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stprfb_$handle() {
        return stprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stprfb_$address() {
        return stprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const float *V, const int *ldv, const float *T, const int *ldt, float *A, const int *lda, float *B, const int *ldb, float *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void stprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = stprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztprfb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztprfb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztprfb_$descriptor() {
        return ztprfb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztprfb_$handle() {
        return ztprfb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztprfb_$address() {
        return ztprfb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztprfb_(const char *side, const char *trans, const char *direct, const char *storev, const int *m, const int *n, const int *k, const int *l, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *ldwork, size_t, size_t, size_t, size_t)
     * }
     */
    public static void ztprfb_(MemorySegment side, MemorySegment trans, MemorySegment direct, MemorySegment storev, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment ldwork, long x18, long x19, long x20, long x21) {
        var mh$ = ztprfb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztprfb_", side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
            }
            mh$.invokeExact(side, trans, direct, storev, m, n, k, l, V, ldv, T, ldt, A, lda, B, ldb, work, ldwork, x18, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctprfs_$descriptor() {
        return ctprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctprfs_$handle() {
        return ctprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctprfs_$address() {
        return ctprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = ctprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtprfs_$descriptor() {
        return dtprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtprfs_$handle() {
        return dtprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtprfs_$address() {
        return dtprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = dtprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stprfs_$descriptor() {
        return stprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stprfs_$handle() {
        return stprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stprfs_$address() {
        return stprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = stprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, iwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztprfs_$descriptor() {
        return ztprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztprfs_$handle() {
        return ztprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztprfs_$address() {
        return ztprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztprfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztprfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16, long x17) {
        var mh$ = ztprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztprfs_", uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctptri_$descriptor() {
        return ctptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctptri_$handle() {
        return ctptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctptri_$address() {
        return ctptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctptri_(const char *uplo, const char *diag, const int *n, _Complex float *AP, int *info, size_t, size_t)
     * }
     */
    public static void ctptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = ctptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtptri_$descriptor() {
        return dtptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtptri_$handle() {
        return dtptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtptri_$address() {
        return dtptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtptri_(const char *uplo, const char *diag, const int *n, double *AP, int *info, size_t, size_t)
     * }
     */
    public static void dtptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = dtptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stptri_$descriptor() {
        return stptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stptri_$handle() {
        return stptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stptri_$address() {
        return stptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stptri_(const char *uplo, const char *diag, const int *n, float *AP, int *info, size_t, size_t)
     * }
     */
    public static void stptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = stptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztptri_$descriptor() {
        return ztptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztptri_$handle() {
        return ztptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztptri_$address() {
        return ztptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztptri_(const char *uplo, const char *diag, const int *n, _Complex double *AP, int *info, size_t, size_t)
     * }
     */
    public static void ztptri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment AP, MemorySegment info, long x5, long x6) {
        var mh$ = ztptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptri_", uplo, diag, n, AP, info, x5, x6);
            }
            mh$.invokeExact(uplo, diag, n, AP, info, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctptrs_$descriptor() {
        return ctptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctptrs_$handle() {
        return ctptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctptrs_$address() {
        return ctptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ctptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtptrs_$descriptor() {
        return dtptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtptrs_$handle() {
        return dtptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtptrs_$address() {
        return dtptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *AP, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = dtptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stptrs_$descriptor() {
        return stptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle stptrs_$handle() {
        return stptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment stptrs_$address() {
        return stptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *AP, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void stptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = stptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztptrs_$descriptor() {
        return ztptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztptrs_$handle() {
        return ztptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztptrs_$address() {
        return ztptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztptrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztptrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9, long x10, long x11) {
        var mh$ = ztptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztptrs_", uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, AP, B, ldb, info, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctpttf_$descriptor() {
        return ctpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctpttf_$handle() {
        return ctpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctpttf_$address() {
        return ctpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpttf_(const char *transr, const char *uplo, const int *n, const _Complex float *AP, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ctpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = ctpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtpttf_$descriptor() {
        return dtpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtpttf_$handle() {
        return dtpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtpttf_$address() {
        return dtpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpttf_(const char *transr, const char *uplo, const int *n, const double *AP, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void dtpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = dtpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor stpttf_$descriptor() {
        return stpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle stpttf_$handle() {
        return stpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment stpttf_$address() {
        return stpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpttf_(const char *transr, const char *uplo, const int *n, const float *AP, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void stpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = stpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztpttf_$descriptor() {
        return ztpttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztpttf_$handle() {
        return ztpttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztpttf_$address() {
        return ztpttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpttf_(const char *transr, const char *uplo, const int *n, const _Complex double *AP, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ztpttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ARF, MemorySegment info, long x6, long x7) {
        var mh$ = ztpttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttf_", transr, uplo, n, AP, ARF, info, x6, x7);
            }
            mh$.invokeExact(transr, uplo, n, AP, ARF, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctpttr_$descriptor() {
        return ctpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle ctpttr_$handle() {
        return ctpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment ctpttr_$address() {
        return ctpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctpttr_(const char *uplo, const int *n, const _Complex float *AP, _Complex float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void ctpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = ctpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtpttr_$descriptor() {
        return dtpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle dtpttr_$handle() {
        return dtpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment dtpttr_$address() {
        return dtpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtpttr_(const char *uplo, const int *n, const double *AP, double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void dtpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = dtpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor stpttr_$descriptor() {
        return stpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle stpttr_$handle() {
        return stpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment stpttr_$address() {
        return stpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stpttr_(const char *uplo, const int *n, const float *AP, float *A, const int *lda, int *info, size_t)
     * }
     */
    public static void stpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = stpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztpttr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztpttr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztpttr_$descriptor() {
        return ztpttr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MethodHandle ztpttr_$handle() {
        return ztpttr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static MemorySegment ztpttr_$address() {
        return ztpttr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztpttr_(const char *uplo, const int *n, const _Complex double *AP, _Complex double *A, const int *lda, int *info, size_t)
     * }
     */
    public static void ztpttr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment A, MemorySegment lda, MemorySegment info, long x6) {
        var mh$ = ztpttr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztpttr_", uplo, n, AP, A, lda, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, A, lda, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrcon_$descriptor() {
        return ctrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrcon_$handle() {
        return ctrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrcon_$address() {
        return ctrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex float *A, const int *lda, float *rcond, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ctrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrcon_", norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrcon_$descriptor() {
        return dtrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrcon_$handle() {
        return dtrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrcon_$address() {
        return dtrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const double *A, const int *lda, double *rcond, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = dtrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrcon_", norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strcon_$descriptor() {
        return strcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strcon_$handle() {
        return strcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strcon_$address() {
        return strcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strcon_(const char *norm, const char *uplo, const char *diag, const int *n, const float *A, const int *lda, float *rcond, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = strcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcon_", norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, iwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrcon_$descriptor() {
        return ztrcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrcon_$handle() {
        return ztrcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrcon_$address() {
        return ztrcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrcon_(const char *norm, const char *uplo, const char *diag, const int *n, const _Complex double *A, const int *lda, double *rcond, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrcon_(MemorySegment norm, MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ztrcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrcon_", norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
            }
            mh$.invokeExact(norm, uplo, diag, n, A, lda, rcond, work, rwork, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrevc_$descriptor() {
        return ctrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrevc_$handle() {
        return ctrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrevc_$address() {
        return ctrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = ctrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrevc_$descriptor() {
        return dtrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrevc_$handle() {
        return dtrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrevc_$address() {
        return dtrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrevc_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dtrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dtrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strevc_$descriptor() {
        return strevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strevc_$handle() {
        return strevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strevc_$address() {
        return strevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strevc_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *info, size_t, size_t)
     * }
     */
    public static void strevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = strevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrevc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrevc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrevc_$descriptor() {
        return ztrevc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrevc_$handle() {
        return ztrevc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrevc_$address() {
        return ztrevc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrevc_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrevc_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = ztrevc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrevc_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrevc3_$descriptor() {
        return ctrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrevc3_$handle() {
        return ctrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrevc3_$address() {
        return ctrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x17, long x18) {
        var mh$ = ctrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrevc3_$descriptor() {
        return dtrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrevc3_$handle() {
        return dtrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrevc3_$address() {
        return dtrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrevc3_(const char *side, const char *howmny, int *select, const int *n, const double *T, const int *ldt, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = dtrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strevc3_$descriptor() {
        return strevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strevc3_$handle() {
        return strevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strevc3_$address() {
        return strevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strevc3_(const char *side, const char *howmny, int *select, const int *n, const float *T, const int *ldt, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void strevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = strevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrevc3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrevc3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrevc3_$descriptor() {
        return ztrevc3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrevc3_$handle() {
        return ztrevc3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrevc3_$address() {
        return ztrevc3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrevc3_(const char *side, const char *howmny, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrevc3_(MemorySegment side, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x17, long x18) {
        var mh$ = ztrevc3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrevc3_", side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
            }
            mh$.invokeExact(side, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, mm, m, work, lwork, rwork, lrwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctrexc_$descriptor() {
        return ctrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MethodHandle ctrexc_$handle() {
        return ctrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MemorySegment ctrexc_$address() {
        return ctrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrexc_(const char *compq, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static void ctrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment info, long x9) {
        var mh$ = ctrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtrexc_$descriptor() {
        return dtrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dtrexc_$handle() {
        return dtrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dtrexc_$address() {
        return dtrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrexc_(const char *compq, const int *n, double *T, const int *ldt, double *Q, const int *ldq, int *ifst, int *ilst, double *work, int *info, size_t)
     * }
     */
    public static void dtrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = dtrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor strexc_$descriptor() {
        return strexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle strexc_$handle() {
        return strexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment strexc_$address() {
        return strexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strexc_(const char *compq, const int *n, float *T, const int *ldt, float *Q, const int *ldq, int *ifst, int *ilst, float *work, int *info, size_t)
     * }
     */
    public static void strexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = strexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrexc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrexc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztrexc_$descriptor() {
        return ztrexc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MethodHandle ztrexc_$handle() {
        return ztrexc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static MemorySegment ztrexc_$address() {
        return ztrexc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrexc_(const char *compq, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, const int *ifst, const int *ilst, int *info, size_t)
     * }
     */
    public static void ztrexc_(MemorySegment compq, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment ifst, MemorySegment ilst, MemorySegment info, long x9) {
        var mh$ = ztrexc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrexc_", compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
            }
            mh$.invokeExact(compq, n, T, ldt, Q, ldq, ifst, ilst, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrrfs_$descriptor() {
        return ctrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrrfs_$handle() {
        return ctrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrrfs_$address() {
        return ctrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, const _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = ctrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrrfs_$descriptor() {
        return dtrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrrfs_$handle() {
        return dtrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrrfs_$address() {
        return dtrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, const double *B, const int *ldb, const double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = dtrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strrfs_$descriptor() {
        return strrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strrfs_$handle() {
        return strrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strrfs_$address() {
        return strrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, const float *B, const int *ldb, const float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = strrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, iwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrrfs_$descriptor() {
        return ztrrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrrfs_$handle() {
        return ztrrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrrfs_$address() {
        return ztrrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrrfs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, const _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrrfs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = ztrrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrrfs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, X, ldx, ferr, berr, work, rwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsen_$descriptor() {
        return ctrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsen_$handle() {
        return ctrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsen_$address() {
        return ctrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex float *T, const int *ldt, _Complex float *Q, const int *ldq, _Complex float *W, int *m, float *s, float *sep, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment W, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = ctrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsen_", job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsen_$descriptor() {
        return dtrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsen_$handle() {
        return dtrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsen_$address() {
        return dtrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsen_(const char *job, const char *compq, const int *select, const int *n, double *T, const int *ldt, double *Q, const int *ldq, double *WR, double *WI, int *m, double *s, double *sep, double *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment WR, MemorySegment WI, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x18, long x19) {
        var mh$ = dtrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsen_", job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsen_$descriptor() {
        return strsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsen_$handle() {
        return strsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsen_$address() {
        return strsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsen_(const char *job, const char *compq, const int *select, const int *n, float *T, const int *ldt, float *Q, const int *ldq, float *WR, float *WI, int *m, float *s, float *sep, float *work, const int *lwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void strsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment WR, MemorySegment WI, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x18, long x19) {
        var mh$ = strsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsen_", job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, WR, WI, m, s, sep, work, lwork, iwork, liwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsen_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrsen_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsen_$descriptor() {
        return ztrsen_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsen_$handle() {
        return ztrsen_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsen_$address() {
        return ztrsen_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsen_(const char *job, const char *compq, const int *select, const int *n, _Complex double *T, const int *ldt, _Complex double *Q, const int *ldq, _Complex double *W, int *m, double *s, double *sep, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrsen_(MemorySegment job, MemorySegment compq, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment Q, MemorySegment ldq, MemorySegment W, MemorySegment m, MemorySegment s, MemorySegment sep, MemorySegment work, MemorySegment lwork, MemorySegment info, long x15, long x16) {
        var mh$ = ztrsen_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsen_", job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
            }
            mh$.invokeExact(job, compq, select, n, T, ldt, Q, ldq, W, m, s, sep, work, lwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsna_$descriptor() {
        return ctrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsna_$handle() {
        return ctrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsna_$address() {
        return ctrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex float *T, const int *ldt, const _Complex float *VL, const int *ldvl, const _Complex float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, _Complex float *work, const int *ldwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ctrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment rwork, MemorySegment info, long x18, long x19) {
        var mh$ = ctrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsna_$descriptor() {
        return dtrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsna_$handle() {
        return dtrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsna_$address() {
        return dtrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsna_(const char *job, const char *howmny, const int *select, const int *n, const double *T, const int *ldt, const double *VL, const int *ldvl, const double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, double *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dtrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = dtrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsna_$descriptor() {
        return strsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsna_$handle() {
        return strsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsna_$address() {
        return strsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsna_(const char *job, const char *howmny, const int *select, const int *n, const float *T, const int *ldt, const float *VL, const int *ldvl, const float *VR, const int *ldvr, float *S, float *SEP, const int *mm, int *m, float *work, const int *ldwork, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void strsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment iwork, MemorySegment info, long x18, long x19) {
        var mh$ = strsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, iwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrsna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsna_$descriptor() {
        return ztrsna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsna_$handle() {
        return ztrsna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsna_$address() {
        return ztrsna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsna_(const char *job, const char *howmny, const int *select, const int *n, const _Complex double *T, const int *ldt, const _Complex double *VL, const int *ldvl, const _Complex double *VR, const int *ldvr, double *S, double *SEP, const int *mm, int *m, _Complex double *work, const int *ldwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void ztrsna_(MemorySegment job, MemorySegment howmny, MemorySegment select, MemorySegment n, MemorySegment T, MemorySegment ldt, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment S, MemorySegment SEP, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment ldwork, MemorySegment rwork, MemorySegment info, long x18, long x19) {
        var mh$ = ztrsna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsna_", job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
            }
            mh$.invokeExact(job, howmny, select, n, T, ldt, VL, ldvl, VR, ldvr, S, SEP, mm, m, work, ldwork, rwork, info, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrsyl_$descriptor() {
        return ctrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrsyl_$handle() {
        return ctrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrsyl_$address() {
        return ctrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, _Complex float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static void ctrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = ctrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrsyl_$descriptor() {
        return dtrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrsyl_$handle() {
        return dtrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrsyl_$address() {
        return dtrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const double *A, const int *lda, const double *B, const int *ldb, double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static void dtrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = dtrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strsyl_$descriptor() {
        return strsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strsyl_$handle() {
        return strsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strsyl_$address() {
        return strsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const float *A, const int *lda, const float *B, const int *ldb, float *C, const int *ldc, float *scale, int *info, size_t, size_t)
     * }
     */
    public static void strsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = strsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrsyl_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrsyl_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrsyl_$descriptor() {
        return ztrsyl_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrsyl_$handle() {
        return ztrsyl_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrsyl_$address() {
        return ztrsyl_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrsyl_(const char *trana, const char *tranb, const int *isgn, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, _Complex double *C, const int *ldc, double *scale, int *info, size_t, size_t)
     * }
     */
    public static void ztrsyl_(MemorySegment trana, MemorySegment tranb, MemorySegment isgn, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment scale, MemorySegment info, long x13, long x14) {
        var mh$ = ztrsyl_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrsyl_", trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
            }
            mh$.invokeExact(trana, tranb, isgn, m, n, A, lda, B, ldb, C, ldc, scale, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrtri_$descriptor() {
        return ctrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrtri_$handle() {
        return ctrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrtri_$address() {
        return ctrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrtri_(const char *uplo, const char *diag, const int *n, _Complex float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ctrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = ctrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrtri_$descriptor() {
        return dtrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrtri_$handle() {
        return dtrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrtri_$address() {
        return dtrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrtri_(const char *uplo, const char *diag, const int *n, double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void dtrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = dtrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strtri_$descriptor() {
        return strtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strtri_$handle() {
        return strtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strtri_$address() {
        return strtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strtri_(const char *uplo, const char *diag, const int *n, float *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void strtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = strtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrtri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrtri_$descriptor() {
        return ztrtri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrtri_$handle() {
        return ztrtri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrtri_$address() {
        return ztrtri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrtri_(const char *uplo, const char *diag, const int *n, _Complex double *A, const int *lda, int *info, size_t, size_t)
     * }
     */
    public static void ztrtri_(MemorySegment uplo, MemorySegment diag, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment info, long x6, long x7) {
        var mh$ = ztrtri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtri_", uplo, diag, n, A, lda, info, x6, x7);
            }
            mh$.invokeExact(uplo, diag, n, A, lda, info, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrtrs_$descriptor() {
        return ctrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ctrtrs_$handle() {
        return ctrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ctrtrs_$address() {
        return ctrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ctrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ctrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrtrs_$descriptor() {
        return dtrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dtrtrs_$handle() {
        return dtrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dtrtrs_$address() {
        return dtrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const double *A, const int *lda, double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dtrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = dtrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strtrs_$descriptor() {
        return strtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle strtrs_$handle() {
        return strtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment strtrs_$address() {
        return strtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const float *A, const int *lda, float *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void strtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = strtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrtrs_$descriptor() {
        return ztrtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle ztrtrs_$handle() {
        return ztrtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment ztrtrs_$address() {
        return ztrtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrtrs_(const char *uplo, const char *trans, const char *diag, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *info, size_t, size_t, size_t)
     * }
     */
    public static void ztrtrs_(MemorySegment uplo, MemorySegment trans, MemorySegment diag, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10, long x11, long x12) {
        var mh$ = ztrtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrtrs_", uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
            }
            mh$.invokeExact(uplo, trans, diag, n, nrhs, A, lda, B, ldb, info, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ctrttf_$descriptor() {
        return ctrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ctrttf_$handle() {
        return ctrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ctrttf_$address() {
        return ctrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrttf_(const char *transr, const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ctrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = ctrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dtrttf_$descriptor() {
        return dtrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dtrttf_$handle() {
        return dtrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dtrttf_$address() {
        return dtrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrttf_(const char *transr, const char *uplo, const int *n, const double *A, const int *lda, double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void dtrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = dtrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor strttf_$descriptor() {
        return strttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle strttf_$handle() {
        return strttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment strttf_$address() {
        return strttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strttf_(const char *transr, const char *uplo, const int *n, const float *A, const int *lda, float *ARF, int *info, size_t, size_t)
     * }
     */
    public static void strttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = strttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrttf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor ztrttf_$descriptor() {
        return ztrttf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle ztrttf_$handle() {
        return ztrttf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment ztrttf_$address() {
        return ztrttf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrttf_(const char *transr, const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *ARF, int *info, size_t, size_t)
     * }
     */
    public static void ztrttf_(MemorySegment transr, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ARF, MemorySegment info, long x7, long x8) {
        var mh$ = ztrttf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttf_", transr, uplo, n, A, lda, ARF, info, x7, x8);
            }
            mh$.invokeExact(transr, uplo, n, A, lda, ARF, info, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ctrttp_$descriptor() {
        return ctrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle ctrttp_$handle() {
        return ctrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment ctrttp_$address() {
        return ctrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctrttp_(const char *uplo, const int *n, const _Complex float *A, const int *lda, _Complex float *AP, int *info, size_t)
     * }
     */
    public static void ctrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = ctrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dtrttp_$descriptor() {
        return dtrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle dtrttp_$handle() {
        return dtrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment dtrttp_$address() {
        return dtrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtrttp_(const char *uplo, const int *n, const double *A, const int *lda, double *AP, int *info, size_t)
     * }
     */
    public static void dtrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = dtrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor strttp_$descriptor() {
        return strttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static MethodHandle strttp_$handle() {
        return strttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static MemorySegment strttp_$address() {
        return strttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strttp_(const char *uplo, const int *n, const float *A, const int *lda, float *AP, int *info, size_t)
     * }
     */
    public static void strttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = strttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztrttp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztrttp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ztrttp_$descriptor() {
        return ztrttp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MethodHandle ztrttp_$handle() {
        return ztrttp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static MemorySegment ztrttp_$address() {
        return ztrttp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztrttp_(const char *uplo, const int *n, const _Complex double *A, const int *lda, _Complex double *AP, int *info, size_t)
     * }
     */
    public static void ztrttp_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment AP, MemorySegment info, long x6) {
        var mh$ = ztrttp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztrttp_", uplo, n, A, lda, AP, info, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, AP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor ctzrzf_$descriptor() {
        return ctzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle ctzrzf_$handle() {
        return ctzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment ctzrzf_$address() {
        return ctzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ctzrzf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void ctzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = ctzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dtzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dtzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dtzrzf_$descriptor() {
        return dtzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dtzrzf_$handle() {
        return dtzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dtzrzf_$address() {
        return dtzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dtzrzf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dtzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dtzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dtzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("stzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor stzrzf_$descriptor() {
        return stzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle stzrzf_$handle() {
        return stzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment stzrzf_$address() {
        return stzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void stzrzf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void stzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = stzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ztzrzf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ztzrzf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor ztzrzf_$descriptor() {
        return ztzrzf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle ztzrzf_$handle() {
        return ztzrzf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment ztzrzf_$address() {
        return ztzrzf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ztzrzf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void ztzrzf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = ztzrzf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ztzrzf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunbdb_$descriptor() {
        return cunbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunbdb_$handle() {
        return cunbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunbdb_$address() {
        return cunbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, float *phi, _Complex float *TAUP1, _Complex float *TAUP2, _Complex float *TAUQ1, _Complex float *TAUQ2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = cunbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunbdb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunbdb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunbdb_$descriptor() {
        return zunbdb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunbdb_$handle() {
        return zunbdb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunbdb_$address() {
        return zunbdb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunbdb_(const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, double *phi, _Complex double *TAUP1, _Complex double *TAUP2, _Complex double *TAUQ1, _Complex double *TAUQ2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunbdb_(MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment phi, MemorySegment TAUP1, MemorySegment TAUP2, MemorySegment TAUQ1, MemorySegment TAUQ2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x22, long x23) {
        var mh$ = zunbdb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunbdb_", trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
            }
            mh$.invokeExact(trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, phi, TAUP1, TAUP2, TAUQ1, TAUQ2, work, lwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cuncsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cuncsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cuncsd_$descriptor() {
        return cuncsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cuncsd_$handle() {
        return cuncsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cuncsd_$address() {
        return cuncsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X12, const int *ldx12, _Complex float *X21, const int *ldx21, _Complex float *X22, const int *ldx22, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cuncsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x32, long x33, long x34, long x35, long x36, long x37) {
        var mh$ = cuncsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cuncsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zuncsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zuncsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zuncsd_$descriptor() {
        return zuncsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zuncsd_$handle() {
        return zuncsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zuncsd_$address() {
        return zuncsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zuncsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const char *signs, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X12, const int *ldx12, _Complex double *X21, const int *ldx21, _Complex double *X22, const int *ldx22, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zuncsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment signs, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X12, MemorySegment ldx12, MemorySegment X21, MemorySegment ldx21, MemorySegment X22, MemorySegment ldx22, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x32, long x33, long x34, long x35, long x36, long x37) {
        var mh$ = zuncsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zuncsd_", jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, signs, m, p, q, X11, ldx11, X12, ldx12, X21, ldx21, X22, ldx22, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, work, lwork, rwork, lrwork, iwork, info, x32, x33, x34, x35, x36, x37);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cuncsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cuncsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cuncsd2by1_$descriptor() {
        return cuncsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cuncsd2by1_$handle() {
        return cuncsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cuncsd2by1_$address() {
        return cuncsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex float *X11, const int *ldx11, _Complex float *X21, const int *ldx21, float *theta, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cuncsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cuncsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cuncsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zuncsd2by1_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zuncsd2by1_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zuncsd2by1_$descriptor() {
        return zuncsd2by1_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zuncsd2by1_$handle() {
        return zuncsd2by1_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zuncsd2by1_$address() {
        return zuncsd2by1_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zuncsd2by1_(const char *jobu1, const char *jobu2, const char *jobv1t, const int *m, const int *p, const int *q, _Complex double *X11, const int *ldx11, _Complex double *X21, const int *ldx21, double *theta, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zuncsd2by1_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment X11, MemorySegment ldx11, MemorySegment X21, MemorySegment ldx21, MemorySegment theta, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zuncsd2by1_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zuncsd2by1_", jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, m, p, q, X11, ldx11, X21, ldx21, theta, U1, ldu1, U2, ldu2, V1T, ldv1t, work, lwork, rwork, lrwork, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cungbr_$descriptor() {
        return cungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cungbr_$handle() {
        return cungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cungbr_$address() {
        return cungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cungbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = cungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zungbr_$descriptor() {
        return zungbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zungbr_$handle() {
        return zungbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zungbr_$address() {
        return zungbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungbr_(const char *vect, const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zungbr_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = zungbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungbr_", vect, m, n, k, A, lda, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(vect, m, n, k, A, lda, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cunghr_$descriptor() {
        return cunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cunghr_$handle() {
        return cunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cunghr_$address() {
        return cunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunghr_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cunghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunghr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunghr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zunghr_$descriptor() {
        return zunghr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zunghr_$handle() {
        return zunghr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zunghr_$address() {
        return zunghr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunghr_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zunghr_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zunghr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunghr_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cunglq_$descriptor() {
        return cunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cunglq_$handle() {
        return cunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cunglq_$address() {
        return cunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunglq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cunglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunglq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunglq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zunglq_$descriptor() {
        return zunglq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zunglq_$handle() {
        return zunglq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zunglq_$address() {
        return zunglq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunglq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zunglq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zunglq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunglq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungql_$descriptor() {
        return cungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungql_$handle() {
        return cungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungql_$address() {
        return cungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungql_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungql_$descriptor() {
        return zungql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungql_$handle() {
        return zungql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungql_$address() {
        return zungql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungql_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungql_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungql_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungqr_$descriptor() {
        return cungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungqr_$handle() {
        return cungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungqr_$address() {
        return cungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungqr_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungqr_$descriptor() {
        return zungqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungqr_$handle() {
        return zungqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungqr_$address() {
        return zungqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungqr_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungqr_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungqr_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungrq_$descriptor() {
        return cungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungrq_$handle() {
        return cungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungrq_$address() {
        return cungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungrq_(const int *m, const int *n, const int *k, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungrq_$descriptor() {
        return zungrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungrq_$handle() {
        return zungrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungrq_$address() {
        return zungrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungrq_(const int *m, const int *n, const int *k, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungrq_(MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungrq_", m, n, k, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, k, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cungtr_$descriptor() {
        return cungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cungtr_$handle() {
        return cungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cungtr_$address() {
        return cungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungtr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cungtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = cungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zungtr_$descriptor() {
        return zungtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zungtr_$handle() {
        return zungtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zungtr_$address() {
        return zungtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungtr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zungtr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zungtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungtr_", uplo, n, A, lda, tau, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, tau, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cungtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cungtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cungtsqr_row_$descriptor() {
        return cungtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cungtsqr_row_$handle() {
        return cungtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cungtsqr_row_$address() {
        return cungtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex float *A, const int *lda, const _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cungtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cungtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cungtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zungtsqr_row_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zungtsqr_row_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zungtsqr_row_$descriptor() {
        return zungtsqr_row_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zungtsqr_row_$handle() {
        return zungtsqr_row_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zungtsqr_row_$address() {
        return zungtsqr_row_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zungtsqr_row_(const int *m, const int *n, const int *mb, const int *nb, _Complex double *A, const int *lda, const _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zungtsqr_row_(MemorySegment m, MemorySegment n, MemorySegment mb, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zungtsqr_row_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zungtsqr_row_", m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb, nb, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmbr_$descriptor() {
        return cunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cunmbr_$handle() {
        return cunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cunmbr_$address() {
        return cunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cunmbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = cunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmbr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmbr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmbr_$descriptor() {
        return zunmbr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zunmbr_$handle() {
        return zunmbr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zunmbr_$address() {
        return zunmbr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmbr_(const char *vect, const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zunmbr_(MemorySegment vect, MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = zunmbr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmbr_", vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(vect, side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmhr_$descriptor() {
        return cunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmhr_$handle() {
        return cunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmhr_$address() {
        return cunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmhr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmhr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmhr_$descriptor() {
        return zunmhr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmhr_$handle() {
        return zunmhr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmhr_$address() {
        return zunmhr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmhr_(const char *side, const char *trans, const int *m, const int *n, const int *ilo, const int *ihi, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmhr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zunmhr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmhr_", side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, ilo, ihi, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmlq_$descriptor() {
        return cunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmlq_$handle() {
        return cunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmlq_$address() {
        return cunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmlq_$descriptor() {
        return zunmlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmlq_$handle() {
        return zunmlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmlq_$address() {
        return zunmlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmlq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmql_$descriptor() {
        return cunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmql_$handle() {
        return cunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmql_$address() {
        return cunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmql_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmql_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmql_$descriptor() {
        return zunmql_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmql_$handle() {
        return zunmql_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmql_$address() {
        return zunmql_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmql_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmql_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmql_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmql_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmqr_$descriptor() {
        return cunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmqr_$handle() {
        return cunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmqr_$address() {
        return cunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmqr_$descriptor() {
        return zunmqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmqr_$handle() {
        return zunmqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmqr_$address() {
        return zunmqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmqr_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmrq_$descriptor() {
        return cunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmrq_$handle() {
        return cunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmrq_$address() {
        return cunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = cunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmrq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmrq_$descriptor() {
        return zunmrq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmrq_$handle() {
        return zunmrq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmrq_$address() {
        return zunmrq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmrq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmrq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zunmrq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrq_", side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, tau, C, ldc, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmrz_$descriptor() {
        return cunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cunmrz_$handle() {
        return cunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cunmrz_$address() {
        return cunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cunmrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmrz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmrz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmrz_$descriptor() {
        return zunmrz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zunmrz_$handle() {
        return zunmrz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zunmrz_$address() {
        return zunmrz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmrz_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *l, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zunmrz_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zunmrz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmrz_", side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, l, A, lda, tau, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cunmtr_$descriptor() {
        return cunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cunmtr_$handle() {
        return cunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cunmtr_$address() {
        return cunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *A, const int *lda, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cunmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = cunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cunmtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zunmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zunmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zunmtr_$descriptor() {
        return zunmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zunmtr_$handle() {
        return zunmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zunmtr_$address() {
        return zunmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zunmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *A, const int *lda, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zunmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14, long x15) {
        var mh$ = zunmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zunmtr_", side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
            }
            mh$.invokeExact(side, uplo, trans, m, n, A, lda, tau, C, ldc, work, lwork, info, x13, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cupgtr_$descriptor() {
        return cupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cupgtr_$handle() {
        return cupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cupgtr_$address() {
        return cupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cupgtr_(const char *uplo, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cupgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = cupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupgtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zupgtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zupgtr_$descriptor() {
        return zupgtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zupgtr_$handle() {
        return zupgtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zupgtr_$address() {
        return zupgtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zupgtr_(const char *uplo, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zupgtr_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zupgtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupgtr_", uplo, n, AP, tau, Q, ldq, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, tau, Q, ldq, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cupmtr_$descriptor() {
        return cupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cupmtr_$handle() {
        return cupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cupmtr_$address() {
        return cupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex float *AP, const _Complex float *tau, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cupmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = cupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cupmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zupmtr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zupmtr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zupmtr_$descriptor() {
        return zupmtr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zupmtr_$handle() {
        return zupmtr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zupmtr_$address() {
        return zupmtr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zupmtr_(const char *side, const char *uplo, const char *trans, const int *m, const int *n, const _Complex double *AP, const _Complex double *tau, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zupmtr_(MemorySegment side, MemorySegment uplo, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment AP, MemorySegment tau, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x11, long x12, long x13) {
        var mh$ = zupmtr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zupmtr_", side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
            }
            mh$.invokeExact(side, uplo, trans, m, n, AP, tau, C, ldc, work, info, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lapack_make_complex_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lapack_make_complex_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static FunctionDescriptor lapack_make_complex_float$descriptor() {
        return lapack_make_complex_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static MethodHandle lapack_make_complex_float$handle() {
        return lapack_make_complex_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static MemorySegment lapack_make_complex_float$address() {
        return lapack_make_complex_float.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Complex float lapack_make_complex_float(float re, float im)
     * }
     */
    public static float lapack_make_complex_float(float re, float im) {
        var mh$ = lapack_make_complex_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lapack_make_complex_float", re, im);
            }
            return (float)mh$.invokeExact(re, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lapack_make_complex_double {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lapack_make_complex_double");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static FunctionDescriptor lapack_make_complex_double$descriptor() {
        return lapack_make_complex_double.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static MethodHandle lapack_make_complex_double$handle() {
        return lapack_make_complex_double.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static MemorySegment lapack_make_complex_double$address() {
        return lapack_make_complex_double.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Complex double lapack_make_complex_double(double re, double im)
     * }
     */
    public static double lapack_make_complex_double(double re, double im) {
        var mh$ = lapack_make_complex_double.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lapack_make_complex_double", re, im);
            }
            return (double)mh$.invokeExact(re, im);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsdc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsdc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsdc$descriptor() {
        return LAPACKE_sbdsdc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static MethodHandle LAPACKE_sbdsdc$handle() {
        return LAPACKE_sbdsdc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static MemorySegment LAPACKE_sbdsdc$address() {
        return LAPACKE_sbdsdc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsdc(int matrix_layout, char uplo, char compq, int n, float *d, float *e, float *u, int ldu, float *vt, int ldvt, float *q, int *iq)
     * }
     */
    public static int LAPACKE_sbdsdc(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq) {
        var mh$ = LAPACKE_sbdsdc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsdc", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsdc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsdc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsdc$descriptor() {
        return LAPACKE_dbdsdc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static MethodHandle LAPACKE_dbdsdc$handle() {
        return LAPACKE_dbdsdc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static MemorySegment LAPACKE_dbdsdc$address() {
        return LAPACKE_dbdsdc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsdc(int matrix_layout, char uplo, char compq, int n, double *d, double *e, double *u, int ldu, double *vt, int ldvt, double *q, int *iq)
     * }
     */
    public static int LAPACKE_dbdsdc(int matrix_layout, byte uplo, byte compq, int n, MemorySegment d, MemorySegment e, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment q, MemorySegment iq) {
        var mh$ = LAPACKE_dbdsdc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsdc", matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsqr$descriptor() {
        return LAPACKE_sbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sbdsqr$handle() {
        return LAPACKE_sbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sbdsqr$address() {
        return LAPACKE_sbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, float *vt, int ldvt, float *u, int ldu, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsqr$descriptor() {
        return LAPACKE_dbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dbdsqr$handle() {
        return LAPACKE_dbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dbdsqr$address() {
        return LAPACKE_dbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, double *vt, int ldvt, double *u, int ldu, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cbdsqr$descriptor() {
        return LAPACKE_cbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cbdsqr$handle() {
        return LAPACKE_cbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cbdsqr$address() {
        return LAPACKE_cbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, float *d, float *e, _Complex float *vt, int ldvt, _Complex float *u, int ldu, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zbdsqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zbdsqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zbdsqr$descriptor() {
        return LAPACKE_zbdsqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zbdsqr$handle() {
        return LAPACKE_zbdsqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zbdsqr$address() {
        return LAPACKE_zbdsqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zbdsqr(int matrix_layout, char uplo, int n, int ncvt, int nru, int ncc, double *d, double *e, _Complex double *vt, int ldvt, _Complex double *u, int ldu, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zbdsqr(int matrix_layout, byte uplo, int n, int ncvt, int nru, int ncc, MemorySegment d, MemorySegment e, MemorySegment vt, int ldvt, MemorySegment u, int ldu, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zbdsqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zbdsqr", matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u, ldu, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sbdsvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sbdsvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sbdsvdx$descriptor() {
        return LAPACKE_sbdsvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_sbdsvdx$handle() {
        return LAPACKE_sbdsvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_sbdsvdx$address() {
        return LAPACKE_sbdsvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, float *d, float *e, float vl, float vu, int il, int iu, int *ns, float *s, float *z, int ldz, int *superb)
     * }
     */
    public static int LAPACKE_sbdsvdx(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment superb) {
        var mh$ = LAPACKE_sbdsvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sbdsvdx", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dbdsvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dbdsvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dbdsvdx$descriptor() {
        return LAPACKE_dbdsvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_dbdsvdx$handle() {
        return LAPACKE_dbdsvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_dbdsvdx$address() {
        return LAPACKE_dbdsvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dbdsvdx(int matrix_layout, char uplo, char jobz, char range, int n, double *d, double *e, double vl, double vu, int il, int iu, int *ns, double *s, double *z, int ldz, int *superb)
     * }
     */
    public static int LAPACKE_dbdsvdx(int matrix_layout, byte uplo, byte jobz, byte range, int n, MemorySegment d, MemorySegment e, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment z, int ldz, MemorySegment superb) {
        var mh$ = LAPACKE_dbdsvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dbdsvdx", matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, uplo, jobz, range, n, d, e, vl, vu, il, iu, ns, s, z, ldz, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sdisna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sdisna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_sdisna$descriptor() {
        return LAPACKE_sdisna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MethodHandle LAPACKE_sdisna$handle() {
        return LAPACKE_sdisna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static MemorySegment LAPACKE_sdisna$address() {
        return LAPACKE_sdisna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sdisna(char job, int m, int n, const float *d, float *sep)
     * }
     */
    public static int LAPACKE_sdisna(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_sdisna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sdisna", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_ddisna {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_ddisna");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static FunctionDescriptor LAPACKE_ddisna$descriptor() {
        return LAPACKE_ddisna.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MethodHandle LAPACKE_ddisna$handle() {
        return LAPACKE_ddisna.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static MemorySegment LAPACKE_ddisna$address() {
        return LAPACKE_ddisna.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_ddisna(char job, int m, int n, const double *d, double *sep)
     * }
     */
    public static int LAPACKE_ddisna(byte job, int m, int n, MemorySegment d, MemorySegment sep) {
        var mh$ = LAPACKE_ddisna.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_ddisna", job, m, n, d, sep);
            }
            return (int)mh$.invokeExact(job, m, n, d, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbbrd$descriptor() {
        return LAPACKE_sgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_sgbbrd$handle() {
        return LAPACKE_sgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_sgbbrd$address() {
        return LAPACKE_sgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, float *ab, int ldab, float *d, float *e, float *q, int ldq, float *pt, int ldpt, float *c, int ldc)
     * }
     */
    public static int LAPACKE_sgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_sgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbbrd$descriptor() {
        return LAPACKE_dgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_dgbbrd$handle() {
        return LAPACKE_dgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_dgbbrd$address() {
        return LAPACKE_dgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, double *ab, int ldab, double *d, double *e, double *q, int ldq, double *pt, int ldpt, double *c, int ldc)
     * }
     */
    public static int LAPACKE_dgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_dgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbbrd$descriptor() {
        return LAPACKE_cgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_cgbbrd$handle() {
        return LAPACKE_cgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_cgbbrd$address() {
        return LAPACKE_cgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex float *ab, int ldab, float *d, float *e, _Complex float *q, int ldq, _Complex float *pt, int ldpt, _Complex float *c, int ldc)
     * }
     */
    public static int LAPACKE_cgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_cgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbbrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbbrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbbrd$descriptor() {
        return LAPACKE_zgbbrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static MethodHandle LAPACKE_zgbbrd$handle() {
        return LAPACKE_zgbbrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static MemorySegment LAPACKE_zgbbrd$address() {
        return LAPACKE_zgbbrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbbrd(int matrix_layout, char vect, int m, int n, int ncc, int kl, int ku, _Complex double *ab, int ldab, double *d, double *e, _Complex double *q, int ldq, _Complex double *pt, int ldpt, _Complex double *c, int ldc)
     * }
     */
    public static int LAPACKE_zgbbrd(int matrix_layout, byte vect, int m, int n, int ncc, int kl, int ku, MemorySegment ab, int ldab, MemorySegment d, MemorySegment e, MemorySegment q, int ldq, MemorySegment pt, int ldpt, MemorySegment c, int ldc) {
        var mh$ = LAPACKE_zgbbrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbbrd", matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
            }
            return (int)mh$.invokeExact(matrix_layout, vect, m, n, ncc, kl, ku, ab, ldab, d, e, q, ldq, pt, ldpt, c, ldc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbcon$descriptor() {
        return LAPACKE_sgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgbcon$handle() {
        return LAPACKE_sgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgbcon$address() {
        return LAPACKE_sgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbcon(int matrix_layout, char norm, int n, int kl, int ku, const float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbcon$descriptor() {
        return LAPACKE_dgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgbcon$handle() {
        return LAPACKE_dgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgbcon$address() {
        return LAPACKE_dgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbcon(int matrix_layout, char norm, int n, int kl, int ku, const double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbcon$descriptor() {
        return LAPACKE_cgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgbcon$handle() {
        return LAPACKE_cgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgbcon$address() {
        return LAPACKE_cgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex float *ab, int ldab, const int *ipiv, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbcon$descriptor() {
        return LAPACKE_zgbcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgbcon$handle() {
        return LAPACKE_zgbcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgbcon$address() {
        return LAPACKE_zgbcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbcon(int matrix_layout, char norm, int n, int kl, int ku, const _Complex double *ab, int ldab, const int *ipiv, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgbcon(int matrix_layout, byte norm, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgbcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbcon", matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, kl, ku, ab, ldab, ipiv, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequ$descriptor() {
        return LAPACKE_sgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequ$handle() {
        return LAPACKE_sgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequ$address() {
        return LAPACKE_sgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequ$descriptor() {
        return LAPACKE_dgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequ$handle() {
        return LAPACKE_dgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequ$address() {
        return LAPACKE_dgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequ$descriptor() {
        return LAPACKE_cgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequ$handle() {
        return LAPACKE_cgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequ$address() {
        return LAPACKE_cgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequ$descriptor() {
        return LAPACKE_zgbequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequ$handle() {
        return LAPACKE_zgbequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequ$address() {
        return LAPACKE_zgbequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequ(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequ", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbequb$descriptor() {
        return LAPACKE_sgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgbequb$handle() {
        return LAPACKE_sgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgbequb$address() {
        return LAPACKE_sgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, const float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbequb$descriptor() {
        return LAPACKE_dgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgbequb$handle() {
        return LAPACKE_dgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgbequb$address() {
        return LAPACKE_dgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, const double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbequb$descriptor() {
        return LAPACKE_cgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgbequb$handle() {
        return LAPACKE_cgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgbequb$address() {
        return LAPACKE_cgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex float *ab, int ldab, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbequb$descriptor() {
        return LAPACKE_zgbequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgbequb$handle() {
        return LAPACKE_zgbequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgbequb$address() {
        return LAPACKE_zgbequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, const _Complex double *ab, int ldab, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgbequb(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgbequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbequb", matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfs$descriptor() {
        return LAPACKE_sgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfs$handle() {
        return LAPACKE_sgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfs$address() {
        return LAPACKE_sgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfs$descriptor() {
        return LAPACKE_dgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfs$handle() {
        return LAPACKE_dgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfs$address() {
        return LAPACKE_dgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfs$descriptor() {
        return LAPACKE_cgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfs$handle() {
        return LAPACKE_cgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfs$address() {
        return LAPACKE_cgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbrfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfs$descriptor() {
        return LAPACKE_zgbrfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfs$handle() {
        return LAPACKE_zgbrfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfs$address() {
        return LAPACKE_zgbrfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgbrfs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgbrfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbrfsx$descriptor() {
        return LAPACKE_sgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgbrfsx$handle() {
        return LAPACKE_sgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgbrfsx$address() {
        return LAPACKE_sgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbrfsx$descriptor() {
        return LAPACKE_dgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgbrfsx$handle() {
        return LAPACKE_dgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgbrfsx$address() {
        return LAPACKE_dgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbrfsx$descriptor() {
        return LAPACKE_cgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgbrfsx$handle() {
        return LAPACKE_cgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgbrfsx$address() {
        return LAPACKE_cgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const _Complex float *afb, int ldafb, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbrfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbrfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbrfsx$descriptor() {
        return LAPACKE_zgbrfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgbrfsx$handle() {
        return LAPACKE_zgbrfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgbrfsx$address() {
        return LAPACKE_zgbrfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbrfsx(int matrix_layout, char trans, char equed, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const _Complex double *afb, int ldafb, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgbrfsx(int matrix_layout, byte trans, byte equed, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgbrfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbrfsx", matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsv$descriptor() {
        return LAPACKE_sgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbsv$handle() {
        return LAPACKE_sgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbsv$address() {
        return LAPACKE_sgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, float *ab, int ldab, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsv$descriptor() {
        return LAPACKE_dgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbsv$handle() {
        return LAPACKE_dgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbsv$address() {
        return LAPACKE_dgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, double *ab, int ldab, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsv$descriptor() {
        return LAPACKE_cgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbsv$handle() {
        return LAPACKE_cgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbsv$address() {
        return LAPACKE_cgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsv$descriptor() {
        return LAPACKE_zgbsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbsv$handle() {
        return LAPACKE_zgbsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbsv$address() {
        return LAPACKE_zgbsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbsv(int matrix_layout, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsv", matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvx$descriptor() {
        return LAPACKE_sgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvx$handle() {
        return LAPACKE_sgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvx$address() {
        return LAPACKE_sgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_sgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_sgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvx$descriptor() {
        return LAPACKE_dgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvx$handle() {
        return LAPACKE_dgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvx$address() {
        return LAPACKE_dgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_dgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_dgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvx$descriptor() {
        return LAPACKE_cgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvx$handle() {
        return LAPACKE_cgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvx$address() {
        return LAPACKE_cgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_cgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_cgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvx$descriptor() {
        return LAPACKE_zgbsvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvx$handle() {
        return LAPACKE_zgbsvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvx$address() {
        return LAPACKE_zgbsvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_zgbsvx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_zgbsvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbsvxx$descriptor() {
        return LAPACKE_sgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgbsvxx$handle() {
        return LAPACKE_sgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgbsvxx$address() {
        return LAPACKE_sgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, float *ab, int ldab, float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbsvxx$descriptor() {
        return LAPACKE_dgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgbsvxx$handle() {
        return LAPACKE_dgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgbsvxx$address() {
        return LAPACKE_dgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, double *ab, int ldab, double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbsvxx$descriptor() {
        return LAPACKE_cgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgbsvxx$handle() {
        return LAPACKE_cgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgbsvxx$address() {
        return LAPACKE_cgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex float *ab, int ldab, _Complex float *afb, int ldafb, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbsvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbsvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbsvxx$descriptor() {
        return LAPACKE_zgbsvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgbsvxx$handle() {
        return LAPACKE_zgbsvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgbsvxx$address() {
        return LAPACKE_zgbsvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbsvxx(int matrix_layout, char fact, char trans, int n, int kl, int ku, int nrhs, _Complex double *ab, int ldab, _Complex double *afb, int ldafb, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgbsvxx(int matrix_layout, byte fact, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment afb, int ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgbsvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbsvxx", matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, kl, ku, nrhs, ab, ldab, afb, ldafb, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrf$descriptor() {
        return LAPACKE_sgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrf$handle() {
        return LAPACKE_sgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrf$address() {
        return LAPACKE_sgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_sgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrf$descriptor() {
        return LAPACKE_dgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrf$handle() {
        return LAPACKE_dgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrf$address() {
        return LAPACKE_dgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_dgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrf$descriptor() {
        return LAPACKE_cgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrf$handle() {
        return LAPACKE_cgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrf$address() {
        return LAPACKE_cgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex float *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_cgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbtrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrf$descriptor() {
        return LAPACKE_zgbtrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrf$handle() {
        return LAPACKE_zgbtrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrf$address() {
        return LAPACKE_zgbtrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, _Complex double *ab, int ldab, int *ipiv)
     * }
     */
    public static int LAPACKE_zgbtrf(int matrix_layout, int m, int n, int kl, int ku, MemorySegment ab, int ldab, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgbtrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrf", matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, kl, ku, ab, ldab, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgbtrs$descriptor() {
        return LAPACKE_sgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgbtrs$handle() {
        return LAPACKE_sgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgbtrs$address() {
        return LAPACKE_sgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const float *ab, int ldab, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgbtrs$descriptor() {
        return LAPACKE_dgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgbtrs$handle() {
        return LAPACKE_dgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgbtrs$address() {
        return LAPACKE_dgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const double *ab, int ldab, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgbtrs$descriptor() {
        return LAPACKE_cgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgbtrs$handle() {
        return LAPACKE_cgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgbtrs$address() {
        return LAPACKE_cgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex float *ab, int ldab, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgbtrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgbtrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgbtrs$descriptor() {
        return LAPACKE_zgbtrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgbtrs$handle() {
        return LAPACKE_zgbtrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgbtrs$address() {
        return LAPACKE_zgbtrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgbtrs(int matrix_layout, char trans, int n, int kl, int ku, int nrhs, const _Complex double *ab, int ldab, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgbtrs(int matrix_layout, byte trans, int n, int kl, int ku, int nrhs, MemorySegment ab, int ldab, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgbtrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgbtrs", matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, kl, ku, nrhs, ab, ldab, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebak$descriptor() {
        return LAPACKE_sgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sgebak$handle() {
        return LAPACKE_sgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sgebak$address() {
        return LAPACKE_sgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebak$descriptor() {
        return LAPACKE_dgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dgebak$handle() {
        return LAPACKE_dgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dgebak$address() {
        return LAPACKE_dgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebak$descriptor() {
        return LAPACKE_cgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cgebak$handle() {
        return LAPACKE_cgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cgebak$address() {
        return LAPACKE_cgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *scale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebak$descriptor() {
        return LAPACKE_zgebak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zgebak$handle() {
        return LAPACKE_zgebak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zgebak$address() {
        return LAPACKE_zgebak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *scale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zgebak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment scale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zgebak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebak", matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, scale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebal$descriptor() {
        return LAPACKE_sgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_sgebal$handle() {
        return LAPACKE_sgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_sgebal$address() {
        return LAPACKE_sgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebal(int matrix_layout, char job, int n, float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_sgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_sgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebal$descriptor() {
        return LAPACKE_dgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_dgebal$handle() {
        return LAPACKE_dgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_dgebal$address() {
        return LAPACKE_dgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebal(int matrix_layout, char job, int n, double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_dgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_dgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebal$descriptor() {
        return LAPACKE_cgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MethodHandle LAPACKE_cgebal$handle() {
        return LAPACKE_cgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static MemorySegment LAPACKE_cgebal$address() {
        return LAPACKE_cgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebal(int matrix_layout, char job, int n, _Complex float *a, int lda, int *ilo, int *ihi, float *scale)
     * }
     */
    public static int LAPACKE_cgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_cgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebal$descriptor() {
        return LAPACKE_zgebal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MethodHandle LAPACKE_zgebal$handle() {
        return LAPACKE_zgebal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static MemorySegment LAPACKE_zgebal$address() {
        return LAPACKE_zgebal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebal(int matrix_layout, char job, int n, _Complex double *a, int lda, int *ilo, int *ihi, double *scale)
     * }
     */
    public static int LAPACKE_zgebal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale) {
        var mh$ = LAPACKE_zgebal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebal", matrix_layout, job, n, a, lda, ilo, ihi, scale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, ilo, ihi, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgebrd$descriptor() {
        return LAPACKE_sgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static MethodHandle LAPACKE_sgebrd$handle() {
        return LAPACKE_sgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static MemorySegment LAPACKE_sgebrd$address() {
        return LAPACKE_sgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgebrd(int matrix_layout, int m, int n, float *a, int lda, float *d, float *e, float *tauq, float *taup)
     * }
     */
    public static int LAPACKE_sgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_sgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgebrd$descriptor() {
        return LAPACKE_dgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static MethodHandle LAPACKE_dgebrd$handle() {
        return LAPACKE_dgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static MemorySegment LAPACKE_dgebrd$address() {
        return LAPACKE_dgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgebrd(int matrix_layout, int m, int n, double *a, int lda, double *d, double *e, double *tauq, double *taup)
     * }
     */
    public static int LAPACKE_dgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_dgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgebrd$descriptor() {
        return LAPACKE_cgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static MethodHandle LAPACKE_cgebrd$handle() {
        return LAPACKE_cgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static MemorySegment LAPACKE_cgebrd$address() {
        return LAPACKE_cgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgebrd(int matrix_layout, int m, int n, _Complex float *a, int lda, float *d, float *e, _Complex float *tauq, _Complex float *taup)
     * }
     */
    public static int LAPACKE_cgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_cgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgebrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgebrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgebrd$descriptor() {
        return LAPACKE_zgebrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static MethodHandle LAPACKE_zgebrd$handle() {
        return LAPACKE_zgebrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static MemorySegment LAPACKE_zgebrd$address() {
        return LAPACKE_zgebrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgebrd(int matrix_layout, int m, int n, _Complex double *a, int lda, double *d, double *e, _Complex double *tauq, _Complex double *taup)
     * }
     */
    public static int LAPACKE_zgebrd(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment d, MemorySegment e, MemorySegment tauq, MemorySegment taup) {
        var mh$ = LAPACKE_zgebrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgebrd", matrix_layout, m, n, a, lda, d, e, tauq, taup);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, d, e, tauq, taup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgecon$descriptor() {
        return LAPACKE_sgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_sgecon$handle() {
        return LAPACKE_sgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_sgecon$address() {
        return LAPACKE_sgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgecon(int matrix_layout, char norm, int n, const float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_sgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_sgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgecon$descriptor() {
        return LAPACKE_dgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_dgecon$handle() {
        return LAPACKE_dgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_dgecon$address() {
        return LAPACKE_dgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgecon(int matrix_layout, char norm, int n, const double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_dgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_dgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgecon$descriptor() {
        return LAPACKE_cgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MethodHandle LAPACKE_cgecon$handle() {
        return LAPACKE_cgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static MemorySegment LAPACKE_cgecon$address() {
        return LAPACKE_cgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgecon(int matrix_layout, char norm, int n, const _Complex float *a, int lda, float anorm, float *rcond)
     * }
     */
    public static int LAPACKE_cgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, float anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_cgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgecon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgecon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgecon$descriptor() {
        return LAPACKE_zgecon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MethodHandle LAPACKE_zgecon$handle() {
        return LAPACKE_zgecon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static MemorySegment LAPACKE_zgecon$address() {
        return LAPACKE_zgecon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgecon(int matrix_layout, char norm, int n, const _Complex double *a, int lda, double anorm, double *rcond)
     * }
     */
    public static int LAPACKE_zgecon(int matrix_layout, byte norm, int n, MemorySegment a, int lda, double anorm, MemorySegment rcond) {
        var mh$ = LAPACKE_zgecon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgecon", matrix_layout, norm, n, a, lda, anorm, rcond);
            }
            return (int)mh$.invokeExact(matrix_layout, norm, n, a, lda, anorm, rcond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequ$descriptor() {
        return LAPACKE_sgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequ$handle() {
        return LAPACKE_sgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequ$address() {
        return LAPACKE_sgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequ(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequ$descriptor() {
        return LAPACKE_dgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequ$handle() {
        return LAPACKE_dgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequ$address() {
        return LAPACKE_dgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequ(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequ$descriptor() {
        return LAPACKE_cgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequ$handle() {
        return LAPACKE_cgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequ$address() {
        return LAPACKE_cgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequ(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeequ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequ$descriptor() {
        return LAPACKE_zgeequ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequ$handle() {
        return LAPACKE_zgeequ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequ$address() {
        return LAPACKE_zgeequ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequ(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequ(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequ", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeequb$descriptor() {
        return LAPACKE_sgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_sgeequb$handle() {
        return LAPACKE_sgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_sgeequb$address() {
        return LAPACKE_sgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeequb(int matrix_layout, int m, int n, const float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_sgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_sgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeequb$descriptor() {
        return LAPACKE_dgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_dgeequb$handle() {
        return LAPACKE_dgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_dgeequb$address() {
        return LAPACKE_dgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeequb(int matrix_layout, int m, int n, const double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_dgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_dgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeequb$descriptor() {
        return LAPACKE_cgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MethodHandle LAPACKE_cgeequb$handle() {
        return LAPACKE_cgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static MemorySegment LAPACKE_cgeequb$address() {
        return LAPACKE_cgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeequb(int matrix_layout, int m, int n, const _Complex float *a, int lda, float *r, float *c, float *rowcnd, float *colcnd, float *amax)
     * }
     */
    public static int LAPACKE_cgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_cgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeequb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeequb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeequb$descriptor() {
        return LAPACKE_zgeequb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MethodHandle LAPACKE_zgeequb$handle() {
        return LAPACKE_zgeequb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static MemorySegment LAPACKE_zgeequb$address() {
        return LAPACKE_zgeequb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeequb(int matrix_layout, int m, int n, const _Complex double *a, int lda, double *r, double *c, double *rowcnd, double *colcnd, double *amax)
     * }
     */
    public static int LAPACKE_zgeequb(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment r, MemorySegment c, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax) {
        var mh$ = LAPACKE_zgeequb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeequb", matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, r, c, rowcnd, colcnd, amax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgees$descriptor() {
        return LAPACKE_sgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_sgees$handle() {
        return LAPACKE_sgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_sgees$address() {
        return LAPACKE_sgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgees(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs)
     * }
     */
    public static int LAPACKE_sgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_sgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgees$descriptor() {
        return LAPACKE_dgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_dgees$handle() {
        return LAPACKE_dgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_dgees$address() {
        return LAPACKE_dgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgees(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs)
     * }
     */
    public static int LAPACKE_dgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_dgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, wr, wi, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgees$descriptor() {
        return LAPACKE_cgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_cgees$handle() {
        return LAPACKE_cgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_cgees$address() {
        return LAPACKE_cgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgees(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs)
     * }
     */
    public static int LAPACKE_cgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_cgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgees$descriptor() {
        return LAPACKE_zgees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static MethodHandle LAPACKE_zgees$handle() {
        return LAPACKE_zgees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static MemorySegment LAPACKE_zgees$address() {
        return LAPACKE_zgees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgees(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs)
     * }
     */
    public static int LAPACKE_zgees(int matrix_layout, byte jobvs, byte sort, MemorySegment select, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs) {
        var mh$ = LAPACKE_zgees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgees", matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, n, a, lda, sdim, w, vs, ldvs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeesx$descriptor() {
        return LAPACKE_sgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sgeesx$handle() {
        return LAPACKE_sgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sgeesx$address() {
        return LAPACKE_sgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeesx(int matrix_layout, char jobvs, char sort, LAPACK_S_SELECT2 select, char sense, int n, float *a, int lda, int *sdim, float *wr, float *wi, float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeesx$descriptor() {
        return LAPACKE_dgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dgeesx$handle() {
        return LAPACKE_dgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dgeesx$address() {
        return LAPACKE_dgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeesx(int matrix_layout, char jobvs, char sort, LAPACK_D_SELECT2 select, char sense, int n, double *a, int lda, int *sdim, double *wr, double *wi, double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment wr, MemorySegment wi, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, wr, wi, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeesx$descriptor() {
        return LAPACKE_cgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cgeesx$handle() {
        return LAPACKE_cgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cgeesx$address() {
        return LAPACKE_cgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeesx(int matrix_layout, char jobvs, char sort, LAPACK_C_SELECT1 select, char sense, int n, _Complex float *a, int lda, int *sdim, _Complex float *w, _Complex float *vs, int ldvs, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeesx$descriptor() {
        return LAPACKE_zgeesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zgeesx$handle() {
        return LAPACKE_zgeesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zgeesx$address() {
        return LAPACKE_zgeesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeesx(int matrix_layout, char jobvs, char sort, LAPACK_Z_SELECT1 select, char sense, int n, _Complex double *a, int lda, int *sdim, _Complex double *w, _Complex double *vs, int ldvs, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zgeesx(int matrix_layout, byte jobvs, byte sort, MemorySegment select, byte sense, int n, MemorySegment a, int lda, MemorySegment sdim, MemorySegment w, MemorySegment vs, int ldvs, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zgeesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeesx", matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvs, sort, select, sense, n, a, lda, sdim, w, vs, ldvs, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeev$descriptor() {
        return LAPACKE_sgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sgeev$handle() {
        return LAPACKE_sgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sgeev$address() {
        return LAPACKE_sgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeev", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeev$descriptor() {
        return LAPACKE_dgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dgeev$handle() {
        return LAPACKE_dgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dgeev$address() {
        return LAPACKE_dgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeev", matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, wr, wi, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeev$descriptor() {
        return LAPACKE_cgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cgeev$handle() {
        return LAPACKE_cgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cgeev$address() {
        return LAPACKE_cgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeev", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeev$descriptor() {
        return LAPACKE_zgeev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zgeev$handle() {
        return LAPACKE_zgeev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zgeev$address() {
        return LAPACKE_zgeev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zgeev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zgeev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeev", matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeevx$descriptor() {
        return LAPACKE_sgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sgeevx$handle() {
        return LAPACKE_sgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sgeevx$address() {
        return LAPACKE_sgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *wr, float *wi, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeevx$descriptor() {
        return LAPACKE_dgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dgeevx$handle() {
        return LAPACKE_dgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dgeevx$address() {
        return LAPACKE_dgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *wr, double *wi, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment wr, MemorySegment wi, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, wr, wi, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeevx$descriptor() {
        return LAPACKE_cgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cgeevx$handle() {
        return LAPACKE_cgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cgeevx$address() {
        return LAPACKE_cgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *w, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeevx$descriptor() {
        return LAPACKE_zgeevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zgeevx$handle() {
        return LAPACKE_zgeevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zgeevx$address() {
        return LAPACKE_zgeevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *w, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zgeevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment w, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zgeevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, w, vl, ldvl, vr, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgehrd$descriptor() {
        return LAPACKE_sgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgehrd$handle() {
        return LAPACKE_sgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgehrd$address() {
        return LAPACKE_sgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgehrd$descriptor() {
        return LAPACKE_dgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgehrd$handle() {
        return LAPACKE_dgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgehrd$address() {
        return LAPACKE_dgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgehrd$descriptor() {
        return LAPACKE_cgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgehrd$handle() {
        return LAPACKE_cgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgehrd$address() {
        return LAPACKE_cgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgehrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgehrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgehrd$descriptor() {
        return LAPACKE_zgehrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgehrd$handle() {
        return LAPACKE_zgehrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgehrd$address() {
        return LAPACKE_zgehrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgehrd(int matrix_layout, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgehrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgehrd", matrix_layout, n, ilo, ihi, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, n, ilo, ihi, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgejsv$descriptor() {
        return LAPACKE_sgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_sgejsv$handle() {
        return LAPACKE_sgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_sgejsv$address() {
        return LAPACKE_sgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, float *a, int lda, float *sva, float *u, int ldu, float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static int LAPACKE_sgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_sgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgejsv$descriptor() {
        return LAPACKE_dgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_dgejsv$handle() {
        return LAPACKE_dgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_dgejsv$address() {
        return LAPACKE_dgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, double *a, int lda, double *sva, double *u, int ldu, double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static int LAPACKE_dgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_dgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgejsv$descriptor() {
        return LAPACKE_cgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_cgejsv$handle() {
        return LAPACKE_cgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_cgejsv$address() {
        return LAPACKE_cgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex float *a, int lda, float *sva, _Complex float *u, int ldu, _Complex float *v, int ldv, float *stat, int *istat)
     * }
     */
    public static int LAPACKE_cgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_cgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgejsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgejsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgejsv$descriptor() {
        return LAPACKE_zgejsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MethodHandle LAPACKE_zgejsv$handle() {
        return LAPACKE_zgejsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static MemorySegment LAPACKE_zgejsv$address() {
        return LAPACKE_zgejsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgejsv(int matrix_layout, char joba, char jobu, char jobv, char jobr, char jobt, char jobp, int m, int n, _Complex double *a, int lda, double *sva, _Complex double *u, int ldu, _Complex double *v, int ldv, double *stat, int *istat)
     * }
     */
    public static int LAPACKE_zgejsv(int matrix_layout, byte joba, byte jobu, byte jobv, byte jobr, byte jobt, byte jobp, int m, int n, MemorySegment a, int lda, MemorySegment sva, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment stat, MemorySegment istat) {
        var mh$ = LAPACKE_zgejsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgejsv", matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, stat, istat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelq2$descriptor() {
        return LAPACKE_sgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgelq2$handle() {
        return LAPACKE_sgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgelq2$address() {
        return LAPACKE_sgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelq2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelq2$descriptor() {
        return LAPACKE_dgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgelq2$handle() {
        return LAPACKE_dgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgelq2$address() {
        return LAPACKE_dgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelq2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelq2$descriptor() {
        return LAPACKE_cgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgelq2$handle() {
        return LAPACKE_cgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgelq2$address() {
        return LAPACKE_cgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelq2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelq2$descriptor() {
        return LAPACKE_zgelq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgelq2$handle() {
        return LAPACKE_zgelq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgelq2$address() {
        return LAPACKE_zgelq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelq2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgelq2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgelq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelq2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelqf$descriptor() {
        return LAPACKE_sgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgelqf$handle() {
        return LAPACKE_sgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgelqf$address() {
        return LAPACKE_sgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelqf$descriptor() {
        return LAPACKE_dgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgelqf$handle() {
        return LAPACKE_dgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgelqf$address() {
        return LAPACKE_dgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelqf$descriptor() {
        return LAPACKE_cgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgelqf$handle() {
        return LAPACKE_cgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgelqf$address() {
        return LAPACKE_cgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelqf$descriptor() {
        return LAPACKE_zgelqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgelqf$handle() {
        return LAPACKE_zgelqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgelqf$address() {
        return LAPACKE_zgelqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgelqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgelqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgels$descriptor() {
        return LAPACKE_sgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgels$handle() {
        return LAPACKE_sgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgels$address() {
        return LAPACKE_sgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgels(int matrix_layout, char trans, int m, int n, int nrhs, float *a, int lda, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgels$descriptor() {
        return LAPACKE_dgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgels$handle() {
        return LAPACKE_dgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgels$address() {
        return LAPACKE_dgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgels(int matrix_layout, char trans, int m, int n, int nrhs, double *a, int lda, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgels$descriptor() {
        return LAPACKE_cgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgels$handle() {
        return LAPACKE_cgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgels$address() {
        return LAPACKE_cgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgels$descriptor() {
        return LAPACKE_zgels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgels$handle() {
        return LAPACKE_zgels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgels$address() {
        return LAPACKE_zgels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgels(int matrix_layout, char trans, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgels(int matrix_layout, byte trans, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgels", matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, m, n, nrhs, a, lda, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsd$descriptor() {
        return LAPACKE_sgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelsd$handle() {
        return LAPACKE_sgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelsd$address() {
        return LAPACKE_sgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsd$descriptor() {
        return LAPACKE_dgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelsd$handle() {
        return LAPACKE_dgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelsd$address() {
        return LAPACKE_dgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsd$descriptor() {
        return LAPACKE_cgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelsd$handle() {
        return LAPACKE_cgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelsd$address() {
        return LAPACKE_cgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsd$descriptor() {
        return LAPACKE_zgelsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelsd$handle() {
        return LAPACKE_zgelsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelsd$address() {
        return LAPACKE_zgelsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelsd(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsd", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelss$descriptor() {
        return LAPACKE_sgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelss$handle() {
        return LAPACKE_sgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelss$address() {
        return LAPACKE_sgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelss$descriptor() {
        return LAPACKE_dgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelss$handle() {
        return LAPACKE_dgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelss$address() {
        return LAPACKE_dgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelss$descriptor() {
        return LAPACKE_cgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelss$handle() {
        return LAPACKE_cgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelss$address() {
        return LAPACKE_cgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, float *s, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelss$descriptor() {
        return LAPACKE_zgelss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelss$handle() {
        return LAPACKE_zgelss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelss$address() {
        return LAPACKE_zgelss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, double *s, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelss(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment s, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelss", matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, s, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgelsy$descriptor() {
        return LAPACKE_sgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_sgelsy$handle() {
        return LAPACKE_sgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_sgelsy$address() {
        return LAPACKE_sgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, float *a, int lda, float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_sgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_sgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgelsy$descriptor() {
        return LAPACKE_dgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_dgelsy$handle() {
        return LAPACKE_dgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_dgelsy$address() {
        return LAPACKE_dgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, double *a, int lda, double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_dgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_dgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgelsy$descriptor() {
        return LAPACKE_cgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_cgelsy$handle() {
        return LAPACKE_cgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_cgelsy$address() {
        return LAPACKE_cgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, _Complex float *a, int lda, _Complex float *b, int ldb, int *jpvt, float rcond, int *rank)
     * }
     */
    public static int LAPACKE_cgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, float rcond, MemorySegment rank) {
        var mh$ = LAPACKE_cgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgelsy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgelsy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgelsy$descriptor() {
        return LAPACKE_zgelsy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MethodHandle LAPACKE_zgelsy$handle() {
        return LAPACKE_zgelsy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static MemorySegment LAPACKE_zgelsy$address() {
        return LAPACKE_zgelsy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, _Complex double *a, int lda, _Complex double *b, int ldb, int *jpvt, double rcond, int *rank)
     * }
     */
    public static int LAPACKE_zgelsy(int matrix_layout, int m, int n, int nrhs, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment jpvt, double rcond, MemorySegment rank) {
        var mh$ = LAPACKE_zgelsy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgelsy", matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, nrhs, a, lda, b, ldb, jpvt, rcond, rank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqlf$descriptor() {
        return LAPACKE_sgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqlf$handle() {
        return LAPACKE_sgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqlf$address() {
        return LAPACKE_sgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqlf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqlf$descriptor() {
        return LAPACKE_dgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqlf$handle() {
        return LAPACKE_dgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqlf$address() {
        return LAPACKE_dgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqlf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqlf$descriptor() {
        return LAPACKE_cgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqlf$handle() {
        return LAPACKE_cgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqlf$address() {
        return LAPACKE_cgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqlf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqlf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqlf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqlf$descriptor() {
        return LAPACKE_zgeqlf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqlf$handle() {
        return LAPACKE_zgeqlf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqlf$address() {
        return LAPACKE_zgeqlf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqlf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqlf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqlf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqlf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqp3$descriptor() {
        return LAPACKE_sgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqp3$handle() {
        return LAPACKE_sgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqp3$address() {
        return LAPACKE_sgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqp3(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static int LAPACKE_sgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqp3$descriptor() {
        return LAPACKE_dgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqp3$handle() {
        return LAPACKE_dgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqp3$address() {
        return LAPACKE_dgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqp3(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static int LAPACKE_dgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqp3$descriptor() {
        return LAPACKE_cgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqp3$handle() {
        return LAPACKE_cgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqp3$address() {
        return LAPACKE_cgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqp3(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqp3$descriptor() {
        return LAPACKE_zgeqp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqp3$handle() {
        return LAPACKE_zgeqp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqp3$address() {
        return LAPACKE_zgeqp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqp3(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqp3(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqp3", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqpf$descriptor() {
        return LAPACKE_sgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqpf$handle() {
        return LAPACKE_sgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqpf$address() {
        return LAPACKE_sgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqpf(int matrix_layout, int m, int n, float *a, int lda, int *jpvt, float *tau)
     * }
     */
    public static int LAPACKE_sgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqpf$descriptor() {
        return LAPACKE_dgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqpf$handle() {
        return LAPACKE_dgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqpf$address() {
        return LAPACKE_dgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqpf(int matrix_layout, int m, int n, double *a, int lda, int *jpvt, double *tau)
     * }
     */
    public static int LAPACKE_dgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqpf$descriptor() {
        return LAPACKE_cgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqpf$handle() {
        return LAPACKE_cgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqpf$address() {
        return LAPACKE_cgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqpf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *jpvt, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqpf$descriptor() {
        return LAPACKE_zgeqpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqpf$handle() {
        return LAPACKE_zgeqpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqpf$address() {
        return LAPACKE_zgeqpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqpf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *jpvt, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqpf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment jpvt, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqpf", matrix_layout, m, n, a, lda, jpvt, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, jpvt, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqr2$descriptor() {
        return LAPACKE_sgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqr2$handle() {
        return LAPACKE_sgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqr2$address() {
        return LAPACKE_sgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqr2(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqr2$descriptor() {
        return LAPACKE_dgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqr2$handle() {
        return LAPACKE_dgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqr2$address() {
        return LAPACKE_dgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqr2(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqr2$descriptor() {
        return LAPACKE_cgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqr2$handle() {
        return LAPACKE_cgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqr2$address() {
        return LAPACKE_cgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqr2(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqr2$descriptor() {
        return LAPACKE_zgeqr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqr2$handle() {
        return LAPACKE_zgeqr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqr2$address() {
        return LAPACKE_zgeqr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqr2(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqr2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqr2", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrf$descriptor() {
        return LAPACKE_sgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrf$handle() {
        return LAPACKE_sgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrf$address() {
        return LAPACKE_sgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrf$descriptor() {
        return LAPACKE_dgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrf$handle() {
        return LAPACKE_dgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrf$address() {
        return LAPACKE_dgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrf$descriptor() {
        return LAPACKE_cgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrf$handle() {
        return LAPACKE_cgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrf$address() {
        return LAPACKE_cgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrf$descriptor() {
        return LAPACKE_zgeqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrf$handle() {
        return LAPACKE_zgeqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrf$address() {
        return LAPACKE_zgeqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgeqrfp$descriptor() {
        return LAPACKE_sgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgeqrfp$handle() {
        return LAPACKE_sgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgeqrfp$address() {
        return LAPACKE_sgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgeqrfp$descriptor() {
        return LAPACKE_dgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgeqrfp$handle() {
        return LAPACKE_dgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgeqrfp$address() {
        return LAPACKE_dgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgeqrfp$descriptor() {
        return LAPACKE_cgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgeqrfp$handle() {
        return LAPACKE_cgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgeqrfp$address() {
        return LAPACKE_cgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgeqrfp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgeqrfp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgeqrfp$descriptor() {
        return LAPACKE_zgeqrfp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgeqrfp$handle() {
        return LAPACKE_zgeqrfp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgeqrfp$address() {
        return LAPACKE_zgeqrfp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgeqrfp(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgeqrfp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgeqrfp", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfs$descriptor() {
        return LAPACKE_sgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_sgerfs$handle() {
        return LAPACKE_sgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_sgerfs$address() {
        return LAPACKE_sgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *b, int ldb, float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_sgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_sgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfs$descriptor() {
        return LAPACKE_dgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_dgerfs$handle() {
        return LAPACKE_dgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_dgerfs$address() {
        return LAPACKE_dgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *b, int ldb, double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_dgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_dgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfs$descriptor() {
        return LAPACKE_cgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MethodHandle LAPACKE_cgerfs$handle() {
        return LAPACKE_cgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static MemorySegment LAPACKE_cgerfs$address() {
        return LAPACKE_cgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *ferr, float *berr)
     * }
     */
    public static int LAPACKE_cgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_cgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfs$descriptor() {
        return LAPACKE_zgerfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MethodHandle LAPACKE_zgerfs$handle() {
        return LAPACKE_zgerfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static MemorySegment LAPACKE_zgerfs$address() {
        return LAPACKE_zgerfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *ferr, double *berr)
     * }
     */
    public static int LAPACKE_zgerfs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment ferr, MemorySegment berr) {
        var mh$ = LAPACKE_zgerfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfs", matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x, ldx, ferr, berr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerfsx$descriptor() {
        return LAPACKE_sgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgerfsx$handle() {
        return LAPACKE_sgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgerfsx$address() {
        return LAPACKE_sgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const float *a, int lda, const float *af, int ldaf, const int *ipiv, const float *r, const float *c, const float *b, int ldb, float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerfsx$descriptor() {
        return LAPACKE_dgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgerfsx$handle() {
        return LAPACKE_dgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgerfsx$address() {
        return LAPACKE_dgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const double *a, int lda, const double *af, int ldaf, const int *ipiv, const double *r, const double *c, const double *b, int ldb, double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerfsx$descriptor() {
        return LAPACKE_cgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgerfsx$handle() {
        return LAPACKE_cgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgerfsx$address() {
        return LAPACKE_cgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex float *a, int lda, const _Complex float *af, int ldaf, const int *ipiv, const float *r, const float *c, const _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerfsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerfsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerfsx$descriptor() {
        return LAPACKE_zgerfsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgerfsx$handle() {
        return LAPACKE_zgerfsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgerfsx$address() {
        return LAPACKE_zgerfsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerfsx(int matrix_layout, char trans, char equed, int n, int nrhs, const _Complex double *a, int lda, const _Complex double *af, int ldaf, const int *ipiv, const double *r, const double *c, const _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgerfsx(int matrix_layout, byte trans, byte equed, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgerfsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerfsx", matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, equed, n, nrhs, a, lda, af, ldaf, ipiv, r, c, b, ldb, x, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgerqf$descriptor() {
        return LAPACKE_sgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MethodHandle LAPACKE_sgerqf$handle() {
        return LAPACKE_sgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static MemorySegment LAPACKE_sgerqf$address() {
        return LAPACKE_sgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgerqf(int matrix_layout, int m, int n, float *a, int lda, float *tau)
     * }
     */
    public static int LAPACKE_sgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_sgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgerqf$descriptor() {
        return LAPACKE_dgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MethodHandle LAPACKE_dgerqf$handle() {
        return LAPACKE_dgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static MemorySegment LAPACKE_dgerqf$address() {
        return LAPACKE_dgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgerqf(int matrix_layout, int m, int n, double *a, int lda, double *tau)
     * }
     */
    public static int LAPACKE_dgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_dgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgerqf$descriptor() {
        return LAPACKE_cgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MethodHandle LAPACKE_cgerqf$handle() {
        return LAPACKE_cgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static MemorySegment LAPACKE_cgerqf$address() {
        return LAPACKE_cgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgerqf(int matrix_layout, int m, int n, _Complex float *a, int lda, _Complex float *tau)
     * }
     */
    public static int LAPACKE_cgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_cgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgerqf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgerqf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgerqf$descriptor() {
        return LAPACKE_zgerqf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MethodHandle LAPACKE_zgerqf$handle() {
        return LAPACKE_zgerqf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static MemorySegment LAPACKE_zgerqf$address() {
        return LAPACKE_zgerqf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgerqf(int matrix_layout, int m, int n, _Complex double *a, int lda, _Complex double *tau)
     * }
     */
    public static int LAPACKE_zgerqf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment tau) {
        var mh$ = LAPACKE_zgerqf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgerqf", matrix_layout, m, n, a, lda, tau);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, tau);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesdd$descriptor() {
        return LAPACKE_sgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_sgesdd$handle() {
        return LAPACKE_sgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_sgesdd$address() {
        return LAPACKE_sgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesdd(int matrix_layout, char jobz, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt)
     * }
     */
    public static int LAPACKE_sgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_sgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesdd$descriptor() {
        return LAPACKE_dgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_dgesdd$handle() {
        return LAPACKE_dgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_dgesdd$address() {
        return LAPACKE_dgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesdd(int matrix_layout, char jobz, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt)
     * }
     */
    public static int LAPACKE_dgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_dgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesdd$descriptor() {
        return LAPACKE_cgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_cgesdd$handle() {
        return LAPACKE_cgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_cgesdd$address() {
        return LAPACKE_cgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesdd(int matrix_layout, char jobz, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt)
     * }
     */
    public static int LAPACKE_cgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_cgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesdd$descriptor() {
        return LAPACKE_zgesdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static MethodHandle LAPACKE_zgesdd$handle() {
        return LAPACKE_zgesdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static MemorySegment LAPACKE_zgesdd$address() {
        return LAPACKE_zgesdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesdd(int matrix_layout, char jobz, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt)
     * }
     */
    public static int LAPACKE_zgesdd(int matrix_layout, byte jobz, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt) {
        var mh$ = LAPACKE_zgesdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesdd", matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
            }
            return (int)mh$.invokeExact(matrix_layout, jobz, m, n, a, lda, s, u, ldu, vt, ldvt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesv$descriptor() {
        return LAPACKE_sgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgesv$handle() {
        return LAPACKE_sgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgesv$address() {
        return LAPACKE_sgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, float *a, int lda, int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesv$descriptor() {
        return LAPACKE_dgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgesv$handle() {
        return LAPACKE_dgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgesv$address() {
        return LAPACKE_dgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesv$descriptor() {
        return LAPACKE_cgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgesv$handle() {
        return LAPACKE_cgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgesv$address() {
        return LAPACKE_cgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, _Complex float *a, int lda, int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesv$descriptor() {
        return LAPACKE_zgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgesv$handle() {
        return LAPACKE_zgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgesv$address() {
        return LAPACKE_zgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dsgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dsgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_dsgesv$descriptor() {
        return LAPACKE_dsgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_dsgesv$handle() {
        return LAPACKE_dsgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_dsgesv$address() {
        return LAPACKE_dsgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, double *a, int lda, int *ipiv, double *b, int ldb, double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_dsgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_dsgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dsgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zcgesv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zcgesv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static FunctionDescriptor LAPACKE_zcgesv$descriptor() {
        return LAPACKE_zcgesv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MethodHandle LAPACKE_zcgesv$handle() {
        return LAPACKE_zcgesv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static MemorySegment LAPACKE_zcgesv$address() {
        return LAPACKE_zcgesv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, _Complex double *a, int lda, int *ipiv, _Complex double *b, int ldb, _Complex double *x, int ldx, int *iter)
     * }
     */
    public static int LAPACKE_zcgesv(int matrix_layout, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment iter) {
        var mh$ = LAPACKE_zcgesv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zcgesv", matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
            }
            return (int)mh$.invokeExact(matrix_layout, n, nrhs, a, lda, ipiv, b, ldb, x, ldx, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvd$descriptor() {
        return LAPACKE_sgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static MethodHandle LAPACKE_sgesvd$handle() {
        return LAPACKE_sgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static MemorySegment LAPACKE_sgesvd$address() {
        return LAPACKE_sgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *vt, int ldvt, float *superb)
     * }
     */
    public static int LAPACKE_sgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_sgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvd$descriptor() {
        return LAPACKE_dgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static MethodHandle LAPACKE_dgesvd$handle() {
        return LAPACKE_dgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static MemorySegment LAPACKE_dgesvd$address() {
        return LAPACKE_dgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *vt, int ldvt, double *superb)
     * }
     */
    public static int LAPACKE_dgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_dgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvd$descriptor() {
        return LAPACKE_cgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static MethodHandle LAPACKE_cgesvd$handle() {
        return LAPACKE_cgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static MemorySegment LAPACKE_cgesvd$address() {
        return LAPACKE_cgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, float *superb)
     * }
     */
    public static int LAPACKE_cgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_cgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvd$descriptor() {
        return LAPACKE_zgesvd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static MethodHandle LAPACKE_zgesvd$handle() {
        return LAPACKE_zgesvd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static MemorySegment LAPACKE_zgesvd$address() {
        return LAPACKE_zgesvd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvd(int matrix_layout, char jobu, char jobvt, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, double *superb)
     * }
     */
    public static int LAPACKE_zgesvd(int matrix_layout, byte jobu, byte jobvt, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_zgesvd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvd", matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdx$descriptor() {
        return LAPACKE_sgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdx$handle() {
        return LAPACKE_sgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdx$address() {
        return LAPACKE_sgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, float *u, int ldu, float *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_sgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_sgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdx$descriptor() {
        return LAPACKE_dgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdx$handle() {
        return LAPACKE_dgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdx$address() {
        return LAPACKE_dgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, double *u, int ldu, double *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_dgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_dgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdx$descriptor() {
        return LAPACKE_cgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdx$handle() {
        return LAPACKE_cgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdx$address() {
        return LAPACKE_cgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex float *a, int lda, float vl, float vu, int il, int iu, int *ns, float *s, _Complex float *u, int ldu, _Complex float *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_cgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, float vl, float vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_cgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdx$descriptor() {
        return LAPACKE_zgesvdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdx$handle() {
        return LAPACKE_zgesvdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdx$address() {
        return LAPACKE_zgesvdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdx(int matrix_layout, char jobu, char jobvt, char range, int m, int n, _Complex double *a, int lda, double vl, double vu, int il, int iu, int *ns, double *s, _Complex double *u, int ldu, _Complex double *vt, int ldvt, int *superb)
     * }
     */
    public static int LAPACKE_zgesvdx(int matrix_layout, byte jobu, byte jobvt, byte range, int m, int n, MemorySegment a, int lda, double vl, double vu, int il, int iu, MemorySegment ns, MemorySegment s, MemorySegment u, int ldu, MemorySegment vt, int ldvt, MemorySegment superb) {
        var mh$ = LAPACKE_zgesvdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdx", matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
            }
            return (int)mh$.invokeExact(matrix_layout, jobu, jobvt, range, m, n, a, lda, vl, vu, il, iu, ns, s, u, ldu, vt, ldvt, superb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvdq$descriptor() {
        return LAPACKE_sgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_sgesvdq$handle() {
        return LAPACKE_sgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_sgesvdq$address() {
        return LAPACKE_sgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, float *a, int lda, float *s, float *u, int ldu, float *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_sgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_sgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvdq$descriptor() {
        return LAPACKE_dgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_dgesvdq$handle() {
        return LAPACKE_dgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_dgesvdq$address() {
        return LAPACKE_dgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, double *a, int lda, double *s, double *u, int ldu, double *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_dgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_dgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvdq$descriptor() {
        return LAPACKE_cgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_cgesvdq$handle() {
        return LAPACKE_cgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_cgesvdq$address() {
        return LAPACKE_cgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *s, _Complex float *u, int ldu, _Complex float *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_cgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_cgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvdq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvdq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvdq$descriptor() {
        return LAPACKE_zgesvdq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static MethodHandle LAPACKE_zgesvdq$handle() {
        return LAPACKE_zgesvdq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static MemorySegment LAPACKE_zgesvdq$address() {
        return LAPACKE_zgesvdq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvdq(int matrix_layout, char joba, char jobp, char jobr, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *s, _Complex double *u, int ldu, _Complex double *v, int ldv, int *numrank)
     * }
     */
    public static int LAPACKE_zgesvdq(int matrix_layout, byte joba, byte jobp, byte jobr, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment s, MemorySegment u, int ldu, MemorySegment v, int ldv, MemorySegment numrank) {
        var mh$ = LAPACKE_zgesvdq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvdq", matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobp, jobr, jobu, jobv, m, n, a, lda, s, u, ldu, v, ldv, numrank);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvj$descriptor() {
        return LAPACKE_sgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static MethodHandle LAPACKE_sgesvj$handle() {
        return LAPACKE_sgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static MemorySegment LAPACKE_sgesvj$address() {
        return LAPACKE_sgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, float *a, int lda, float *sva, int mv, float *v, int ldv, float *stat)
     * }
     */
    public static int LAPACKE_sgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_sgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvj$descriptor() {
        return LAPACKE_dgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static MethodHandle LAPACKE_dgesvj$handle() {
        return LAPACKE_dgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static MemorySegment LAPACKE_dgesvj$address() {
        return LAPACKE_dgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, double *a, int lda, double *sva, int mv, double *v, int ldv, double *stat)
     * }
     */
    public static int LAPACKE_dgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_dgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvj$descriptor() {
        return LAPACKE_cgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static MethodHandle LAPACKE_cgesvj$handle() {
        return LAPACKE_cgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static MemorySegment LAPACKE_cgesvj$address() {
        return LAPACKE_cgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex float *a, int lda, float *sva, int mv, _Complex float *v, int ldv, float *stat)
     * }
     */
    public static int LAPACKE_cgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_cgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvj$descriptor() {
        return LAPACKE_zgesvj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static MethodHandle LAPACKE_zgesvj$handle() {
        return LAPACKE_zgesvj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static MemorySegment LAPACKE_zgesvj$address() {
        return LAPACKE_zgesvj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvj(int matrix_layout, char joba, char jobu, char jobv, int m, int n, _Complex double *a, int lda, double *sva, int mv, _Complex double *v, int ldv, double *stat)
     * }
     */
    public static int LAPACKE_zgesvj(int matrix_layout, byte joba, byte jobu, byte jobv, int m, int n, MemorySegment a, int lda, MemorySegment sva, int mv, MemorySegment v, int ldv, MemorySegment stat) {
        var mh$ = LAPACKE_zgesvj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvj", matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
            }
            return (int)mh$.invokeExact(matrix_layout, joba, jobu, jobv, m, n, a, lda, sva, mv, v, ldv, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvx$descriptor() {
        return LAPACKE_sgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_sgesvx$handle() {
        return LAPACKE_sgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_sgesvx$address() {
        return LAPACKE_sgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_sgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_sgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvx$descriptor() {
        return LAPACKE_dgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_dgesvx$handle() {
        return LAPACKE_dgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_dgesvx$address() {
        return LAPACKE_dgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_dgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_dgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvx$descriptor() {
        return LAPACKE_cgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_cgesvx$handle() {
        return LAPACKE_cgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_cgesvx$address() {
        return LAPACKE_cgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *ferr, float *berr, float *rpivot)
     * }
     */
    public static int LAPACKE_cgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_cgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvx$descriptor() {
        return LAPACKE_zgesvx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MethodHandle LAPACKE_zgesvx$handle() {
        return LAPACKE_zgesvx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static MemorySegment LAPACKE_zgesvx$address() {
        return LAPACKE_zgesvx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *ferr, double *berr, double *rpivot)
     * }
     */
    public static int LAPACKE_zgesvx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment rpivot) {
        var mh$ = LAPACKE_zgesvx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, ferr, berr, rpivot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgesvxx$descriptor() {
        return LAPACKE_sgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_sgesvxx$handle() {
        return LAPACKE_sgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_sgesvxx$address() {
        return LAPACKE_sgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, float *a, int lda, float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, float *b, int ldb, float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_sgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_sgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgesvxx$descriptor() {
        return LAPACKE_dgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_dgesvxx$handle() {
        return LAPACKE_dgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_dgesvxx$address() {
        return LAPACKE_dgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, double *a, int lda, double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, double *b, int ldb, double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_dgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_dgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgesvxx$descriptor() {
        return LAPACKE_cgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MethodHandle LAPACKE_cgesvxx$handle() {
        return LAPACKE_cgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static MemorySegment LAPACKE_cgesvxx$address() {
        return LAPACKE_cgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex float *a, int lda, _Complex float *af, int ldaf, int *ipiv, char *equed, float *r, float *c, _Complex float *b, int ldb, _Complex float *x, int ldx, float *rcond, float *rpvgrw, float *berr, int n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, int nparams, float *params)
     * }
     */
    public static int LAPACKE_cgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_cgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgesvxx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgesvxx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgesvxx$descriptor() {
        return LAPACKE_zgesvxx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MethodHandle LAPACKE_zgesvxx$handle() {
        return LAPACKE_zgesvxx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static MemorySegment LAPACKE_zgesvxx$address() {
        return LAPACKE_zgesvxx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgesvxx(int matrix_layout, char fact, char trans, int n, int nrhs, _Complex double *a, int lda, _Complex double *af, int ldaf, int *ipiv, char *equed, double *r, double *c, _Complex double *b, int ldb, _Complex double *x, int ldx, double *rcond, double *rpvgrw, double *berr, int n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, int nparams, double *params)
     * }
     */
    public static int LAPACKE_zgesvxx(int matrix_layout, byte fact, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment af, int ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment r, MemorySegment c, MemorySegment b, int ldb, MemorySegment x, int ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, int n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, int nparams, MemorySegment params) {
        var mh$ = LAPACKE_zgesvxx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgesvxx", matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
            }
            return (int)mh$.invokeExact(matrix_layout, fact, trans, n, nrhs, a, lda, af, ldaf, ipiv, equed, r, c, b, ldb, x, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetf2$descriptor() {
        return LAPACKE_sgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetf2$handle() {
        return LAPACKE_sgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetf2$address() {
        return LAPACKE_sgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetf2$descriptor() {
        return LAPACKE_dgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetf2$handle() {
        return LAPACKE_dgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetf2$address() {
        return LAPACKE_dgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetf2$descriptor() {
        return LAPACKE_cgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetf2$handle() {
        return LAPACKE_cgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetf2$address() {
        return LAPACKE_cgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetf2$descriptor() {
        return LAPACKE_zgetf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetf2$handle() {
        return LAPACKE_zgetf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetf2$address() {
        return LAPACKE_zgetf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf$descriptor() {
        return LAPACKE_sgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf$handle() {
        return LAPACKE_sgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf$address() {
        return LAPACKE_sgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf$descriptor() {
        return LAPACKE_dgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf$handle() {
        return LAPACKE_dgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf$address() {
        return LAPACKE_dgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf$descriptor() {
        return LAPACKE_cgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf$handle() {
        return LAPACKE_cgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf$address() {
        return LAPACKE_cgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf$descriptor() {
        return LAPACKE_zgetrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf$handle() {
        return LAPACKE_zgetrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf$address() {
        return LAPACKE_zgetrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrf2$descriptor() {
        return LAPACKE_sgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetrf2$handle() {
        return LAPACKE_sgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetrf2$address() {
        return LAPACKE_sgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrf2(int matrix_layout, int m, int n, float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_sgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrf2$descriptor() {
        return LAPACKE_dgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetrf2$handle() {
        return LAPACKE_dgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetrf2$address() {
        return LAPACKE_dgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrf2(int matrix_layout, int m, int n, double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_dgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrf2$descriptor() {
        return LAPACKE_cgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetrf2$handle() {
        return LAPACKE_cgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetrf2$address() {
        return LAPACKE_cgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrf2(int matrix_layout, int m, int n, _Complex float *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_cgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrf2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrf2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrf2$descriptor() {
        return LAPACKE_zgetrf2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetrf2$handle() {
        return LAPACKE_zgetrf2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetrf2$address() {
        return LAPACKE_zgetrf2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrf2(int matrix_layout, int m, int n, _Complex double *a, int lda, int *ipiv)
     * }
     */
    public static int LAPACKE_zgetrf2(int matrix_layout, int m, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetrf2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrf2", matrix_layout, m, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetri$descriptor() {
        return LAPACKE_sgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_sgetri$handle() {
        return LAPACKE_sgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_sgetri$address() {
        return LAPACKE_sgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetri(int matrix_layout, int n, float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_sgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_sgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetri$descriptor() {
        return LAPACKE_dgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_dgetri$handle() {
        return LAPACKE_dgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_dgetri$address() {
        return LAPACKE_dgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetri(int matrix_layout, int n, double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_dgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_dgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetri$descriptor() {
        return LAPACKE_cgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_cgetri$handle() {
        return LAPACKE_cgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_cgetri$address() {
        return LAPACKE_cgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetri(int matrix_layout, int n, _Complex float *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_cgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_cgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetri$descriptor() {
        return LAPACKE_zgetri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MethodHandle LAPACKE_zgetri$handle() {
        return LAPACKE_zgetri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static MemorySegment LAPACKE_zgetri$address() {
        return LAPACKE_zgetri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetri(int matrix_layout, int n, _Complex double *a, int lda, const int *ipiv)
     * }
     */
    public static int LAPACKE_zgetri(int matrix_layout, int n, MemorySegment a, int lda, MemorySegment ipiv) {
        var mh$ = LAPACKE_zgetri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetri", matrix_layout, n, a, lda, ipiv);
            }
            return (int)mh$.invokeExact(matrix_layout, n, a, lda, ipiv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgetrs$descriptor() {
        return LAPACKE_sgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_sgetrs$handle() {
        return LAPACKE_sgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_sgetrs$address() {
        return LAPACKE_sgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgetrs(int matrix_layout, char trans, int n, int nrhs, const float *a, int lda, const int *ipiv, float *b, int ldb)
     * }
     */
    public static int LAPACKE_sgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_sgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgetrs$descriptor() {
        return LAPACKE_dgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_dgetrs$handle() {
        return LAPACKE_dgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_dgetrs$address() {
        return LAPACKE_dgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgetrs(int matrix_layout, char trans, int n, int nrhs, const double *a, int lda, const int *ipiv, double *b, int ldb)
     * }
     */
    public static int LAPACKE_dgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_dgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgetrs$descriptor() {
        return LAPACKE_cgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_cgetrs$handle() {
        return LAPACKE_cgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_cgetrs$address() {
        return LAPACKE_cgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex float *a, int lda, const int *ipiv, _Complex float *b, int ldb)
     * }
     */
    public static int LAPACKE_cgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_cgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgetrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgetrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgetrs$descriptor() {
        return LAPACKE_zgetrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MethodHandle LAPACKE_zgetrs$handle() {
        return LAPACKE_zgetrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static MemorySegment LAPACKE_zgetrs$address() {
        return LAPACKE_zgetrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgetrs(int matrix_layout, char trans, int n, int nrhs, const _Complex double *a, int lda, const int *ipiv, _Complex double *b, int ldb)
     * }
     */
    public static int LAPACKE_zgetrs(int matrix_layout, byte trans, int n, int nrhs, MemorySegment a, int lda, MemorySegment ipiv, MemorySegment b, int ldb) {
        var mh$ = LAPACKE_zgetrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgetrs", matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
            }
            return (int)mh$.invokeExact(matrix_layout, trans, n, nrhs, a, lda, ipiv, b, ldb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbak$descriptor() {
        return LAPACKE_sggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_sggbak$handle() {
        return LAPACKE_sggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_sggbak$address() {
        return LAPACKE_sggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, float *v, int ldv)
     * }
     */
    public static int LAPACKE_sggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_sggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbak$descriptor() {
        return LAPACKE_dggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_dggbak$handle() {
        return LAPACKE_dggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_dggbak$address() {
        return LAPACKE_dggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, double *v, int ldv)
     * }
     */
    public static int LAPACKE_dggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_dggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbak$descriptor() {
        return LAPACKE_cggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_cggbak$handle() {
        return LAPACKE_cggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_cggbak$address() {
        return LAPACKE_cggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const float *lscale, const float *rscale, int m, _Complex float *v, int ldv)
     * }
     */
    public static int LAPACKE_cggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_cggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggbak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbak$descriptor() {
        return LAPACKE_zggbak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MethodHandle LAPACKE_zggbak$handle() {
        return LAPACKE_zggbak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static MemorySegment LAPACKE_zggbak$address() {
        return LAPACKE_zggbak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbak(int matrix_layout, char job, char side, int n, int ilo, int ihi, const double *lscale, const double *rscale, int m, _Complex double *v, int ldv)
     * }
     */
    public static int LAPACKE_zggbak(int matrix_layout, byte job, byte side, int n, int ilo, int ihi, MemorySegment lscale, MemorySegment rscale, int m, MemorySegment v, int ldv) {
        var mh$ = LAPACKE_zggbak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbak", matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
            }
            return (int)mh$.invokeExact(matrix_layout, job, side, n, ilo, ihi, lscale, rscale, m, v, ldv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggbal$descriptor() {
        return LAPACKE_sggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MethodHandle LAPACKE_sggbal$handle() {
        return LAPACKE_sggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MemorySegment LAPACKE_sggbal$address() {
        return LAPACKE_sggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggbal(int matrix_layout, char job, int n, float *a, int lda, float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static int LAPACKE_sggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_sggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggbal$descriptor() {
        return LAPACKE_dggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MethodHandle LAPACKE_dggbal$handle() {
        return LAPACKE_dggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MemorySegment LAPACKE_dggbal$address() {
        return LAPACKE_dggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggbal(int matrix_layout, char job, int n, double *a, int lda, double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static int LAPACKE_dggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_dggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggbal$descriptor() {
        return LAPACKE_cggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MethodHandle LAPACKE_cggbal$handle() {
        return LAPACKE_cggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static MemorySegment LAPACKE_cggbal$address() {
        return LAPACKE_cggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggbal(int matrix_layout, char job, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *ilo, int *ihi, float *lscale, float *rscale)
     * }
     */
    public static int LAPACKE_cggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_cggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggbal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggbal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggbal$descriptor() {
        return LAPACKE_zggbal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MethodHandle LAPACKE_zggbal$handle() {
        return LAPACKE_zggbal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static MemorySegment LAPACKE_zggbal$address() {
        return LAPACKE_zggbal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggbal(int matrix_layout, char job, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *ilo, int *ihi, double *lscale, double *rscale)
     * }
     */
    public static int LAPACKE_zggbal(int matrix_layout, byte job, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale) {
        var mh$ = LAPACKE_zggbal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggbal", matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
            }
            return (int)mh$.invokeExact(matrix_layout, job, n, a, lda, b, ldb, ilo, ihi, lscale, rscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges$descriptor() {
        return LAPACKE_sgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_sgges$handle() {
        return LAPACKE_sgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_sgges$address() {
        return LAPACKE_sgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_sgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_sgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges$descriptor() {
        return LAPACKE_dgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_dgges$handle() {
        return LAPACKE_dgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_dgges$address() {
        return LAPACKE_dgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_dgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_dgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges$descriptor() {
        return LAPACKE_cgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_cgges$handle() {
        return LAPACKE_cgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_cgges$address() {
        return LAPACKE_cgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_cgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_cgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges$descriptor() {
        return LAPACKE_zgges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_zgges$handle() {
        return LAPACKE_zgges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_zgges$address() {
        return LAPACKE_zgges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_zgges(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_zgges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgges3$descriptor() {
        return LAPACKE_sgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_sgges3$handle() {
        return LAPACKE_sgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_sgges3$address() {
        return LAPACKE_sgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_sgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_sgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgges3$descriptor() {
        return LAPACKE_dgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_dgges3$handle() {
        return LAPACKE_dgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_dgges3$address() {
        return LAPACKE_dgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_dgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_dgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgges3$descriptor() {
        return LAPACKE_cgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_cgges3$handle() {
        return LAPACKE_cgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_cgges3$address() {
        return LAPACKE_cgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_cgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_cgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgges3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgges3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgges3$descriptor() {
        return LAPACKE_zgges3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MethodHandle LAPACKE_zgges3$handle() {
        return LAPACKE_zgges3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static MemorySegment LAPACKE_zgges3$address() {
        return LAPACKE_zgges3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgges3(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr)
     * }
     */
    public static int LAPACKE_zgges3(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr) {
        var mh$ = LAPACKE_zgges3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgges3", matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggesx$descriptor() {
        return LAPACKE_sggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sggesx$handle() {
        return LAPACKE_sggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sggesx$address() {
        return LAPACKE_sggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_S_SELECT3 selctg, char sense, int n, float *a, int lda, float *b, int ldb, int *sdim, float *alphar, float *alphai, float *beta, float *vsl, int ldvsl, float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggesx$descriptor() {
        return LAPACKE_dggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dggesx$handle() {
        return LAPACKE_dggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dggesx$address() {
        return LAPACKE_dggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_D_SELECT3 selctg, char sense, int n, double *a, int lda, double *b, int ldb, int *sdim, double *alphar, double *alphai, double *beta, double *vsl, int ldvsl, double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alphar, alphai, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggesx$descriptor() {
        return LAPACKE_cggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cggesx$handle() {
        return LAPACKE_cggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cggesx$address() {
        return LAPACKE_cggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_C_SELECT2 selctg, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *vsl, int ldvsl, _Complex float *vsr, int ldvsr, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggesx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_POINTER,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggesx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggesx$descriptor() {
        return LAPACKE_zggesx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zggesx$handle() {
        return LAPACKE_zggesx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zggesx$address() {
        return LAPACKE_zggesx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggesx(int matrix_layout, char jobvsl, char jobvsr, char sort, LAPACK_Z_SELECT2 selctg, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *vsl, int ldvsl, _Complex double *vsr, int ldvsr, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zggesx(int matrix_layout, byte jobvsl, byte jobvsr, byte sort, MemorySegment selctg, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment vsl, int ldvsl, MemorySegment vsr, int ldvsr, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zggesx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggesx", matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvsl, jobvsr, sort, selctg, sense, n, a, lda, b, ldb, sdim, alpha, beta, vsl, ldvsl, vsr, ldvsr, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev$descriptor() {
        return LAPACKE_sggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sggev$handle() {
        return LAPACKE_sggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sggev$address() {
        return LAPACKE_sggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev$descriptor() {
        return LAPACKE_dggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dggev$handle() {
        return LAPACKE_dggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dggev$address() {
        return LAPACKE_dggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev$descriptor() {
        return LAPACKE_cggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cggev$handle() {
        return LAPACKE_cggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cggev$address() {
        return LAPACKE_cggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev$descriptor() {
        return LAPACKE_zggev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zggev$handle() {
        return LAPACKE_zggev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zggev$address() {
        return LAPACKE_zggev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zggev(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zggev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggev3$descriptor() {
        return LAPACKE_sggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_sggev3$handle() {
        return LAPACKE_sggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_sggev3$address() {
        return LAPACKE_sggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggev3(int matrix_layout, char jobvl, char jobvr, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_sggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_sggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggev3$descriptor() {
        return LAPACKE_dggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_dggev3$handle() {
        return LAPACKE_dggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_dggev3$address() {
        return LAPACKE_dggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggev3(int matrix_layout, char jobvl, char jobvr, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_dggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_dggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggev3$descriptor() {
        return LAPACKE_cggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_cggev3$handle() {
        return LAPACKE_cggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_cggev3$address() {
        return LAPACKE_cggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr)
     * }
     */
    public static int LAPACKE_cggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_cggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggev3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggev3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggev3$descriptor() {
        return LAPACKE_zggev3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MethodHandle LAPACKE_zggev3$handle() {
        return LAPACKE_zggev3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static MemorySegment LAPACKE_zggev3$address() {
        return LAPACKE_zggev3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggev3(int matrix_layout, char jobvl, char jobvr, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr)
     * }
     */
    public static int LAPACKE_zggev3(int matrix_layout, byte jobvl, byte jobvr, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr) {
        var mh$ = LAPACKE_zggev3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggev3", matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
            }
            return (int)mh$.invokeExact(matrix_layout, jobvl, jobvr, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggevx$descriptor() {
        return LAPACKE_sggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_sggevx$handle() {
        return LAPACKE_sggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_sggevx$address() {
        return LAPACKE_sggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, float *a, int lda, float *b, int ldb, float *alphar, float *alphai, float *beta, float *vl, int ldvl, float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_sggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_sggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggevx$descriptor() {
        return LAPACKE_dggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_dggevx$handle() {
        return LAPACKE_dggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_dggevx$address() {
        return LAPACKE_dggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, double *a, int lda, double *b, int ldb, double *alphar, double *alphai, double *beta, double *vl, int ldvl, double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_dggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_dggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggevx$descriptor() {
        return LAPACKE_cggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_cggevx$handle() {
        return LAPACKE_cggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_cggevx$address() {
        return LAPACKE_cggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *alpha, _Complex float *beta, _Complex float *vl, int ldvl, _Complex float *vr, int ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv)
     * }
     */
    public static int LAPACKE_cggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_cggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggevx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggevx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggevx$descriptor() {
        return LAPACKE_zggevx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MethodHandle LAPACKE_zggevx$handle() {
        return LAPACKE_zggevx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static MemorySegment LAPACKE_zggevx$address() {
        return LAPACKE_zggevx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggevx(int matrix_layout, char balanc, char jobvl, char jobvr, char sense, int n, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *alpha, _Complex double *beta, _Complex double *vl, int ldvl, _Complex double *vr, int ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv)
     * }
     */
    public static int LAPACKE_zggevx(int matrix_layout, byte balanc, byte jobvl, byte jobvr, byte sense, int n, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment alpha, MemorySegment beta, MemorySegment vl, int ldvl, MemorySegment vr, int ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv) {
        var mh$ = LAPACKE_zggevx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggevx", matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
            }
            return (int)mh$.invokeExact(matrix_layout, balanc, jobvl, jobvr, sense, n, a, lda, b, ldb, alpha, beta, vl, ldvl, vr, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggglm$descriptor() {
        return LAPACKE_sggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static MethodHandle LAPACKE_sggglm$handle() {
        return LAPACKE_sggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static MemorySegment LAPACKE_sggglm$address() {
        return LAPACKE_sggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, float *a, int lda, float *b, int ldb, float *d, float *x, float *y)
     * }
     */
    public static int LAPACKE_sggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_sggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_dggglm$descriptor() {
        return LAPACKE_dggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static MethodHandle LAPACKE_dggglm$handle() {
        return LAPACKE_dggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static MemorySegment LAPACKE_dggglm$address() {
        return LAPACKE_dggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, double *a, int lda, double *b, int ldb, double *d, double *x, double *y)
     * }
     */
    public static int LAPACKE_dggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_dggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_cggglm$descriptor() {
        return LAPACKE_cggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static MethodHandle LAPACKE_cggglm$handle() {
        return LAPACKE_cggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static MemorySegment LAPACKE_cggglm$address() {
        return LAPACKE_cggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *d, _Complex float *x, _Complex float *y)
     * }
     */
    public static int LAPACKE_cggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_cggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zggglm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zggglm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static FunctionDescriptor LAPACKE_zggglm$descriptor() {
        return LAPACKE_zggglm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static MethodHandle LAPACKE_zggglm$handle() {
        return LAPACKE_zggglm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static MemorySegment LAPACKE_zggglm$address() {
        return LAPACKE_zggglm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *d, _Complex double *x, _Complex double *y)
     * }
     */
    public static int LAPACKE_zggglm(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment d, MemorySegment x, MemorySegment y) {
        var mh$ = LAPACKE_zggglm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zggglm", matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, b, ldb, d, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghrd$descriptor() {
        return LAPACKE_sgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghrd$handle() {
        return LAPACKE_sgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghrd$address() {
        return LAPACKE_sgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghrd$descriptor() {
        return LAPACKE_dgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghrd$handle() {
        return LAPACKE_dgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghrd$address() {
        return LAPACKE_dgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghrd$descriptor() {
        return LAPACKE_cgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghrd$handle() {
        return LAPACKE_cgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghrd$address() {
        return LAPACKE_cgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghrd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgghrd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghrd$descriptor() {
        return LAPACKE_zgghrd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghrd$handle() {
        return LAPACKE_zgghrd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghrd$address() {
        return LAPACKE_zgghrd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghrd(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghrd(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghrd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghrd", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgghd3$descriptor() {
        return LAPACKE_sgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_sgghd3$handle() {
        return LAPACKE_sgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_sgghd3$address() {
        return LAPACKE_sgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, float *a, int lda, float *b, int ldb, float *q, int ldq, float *z, int ldz)
     * }
     */
    public static int LAPACKE_sgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_sgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgghd3$descriptor() {
        return LAPACKE_dgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_dgghd3$handle() {
        return LAPACKE_dgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_dgghd3$address() {
        return LAPACKE_dgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, double *a, int lda, double *b, int ldb, double *q, int ldq, double *z, int ldz)
     * }
     */
    public static int LAPACKE_dgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_dgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgghd3$descriptor() {
        return LAPACKE_cgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_cgghd3$handle() {
        return LAPACKE_cgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_cgghd3$address() {
        return LAPACKE_cgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *q, int ldq, _Complex float *z, int ldz)
     * }
     */
    public static int LAPACKE_cgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_cgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgghd3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_CHAR,
            lapacke_h.C_CHAR,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgghd3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgghd3$descriptor() {
        return LAPACKE_zgghd3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MethodHandle LAPACKE_zgghd3$handle() {
        return LAPACKE_zgghd3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static MemorySegment LAPACKE_zgghd3$address() {
        return LAPACKE_zgghd3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgghd3(int matrix_layout, char compq, char compz, int n, int ilo, int ihi, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *q, int ldq, _Complex double *z, int ldz)
     * }
     */
    public static int LAPACKE_zgghd3(int matrix_layout, byte compq, byte compz, int n, int ilo, int ihi, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment q, int ldq, MemorySegment z, int ldz) {
        var mh$ = LAPACKE_zgghd3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgghd3", matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
            }
            return (int)mh$.invokeExact(matrix_layout, compq, compz, n, ilo, ihi, a, lda, b, ldb, q, ldq, z, ldz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_sgglse$descriptor() {
        return LAPACKE_sgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static MethodHandle LAPACKE_sgglse$handle() {
        return LAPACKE_sgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static MemorySegment LAPACKE_sgglse$address() {
        return LAPACKE_sgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, float *a, int lda, float *b, int ldb, float *c, float *d, float *x)
     * }
     */
    public static int LAPACKE_sgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_sgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_dgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_dgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_dgglse$descriptor() {
        return LAPACKE_dgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static MethodHandle LAPACKE_dgglse$handle() {
        return LAPACKE_dgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static MemorySegment LAPACKE_dgglse$address() {
        return LAPACKE_dgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, double *a, int lda, double *b, int ldb, double *c, double *d, double *x)
     * }
     */
    public static int LAPACKE_dgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_dgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_dgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_cgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_cgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_cgglse$descriptor() {
        return LAPACKE_cgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static MethodHandle LAPACKE_cgglse$handle() {
        return LAPACKE_cgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static MemorySegment LAPACKE_cgglse$address() {
        return LAPACKE_cgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, _Complex float *a, int lda, _Complex float *b, int ldb, _Complex float *c, _Complex float *d, _Complex float *x)
     * }
     */
    public static int LAPACKE_cgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_cgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_cgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_zgglse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_zgglse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static FunctionDescriptor LAPACKE_zgglse$descriptor() {
        return LAPACKE_zgglse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static MethodHandle LAPACKE_zgglse$handle() {
        return LAPACKE_zgglse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static MemorySegment LAPACKE_zgglse$address() {
        return LAPACKE_zgglse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, _Complex double *a, int lda, _Complex double *b, int ldb, _Complex double *c, _Complex double *d, _Complex double *x)
     * }
     */
    public static int LAPACKE_zgglse(int matrix_layout, int m, int n, int p, MemorySegment a, int lda, MemorySegment b, int ldb, MemorySegment c, MemorySegment d, MemorySegment x) {
        var mh$ = LAPACKE_zgglse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_zgglse", matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
            }
            return (int)mh$.invokeExact(matrix_layout, m, n, p, a, lda, b, ldb, c, d, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LAPACKE_sggqrf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("LAPACKE_sggqrf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static FunctionDescriptor LAPACKE_sggqrf$descriptor() {
        return LAPACKE_sggqrf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MethodHandle LAPACKE_sggqrf$handle() {
        return LAPACKE_sggqrf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static MemorySegment LAPACKE_sggqrf$address() {
        return LAPACKE_sggqrf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, float *a, int lda, float *taua, float *b, int ldb, float *taub)
     * }
     */
    public static int LAPACKE_sggqrf(int matrix_layout, int n, int m, int p, MemorySegment a, int lda, MemorySegment taua, MemorySegment b, int ldb, MemorySegment taub) {
        var mh$ = LAPACKE_sggqrf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LAPACKE_sggqrf", matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
            }
            return (int)mh$.invokeExact(matrix_layout, n, m, p, a, lda, taua, b, ldb, taub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

