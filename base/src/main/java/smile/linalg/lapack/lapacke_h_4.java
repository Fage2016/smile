// Generated by jextract

package smile.linalg.lapack;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class lapacke_h_4 {

    lapacke_h_4() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final String OS = System.getProperty("os.name", "linux").toLowerCase().split(" ")[0];
    static final String LIBRARY_NAME = System.getProperty("smile.lib.lapack", switch (OS) {
        case "mac" -> "lapack"; // macOS's builtin Accelerate framework
        case "windows" -> "mkl_rt"; // Intel's MKL
        default -> "lapacke"; // LAPACKE
    });
    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName(LIBRARY_NAME), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _COMPLEX_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _COMPLEX_H 1
     * }
     */
    public static int _COMPLEX_H() {
        return _COMPLEX_H;
    }
    private static final int LAPACK_ROW_MAJOR = (int)101L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_ROW_MAJOR 101
     * }
     */
    public static int LAPACK_ROW_MAJOR() {
        return LAPACK_ROW_MAJOR;
    }
    private static final int LAPACK_COL_MAJOR = (int)102L;
    /**
     * {@snippet lang=c :
     * #define LAPACK_COL_MAJOR 102
     * }
     */
    public static int LAPACK_COL_MAJOR() {
        return LAPACK_COL_MAJOR;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = lapacke_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = lapacke_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = lapacke_h.C_DOUBLE;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = lapacke_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = lapacke_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = lapacke_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = lapacke_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = lapacke_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = lapacke_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = lapacke_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = lapacke_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = lapacke_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = lapacke_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT    );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            lapacke_h.C_INT,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            lapacke_h.C_LONG_LONG,
            lapacke_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_POINTER,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_LONG,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacos$descriptor() {
        return cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MethodHandle cacos$handle() {
        return cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static MemorySegment cacos$address() {
        return cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacos(_Complex double __z)
     * }
     */
    public static double cacos(double __z) {
        var mh$ = cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cacos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacos$descriptor() {
        return __cacos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MethodHandle __cacos$handle() {
        return __cacos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static MemorySegment __cacos$address() {
        return __cacos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacos(_Complex double __z)
     * }
     */
    public static double __cacos(double __z) {
        var mh$ = __cacos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casin$descriptor() {
        return casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MethodHandle casin$handle() {
        return casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static MemorySegment casin$address() {
        return casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casin(_Complex double __z)
     * }
     */
    public static double casin(double __z) {
        var mh$ = casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__casin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casin$descriptor() {
        return __casin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MethodHandle __casin$handle() {
        return __casin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static MemorySegment __casin$address() {
        return __casin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casin(_Complex double __z)
     * }
     */
    public static double __casin(double __z) {
        var mh$ = __casin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catan$descriptor() {
        return catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MethodHandle catan$handle() {
        return catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static MemorySegment catan$address() {
        return catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catan(_Complex double __z)
     * }
     */
    public static double catan(double __z) {
        var mh$ = catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__catan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catan$descriptor() {
        return __catan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MethodHandle __catan$handle() {
        return __catan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static MemorySegment __catan$address() {
        return __catan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catan(_Complex double __z)
     * }
     */
    public static double __catan(double __z) {
        var mh$ = __catan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccos$descriptor() {
        return ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MethodHandle ccos$handle() {
        return ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static MemorySegment ccos$address() {
        return ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccos(_Complex double __z)
     * }
     */
    public static double ccos(double __z) {
        var mh$ = ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ccos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccos$descriptor() {
        return __ccos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MethodHandle __ccos$handle() {
        return __ccos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static MemorySegment __ccos$address() {
        return __ccos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccos(_Complex double __z)
     * }
     */
    public static double __ccos(double __z) {
        var mh$ = __ccos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccos", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csin$descriptor() {
        return csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MethodHandle csin$handle() {
        return csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static MemorySegment csin$address() {
        return csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csin(_Complex double __z)
     * }
     */
    public static double csin(double __z) {
        var mh$ = csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csin$descriptor() {
        return __csin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MethodHandle __csin$handle() {
        return __csin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static MemorySegment __csin$address() {
        return __csin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csin(_Complex double __z)
     * }
     */
    public static double __csin(double __z) {
        var mh$ = __csin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csin", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctan$descriptor() {
        return ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MethodHandle ctan$handle() {
        return ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static MemorySegment ctan$address() {
        return ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctan(_Complex double __z)
     * }
     */
    public static double ctan(double __z) {
        var mh$ = ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ctan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctan$descriptor() {
        return __ctan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MethodHandle __ctan$handle() {
        return __ctan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static MemorySegment __ctan$address() {
        return __ctan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctan(_Complex double __z)
     * }
     */
    public static double __ctan(double __z) {
        var mh$ = __ctan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctan", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cacosh$descriptor() {
        return cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle cacosh$handle() {
        return cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment cacosh$address() {
        return cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cacosh(_Complex double __z)
     * }
     */
    public static double cacosh(double __z) {
        var mh$ = cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cacosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cacosh$descriptor() {
        return __cacosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MethodHandle __cacosh$handle() {
        return __cacosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static MemorySegment __cacosh$address() {
        return __cacosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cacosh(_Complex double __z)
     * }
     */
    public static double __cacosh(double __z) {
        var mh$ = __cacosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor casinh$descriptor() {
        return casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MethodHandle casinh$handle() {
        return casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static MemorySegment casinh$address() {
        return casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double casinh(_Complex double __z)
     * }
     */
    public static double casinh(double __z) {
        var mh$ = casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__casinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __casinh$descriptor() {
        return __casinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MethodHandle __casinh$handle() {
        return __casinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static MemorySegment __casinh$address() {
        return __casinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __casinh(_Complex double __z)
     * }
     */
    public static double __casinh(double __z) {
        var mh$ = __casinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor catanh$descriptor() {
        return catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MethodHandle catanh$handle() {
        return catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static MemorySegment catanh$address() {
        return catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double catanh(_Complex double __z)
     * }
     */
    public static double catanh(double __z) {
        var mh$ = catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__catanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __catanh$descriptor() {
        return __catanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MethodHandle __catanh$handle() {
        return __catanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static MemorySegment __catanh$address() {
        return __catanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __catanh(_Complex double __z)
     * }
     */
    public static double __catanh(double __z) {
        var mh$ = __catanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ccosh$descriptor() {
        return ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle ccosh$handle() {
        return ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment ccosh$address() {
        return ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ccosh(_Complex double __z)
     * }
     */
    public static double ccosh(double __z) {
        var mh$ = ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ccosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ccosh$descriptor() {
        return __ccosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MethodHandle __ccosh$handle() {
        return __ccosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static MemorySegment __ccosh$address() {
        return __ccosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ccosh(_Complex double __z)
     * }
     */
    public static double __ccosh(double __z) {
        var mh$ = __ccosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csinh$descriptor() {
        return csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MethodHandle csinh$handle() {
        return csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static MemorySegment csinh$address() {
        return csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csinh(_Complex double __z)
     * }
     */
    public static double csinh(double __z) {
        var mh$ = csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csinh$descriptor() {
        return __csinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MethodHandle __csinh$handle() {
        return __csinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static MemorySegment __csinh$address() {
        return __csinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csinh(_Complex double __z)
     * }
     */
    public static double __csinh(double __z) {
        var mh$ = __csinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor ctanh$descriptor() {
        return ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle ctanh$handle() {
        return ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment ctanh$address() {
        return ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double ctanh(_Complex double __z)
     * }
     */
    public static double ctanh(double __z) {
        var mh$ = ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ctanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __ctanh$descriptor() {
        return __ctanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MethodHandle __ctanh$handle() {
        return __ctanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static MemorySegment __ctanh$address() {
        return __ctanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __ctanh(_Complex double __z)
     * }
     */
    public static double __ctanh(double __z) {
        var mh$ = __ctanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanh", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cexp$descriptor() {
        return cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MethodHandle cexp$handle() {
        return cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static MemorySegment cexp$address() {
        return cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cexp(_Complex double __z)
     * }
     */
    public static double cexp(double __z) {
        var mh$ = cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cexp$descriptor() {
        return __cexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MethodHandle __cexp$handle() {
        return __cexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static MemorySegment __cexp$address() {
        return __cexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cexp(_Complex double __z)
     * }
     */
    public static double __cexp(double __z) {
        var mh$ = __cexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexp", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor clog$descriptor() {
        return clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MethodHandle clog$handle() {
        return clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static MemorySegment clog$address() {
        return clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double clog(_Complex double __z)
     * }
     */
    public static double clog(double __z) {
        var mh$ = clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__clog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __clog$descriptor() {
        return __clog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MethodHandle __clog$handle() {
        return __clog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static MemorySegment __clog$address() {
        return __clog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __clog(_Complex double __z)
     * }
     */
    public static double __clog(double __z) {
        var mh$ = __clog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clog", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor cpow$descriptor() {
        return cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle cpow$handle() {
        return cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment cpow$address() {
        return cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double cpow(double __x, double __y) {
        var mh$ = cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cpow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static FunctionDescriptor __cpow$descriptor() {
        return __cpow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MethodHandle __cpow$handle() {
        return __cpow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static MemorySegment __cpow$address() {
        return __cpow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cpow(_Complex double __x, _Complex double __y)
     * }
     */
    public static double __cpow(double __x, double __y) {
        var mh$ = __cpow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor csqrt$descriptor() {
        return csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle csqrt$handle() {
        return csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment csqrt$address() {
        return csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double csqrt(_Complex double __z)
     * }
     */
    public static double csqrt(double __z) {
        var mh$ = csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __csqrt$descriptor() {
        return __csqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MethodHandle __csqrt$handle() {
        return __csqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static MemorySegment __csqrt$address() {
        return __csqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __csqrt(_Complex double __z)
     * }
     */
    public static double __csqrt(double __z) {
        var mh$ = __csqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrt", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cabs$descriptor() {
        return cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MethodHandle cabs$handle() {
        return cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static MemorySegment cabs$address() {
        return cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cabs(_Complex double __z)
     * }
     */
    public static double cabs(double __z) {
        var mh$ = cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cabs$descriptor() {
        return __cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MethodHandle __cabs$handle() {
        return __cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static MemorySegment __cabs$address() {
        return __cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cabs(_Complex double __z)
     * }
     */
    public static double __cabs(double __z) {
        var mh$ = __cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabs", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor carg$descriptor() {
        return carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MethodHandle carg$handle() {
        return carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static MemorySegment carg$address() {
        return carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double carg(_Complex double __z)
     * }
     */
    public static double carg(double __z) {
        var mh$ = carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __carg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__carg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __carg$descriptor() {
        return __carg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MethodHandle __carg$handle() {
        return __carg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static MemorySegment __carg$address() {
        return __carg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __carg(_Complex double __z)
     * }
     */
    public static double __carg(double __z) {
        var mh$ = __carg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__carg", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor conj$descriptor() {
        return conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MethodHandle conj$handle() {
        return conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static MemorySegment conj$address() {
        return conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double conj(_Complex double __z)
     * }
     */
    public static double conj(double __z) {
        var mh$ = conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__conj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __conj$descriptor() {
        return __conj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MethodHandle __conj$handle() {
        return __conj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static MemorySegment __conj$address() {
        return __conj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __conj(_Complex double __z)
     * }
     */
    public static double __conj(double __z) {
        var mh$ = __conj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cproj$descriptor() {
        return cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MethodHandle cproj$handle() {
        return cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static MemorySegment cproj$address() {
        return cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double cproj(_Complex double __z)
     * }
     */
    public static double cproj(double __z) {
        var mh$ = cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cproj$descriptor() {
        return __cproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MethodHandle __cproj$handle() {
        return __cproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static MemorySegment __cproj$address() {
        return __cproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex double __cproj(_Complex double __z)
     * }
     */
    public static double __cproj(double __z) {
        var mh$ = __cproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cproj", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor cimag$descriptor() {
        return cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MethodHandle cimag$handle() {
        return cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static MemorySegment cimag$address() {
        return cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cimag(_Complex double __z)
     * }
     */
    public static double cimag(double __z) {
        var mh$ = cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cimag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __cimag$descriptor() {
        return __cimag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MethodHandle __cimag$handle() {
        return __cimag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static MemorySegment __cimag$address() {
        return __cimag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cimag(_Complex double __z)
     * }
     */
    public static double __cimag(double __z) {
        var mh$ = __cimag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimag", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor creal$descriptor() {
        return creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MethodHandle creal$handle() {
        return creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static MemorySegment creal$address() {
        return creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double creal(_Complex double __z)
     * }
     */
    public static double creal(double __z) {
        var mh$ = creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __creal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__creal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static FunctionDescriptor __creal$descriptor() {
        return __creal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MethodHandle __creal$handle() {
        return __creal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static MemorySegment __creal$address() {
        return __creal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __creal(_Complex double __z)
     * }
     */
    public static double __creal(double __z) {
        var mh$ = __creal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__creal", __z);
            }
            return (double)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacosf$descriptor() {
        return cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle cacosf$handle() {
        return cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment cacosf$address() {
        return cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacosf(_Complex float __z)
     * }
     */
    public static float cacosf(float __z) {
        var mh$ = cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cacosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacosf$descriptor() {
        return __cacosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacosf$handle() {
        return __cacosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacosf$address() {
        return __cacosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacosf(_Complex float __z)
     * }
     */
    public static float __cacosf(float __z) {
        var mh$ = __cacosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinf$descriptor() {
        return casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MethodHandle casinf$handle() {
        return casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static MemorySegment casinf$address() {
        return casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinf(_Complex float __z)
     * }
     */
    public static float casinf(float __z) {
        var mh$ = casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__casinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinf$descriptor() {
        return __casinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinf$handle() {
        return __casinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinf$address() {
        return __casinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinf(_Complex float __z)
     * }
     */
    public static float __casinf(float __z) {
        var mh$ = __casinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanf$descriptor() {
        return catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MethodHandle catanf$handle() {
        return catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static MemorySegment catanf$address() {
        return catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanf(_Complex float __z)
     * }
     */
    public static float catanf(float __z) {
        var mh$ = catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__catanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanf$descriptor() {
        return __catanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanf$handle() {
        return __catanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanf$address() {
        return __catanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanf(_Complex float __z)
     * }
     */
    public static float __catanf(float __z) {
        var mh$ = __catanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccosf$descriptor() {
        return ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle ccosf$handle() {
        return ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment ccosf$address() {
        return ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccosf(_Complex float __z)
     * }
     */
    public static float ccosf(float __z) {
        var mh$ = ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ccosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccosf$descriptor() {
        return __ccosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccosf$handle() {
        return __ccosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccosf$address() {
        return __ccosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccosf(_Complex float __z)
     * }
     */
    public static float __ccosf(float __z) {
        var mh$ = __ccosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccosf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinf$descriptor() {
        return csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MethodHandle csinf$handle() {
        return csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static MemorySegment csinf$address() {
        return csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinf(_Complex float __z)
     * }
     */
    public static float csinf(float __z) {
        var mh$ = csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinf$descriptor() {
        return __csinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinf$handle() {
        return __csinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinf$address() {
        return __csinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinf(_Complex float __z)
     * }
     */
    public static float __csinf(float __z) {
        var mh$ = __csinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanf$descriptor() {
        return ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanf$handle() {
        return ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanf$address() {
        return ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanf(_Complex float __z)
     * }
     */
    public static float ctanf(float __z) {
        var mh$ = ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ctanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanf$descriptor() {
        return __ctanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanf$handle() {
        return __ctanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanf$address() {
        return __ctanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanf(_Complex float __z)
     * }
     */
    public static float __ctanf(float __z) {
        var mh$ = __ctanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cacoshf$descriptor() {
        return cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle cacoshf$handle() {
        return cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment cacoshf$address() {
        return cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cacoshf(_Complex float __z)
     * }
     */
    public static float cacoshf(float __z) {
        var mh$ = cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cacoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cacoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cacoshf$descriptor() {
        return __cacoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __cacoshf$handle() {
        return __cacoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __cacoshf$address() {
        return __cacoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cacoshf(_Complex float __z)
     * }
     */
    public static float __cacoshf(float __z) {
        var mh$ = __cacoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cacoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor casinhf$descriptor() {
        return casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle casinhf$handle() {
        return casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment casinhf$address() {
        return casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float casinhf(_Complex float __z)
     * }
     */
    public static float casinhf(float __z) {
        var mh$ = casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __casinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__casinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __casinhf$descriptor() {
        return __casinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __casinhf$handle() {
        return __casinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __casinhf$address() {
        return __casinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __casinhf(_Complex float __z)
     * }
     */
    public static float __casinhf(float __z) {
        var mh$ = __casinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__casinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor catanhf$descriptor() {
        return catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle catanhf$handle() {
        return catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment catanhf$address() {
        return catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float catanhf(_Complex float __z)
     * }
     */
    public static float catanhf(float __z) {
        var mh$ = catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __catanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__catanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __catanhf$descriptor() {
        return __catanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __catanhf$handle() {
        return __catanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __catanhf$address() {
        return __catanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __catanhf(_Complex float __z)
     * }
     */
    public static float __catanhf(float __z) {
        var mh$ = __catanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__catanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ccoshf$descriptor() {
        return ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle ccoshf$handle() {
        return ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment ccoshf$address() {
        return ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ccoshf(_Complex float __z)
     * }
     */
    public static float ccoshf(float __z) {
        var mh$ = ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ccoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ccoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ccoshf$descriptor() {
        return __ccoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MethodHandle __ccoshf$handle() {
        return __ccoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static MemorySegment __ccoshf$address() {
        return __ccoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ccoshf(_Complex float __z)
     * }
     */
    public static float __ccoshf(float __z) {
        var mh$ = __ccoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ccoshf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csinhf$descriptor() {
        return csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle csinhf$handle() {
        return csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment csinhf$address() {
        return csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csinhf(_Complex float __z)
     * }
     */
    public static float csinhf(float __z) {
        var mh$ = csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csinhf$descriptor() {
        return __csinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MethodHandle __csinhf$handle() {
        return __csinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static MemorySegment __csinhf$address() {
        return __csinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csinhf(_Complex float __z)
     * }
     */
    public static float __csinhf(float __z) {
        var mh$ = __csinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csinhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor ctanhf$descriptor() {
        return ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle ctanhf$handle() {
        return ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment ctanhf$address() {
        return ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float ctanhf(_Complex float __z)
     * }
     */
    public static float ctanhf(float __z) {
        var mh$ = ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__ctanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __ctanhf$descriptor() {
        return __ctanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MethodHandle __ctanhf$handle() {
        return __ctanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static MemorySegment __ctanhf$address() {
        return __ctanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __ctanhf(_Complex float __z)
     * }
     */
    public static float __ctanhf(float __z) {
        var mh$ = __ctanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctanhf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cexpf$descriptor() {
        return cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle cexpf$handle() {
        return cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment cexpf$address() {
        return cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cexpf(_Complex float __z)
     * }
     */
    public static float cexpf(float __z) {
        var mh$ = cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cexpf$descriptor() {
        return __cexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MethodHandle __cexpf$handle() {
        return __cexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static MemorySegment __cexpf$address() {
        return __cexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cexpf(_Complex float __z)
     * }
     */
    public static float __cexpf(float __z) {
        var mh$ = __cexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cexpf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor clogf$descriptor() {
        return clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MethodHandle clogf$handle() {
        return clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static MemorySegment clogf$address() {
        return clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float clogf(_Complex float __z)
     * }
     */
    public static float clogf(float __z) {
        var mh$ = clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __clogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__clogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __clogf$descriptor() {
        return __clogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MethodHandle __clogf$handle() {
        return __clogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static MemorySegment __clogf$address() {
        return __clogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __clogf(_Complex float __z)
     * }
     */
    public static float __clogf(float __z) {
        var mh$ = __clogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__clogf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor cpowf$descriptor() {
        return cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle cpowf$handle() {
        return cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment cpowf$address() {
        return cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float cpowf(float __x, float __y) {
        var mh$ = cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cpowf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cpowf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static FunctionDescriptor __cpowf$descriptor() {
        return __cpowf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MethodHandle __cpowf$handle() {
        return __cpowf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static MemorySegment __cpowf$address() {
        return __cpowf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cpowf(_Complex float __x, _Complex float __y)
     * }
     */
    public static float __cpowf(float __x, float __y) {
        var mh$ = __cpowf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cpowf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor csqrtf$descriptor() {
        return csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle csqrtf$handle() {
        return csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment csqrtf$address() {
        return csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float csqrtf(_Complex float __z)
     * }
     */
    public static float csqrtf(float __z) {
        var mh$ = csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __csqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__csqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __csqrtf$descriptor() {
        return __csqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MethodHandle __csqrtf$handle() {
        return __csqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static MemorySegment __csqrtf$address() {
        return __csqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __csqrtf(_Complex float __z)
     * }
     */
    public static float __csqrtf(float __z) {
        var mh$ = __csqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__csqrtf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cabsf$descriptor() {
        return cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle cabsf$handle() {
        return cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment cabsf$address() {
        return cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cabsf(_Complex float __z)
     * }
     */
    public static float cabsf(float __z) {
        var mh$ = cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cabsf$descriptor() {
        return __cabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MethodHandle __cabsf$handle() {
        return __cabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static MemorySegment __cabsf$address() {
        return __cabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cabsf(_Complex float __z)
     * }
     */
    public static float __cabsf(float __z) {
        var mh$ = __cabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cabsf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cargf$descriptor() {
        return cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MethodHandle cargf$handle() {
        return cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static MemorySegment cargf$address() {
        return cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cargf(_Complex float __z)
     * }
     */
    public static float cargf(float __z) {
        var mh$ = cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cargf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cargf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cargf$descriptor() {
        return __cargf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MethodHandle __cargf$handle() {
        return __cargf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static MemorySegment __cargf$address() {
        return __cargf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cargf(_Complex float __z)
     * }
     */
    public static float __cargf(float __z) {
        var mh$ = __cargf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cargf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor conjf$descriptor() {
        return conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MethodHandle conjf$handle() {
        return conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static MemorySegment conjf$address() {
        return conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float conjf(_Complex float __z)
     * }
     */
    public static float conjf(float __z) {
        var mh$ = conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __conjf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__conjf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __conjf$descriptor() {
        return __conjf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MethodHandle __conjf$handle() {
        return __conjf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static MemorySegment __conjf$address() {
        return __conjf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __conjf(_Complex float __z)
     * }
     */
    public static float __conjf(float __z) {
        var mh$ = __conjf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__conjf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cprojf$descriptor() {
        return cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle cprojf$handle() {
        return cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment cprojf$address() {
        return cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float cprojf(_Complex float __z)
     * }
     */
    public static float cprojf(float __z) {
        var mh$ = cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cprojf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cprojf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cprojf$descriptor() {
        return __cprojf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MethodHandle __cprojf$handle() {
        return __cprojf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static MemorySegment __cprojf$address() {
        return __cprojf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern _Complex float __cprojf(_Complex float __z)
     * }
     */
    public static float __cprojf(float __z) {
        var mh$ = __cprojf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cprojf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor cimagf$descriptor() {
        return cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle cimagf$handle() {
        return cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment cimagf$address() {
        return cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cimagf(_Complex float __z)
     * }
     */
    public static float cimagf(float __z) {
        var mh$ = cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cimagf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__cimagf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __cimagf$descriptor() {
        return __cimagf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MethodHandle __cimagf$handle() {
        return __cimagf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static MemorySegment __cimagf$address() {
        return __cimagf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cimagf(_Complex float __z)
     * }
     */
    public static float __cimagf(float __z) {
        var mh$ = __cimagf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cimagf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor crealf$descriptor() {
        return crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MethodHandle crealf$handle() {
        return crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static MemorySegment crealf$address() {
        return crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float crealf(_Complex float __z)
     * }
     */
    public static float crealf(float __z) {
        var mh$ = crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __crealf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_FLOAT
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("__crealf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static FunctionDescriptor __crealf$descriptor() {
        return __crealf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MethodHandle __crealf$handle() {
        return __crealf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static MemorySegment __crealf$address() {
        return __crealf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __crealf(_Complex float __z)
     * }
     */
    public static float __crealf(float __z) {
        var mh$ = __crealf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__crealf", __z);
            }
            return (float)mh$.invokeExact(__z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float lapack_float_return
     * }
     */
    public static final OfFloat lapack_float_return = lapacke_h.C_FLOAT;

    private static class lsame_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_INT,
            lapacke_h.C_INT,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("lsame_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static FunctionDescriptor lsame_$descriptor() {
        return lsame_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static MethodHandle lsame_$handle() {
        return lsame_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static MemorySegment lsame_$address() {
        return lsame_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lsame_(char *ca, char *cb, int lca, int lcb, size_t, size_t)
     * }
     */
    public static int lsame_(MemorySegment ca, MemorySegment cb, int lca, int lcb, long x4, long x5) {
        var mh$ = lsame_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsame_", ca, cb, lca, lcb, x4, x5);
            }
            return (int)mh$.invokeExact(ca, cb, lca, lcb, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cbbcsd_$descriptor() {
        return cbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cbbcsd_$handle() {
        return cbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cbbcsd_$address() {
        return cbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, _Complex float *U1, const int *ldu1, _Complex float *U2, const int *ldu2, _Complex float *V1T, const int *ldv1t, _Complex float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = cbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbbcsd_$descriptor() {
        return dbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dbbcsd_$handle() {
        return dbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dbbcsd_$address() {
        return dbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, double *U1, const int *ldu1, double *U2, const int *ldu2, double *V1T, const int *ldv1t, double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *b21d, double *b21e, double *b22d, double *b22e, double *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment b21d, MemorySegment b21e, MemorySegment b22d, MemorySegment b22e, MemorySegment work, MemorySegment lwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = dbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, b21d, b21e, b22d, b22e, work, lwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, b21d, b21e, b22d, b22e, work, lwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbbcsd_$descriptor() {
        return sbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sbbcsd_$handle() {
        return sbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sbbcsd_$address() {
        return sbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, float *theta, float *phi, float *U1, const int *ldu1, float *U2, const int *ldu2, float *V1T, const int *ldv1t, float *V2T, const int *ldv2t, float *B11D, float *B11E, float *B12D, float *B12E, float *B21D, float *B21E, float *B22D, float *B22E, float *work, const int *lwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment work, MemorySegment lwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = sbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, work, lwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, work, lwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zbbcsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zbbcsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zbbcsd_$descriptor() {
        return zbbcsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zbbcsd_$handle() {
        return zbbcsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zbbcsd_$address() {
        return zbbcsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zbbcsd_(const char *jobu1, const char *jobu2, const char *jobv1t, const char *jobv2t, const char *trans, const int *m, const int *p, const int *q, double *theta, double *phi, _Complex double *U1, const int *ldu1, _Complex double *U2, const int *ldu2, _Complex double *V1T, const int *ldv1t, _Complex double *V2T, const int *ldv2t, double *B11D, double *B11E, double *B12D, double *B12E, double *B21D, double *B21E, double *B22D, double *B22E, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zbbcsd_(MemorySegment jobu1, MemorySegment jobu2, MemorySegment jobv1t, MemorySegment jobv2t, MemorySegment trans, MemorySegment m, MemorySegment p, MemorySegment q, MemorySegment theta, MemorySegment phi, MemorySegment U1, MemorySegment ldu1, MemorySegment U2, MemorySegment ldu2, MemorySegment V1T, MemorySegment ldv1t, MemorySegment V2T, MemorySegment ldv2t, MemorySegment B11D, MemorySegment B11E, MemorySegment B12D, MemorySegment B12E, MemorySegment B21D, MemorySegment B21E, MemorySegment B22D, MemorySegment B22E, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x29, long x30, long x31, long x32, long x33) {
        var mh$ = zbbcsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zbbcsd_", jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
            }
            mh$.invokeExact(jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q, theta, phi, U1, ldu1, U2, ldu2, V1T, ldv1t, V2T, ldv2t, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, rwork, lrwork, info, x29, x30, x31, x32, x33);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbdsdc_$descriptor() {
        return dbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dbdsdc_$handle() {
        return dbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dbdsdc_$address() {
        return dbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsdc_(const char *uplo, const char *compq, const int *n, double *D, double *E, double *U, const int *ldu, double *VT, const int *ldvt, double *Q, int *IQ, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dbdsdc_(MemorySegment uplo, MemorySegment compq, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment Q, MemorySegment IQ, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14, long x15) {
        var mh$ = dbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsdc_", uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
            }
            mh$.invokeExact(uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsdc_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sbdsdc_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbdsdc_$descriptor() {
        return sbdsdc_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sbdsdc_$handle() {
        return sbdsdc_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sbdsdc_$address() {
        return sbdsdc_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsdc_(const char *uplo, const char *compq, const int *n, float *D, float *E, float *U, const int *ldu, float *VT, const int *ldvt, float *Q, int *IQ, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sbdsdc_(MemorySegment uplo, MemorySegment compq, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment Q, MemorySegment IQ, MemorySegment work, MemorySegment iwork, MemorySegment info, long x14, long x15) {
        var mh$ = sbdsdc_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsdc_", uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
            }
            mh$.invokeExact(uplo, compq, n, D, E, U, ldu, VT, ldvt, Q, IQ, work, iwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cbdsqr_$descriptor() {
        return cbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cbdsqr_$handle() {
        return cbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cbdsqr_$address() {
        return cbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, _Complex float *VT, const int *ldvt, _Complex float *U, const int *ldu, _Complex float *C, const int *ldc, float *rwork, int *info, size_t)
     * }
     */
    public static void cbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = cbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dbdsqr_$descriptor() {
        return dbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dbdsqr_$handle() {
        return dbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dbdsqr_$address() {
        return dbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, double *VT, const int *ldvt, double *U, const int *ldu, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static void dbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x15) {
        var mh$ = dbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sbdsqr_$descriptor() {
        return sbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sbdsqr_$handle() {
        return sbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sbdsqr_$address() {
        return sbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, float *D, float *E, float *VT, const int *ldvt, float *U, const int *ldu, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static void sbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x15) {
        var mh$ = sbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, work, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zbdsqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zbdsqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zbdsqr_$descriptor() {
        return zbdsqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zbdsqr_$handle() {
        return zbdsqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zbdsqr_$address() {
        return zbdsqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zbdsqr_(const char *uplo, const int *n, const int *ncvt, const int *nru, const int *ncc, double *D, double *E, _Complex double *VT, const int *ldvt, _Complex double *U, const int *ldu, _Complex double *C, const int *ldc, double *rwork, int *info, size_t)
     * }
     */
    public static void zbdsqr_(MemorySegment uplo, MemorySegment n, MemorySegment ncvt, MemorySegment nru, MemorySegment ncc, MemorySegment D, MemorySegment E, MemorySegment VT, MemorySegment ldvt, MemorySegment U, MemorySegment ldu, MemorySegment C, MemorySegment ldc, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zbdsqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zbdsqr_", uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, ncvt, nru, ncc, D, E, VT, ldvt, U, ldu, C, ldc, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dbdsvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dbdsvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dbdsvdx_$descriptor() {
        return dbdsvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dbdsvdx_$handle() {
        return dbdsvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dbdsvdx_$address() {
        return dbdsvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const double *D, const double *E, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *Z, const int *ldz, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dbdsvdx_(MemorySegment uplo, MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = dbdsvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dbdsvdx_", uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbdsvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sbdsvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sbdsvdx_$descriptor() {
        return sbdsvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sbdsvdx_$handle() {
        return sbdsvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sbdsvdx_$address() {
        return sbdsvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sbdsvdx_(const char *uplo, const char *jobz, const char *range, const int *n, const float *D, const float *E, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *Z, const int *ldz, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sbdsvdx_(MemorySegment uplo, MemorySegment jobz, MemorySegment range, MemorySegment n, MemorySegment D, MemorySegment E, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17, long x18, long x19) {
        var mh$ = sbdsvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbdsvdx_", uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
            }
            mh$.invokeExact(uplo, jobz, range, n, D, E, vl, vu, il, iu, ns, S, Z, ldz, work, iwork, info, x17, x18, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ddisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("ddisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor ddisna_$descriptor() {
        return ddisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static MethodHandle ddisna_$handle() {
        return ddisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static MemorySegment ddisna_$address() {
        return ddisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ddisna_(const char *job, const int *m, const int *n, const double *D, double *SEP, int *info, size_t)
     * }
     */
    public static void ddisna_(MemorySegment job, MemorySegment m, MemorySegment n, MemorySegment D, MemorySegment SEP, MemorySegment info, long x6) {
        var mh$ = ddisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ddisna_", job, m, n, D, SEP, info, x6);
            }
            mh$.invokeExact(job, m, n, D, SEP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sdisna_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sdisna_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sdisna_$descriptor() {
        return sdisna_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static MethodHandle sdisna_$handle() {
        return sdisna_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static MemorySegment sdisna_$address() {
        return sdisna_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sdisna_(const char *job, const int *m, const int *n, const float *D, float *SEP, int *info, size_t)
     * }
     */
    public static void sdisna_(MemorySegment job, MemorySegment m, MemorySegment n, MemorySegment D, MemorySegment SEP, MemorySegment info, long x6) {
        var mh$ = sdisna_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sdisna_", job, m, n, D, SEP, info, x6);
            }
            mh$.invokeExact(job, m, n, D, SEP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbbrd_$descriptor() {
        return cgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbbrd_$handle() {
        return cgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbbrd_$address() {
        return cgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *PT, const int *ldpt, _Complex float *C, const int *ldc, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = cgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbbrd_$descriptor() {
        return dgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dgbbrd_$handle() {
        return dgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dgbbrd_$address() {
        return dgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, double *AB, const int *ldab, double *D, double *E, double *Q, const int *ldq, double *PT, const int *ldpt, double *C, const int *ldc, double *work, int *info, size_t)
     * }
     */
    public static void dgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x18) {
        var mh$ = dgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbbrd_$descriptor() {
        return sgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sgbbrd_$handle() {
        return sgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sgbbrd_$address() {
        return sgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, float *AB, const int *ldab, float *D, float *E, float *Q, const int *ldq, float *PT, const int *ldpt, float *C, const int *ldc, float *work, int *info, size_t)
     * }
     */
    public static void sgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x18) {
        var mh$ = sgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, info, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbbrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbbrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbbrd_$descriptor() {
        return zgbbrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbbrd_$handle() {
        return zgbbrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbbrd_$address() {
        return zgbbrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbbrd_(const char *vect, const int *m, const int *n, const int *ncc, const int *kl, const int *ku, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *PT, const int *ldpt, _Complex double *C, const int *ldc, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbbrd_(MemorySegment vect, MemorySegment m, MemorySegment n, MemorySegment ncc, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment PT, MemorySegment ldpt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = zgbbrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbbrd_", vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
            }
            mh$.invokeExact(vect, m, n, ncc, kl, ku, AB, ldab, D, E, Q, ldq, PT, ldpt, C, ldc, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbcon_$descriptor() {
        return cgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbcon_$handle() {
        return cgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbcon_$address() {
        return cgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12) {
        var mh$ = cgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbcon_$descriptor() {
        return dgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgbcon_$handle() {
        return dgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgbcon_$address() {
        return dgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = dgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbcon_$descriptor() {
        return sgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgbcon_$handle() {
        return sgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgbcon_$address() {
        return sgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = sgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbcon_$descriptor() {
        return zgbcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbcon_$handle() {
        return zgbcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbcon_$address() {
        return zgbcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbcon_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbcon_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12) {
        var mh$ = zgbcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbcon_", norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
            }
            mh$.invokeExact(norm, n, kl, ku, AB, ldab, ipiv, anorm, rcond, work, rwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgbequ_$descriptor() {
        return cgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgbequ_$handle() {
        return cgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgbequ_$address() {
        return cgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgbequ_$descriptor() {
        return dgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgbequ_$handle() {
        return dgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgbequ_$address() {
        return dgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbequ_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgbequ_$descriptor() {
        return sgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgbequ_$handle() {
        return sgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgbequ_$address() {
        return sgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbequ_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgbequ_$descriptor() {
        return zgbequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgbequ_$handle() {
        return zgbequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgbequ_$address() {
        return zgbequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbequ_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgbequ_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgbequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequ_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgbequb_$descriptor() {
        return cgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgbequb_$handle() {
        return cgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgbequb_$address() {
        return cgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgbequb_$descriptor() {
        return dgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgbequb_$handle() {
        return dgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgbequb_$address() {
        return dgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbequb_(const int *m, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgbequb_$descriptor() {
        return sgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgbequb_$handle() {
        return sgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgbequb_$address() {
        return sgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbequb_(const int *m, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgbequb_$descriptor() {
        return zgbequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgbequb_$handle() {
        return zgbequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgbequb_$address() {
        return zgbequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbequb_(const int *m, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgbequb_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgbequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbequb_", m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbrfs_$descriptor() {
        return cgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgbrfs_$handle() {
        return cgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgbrfs_$address() {
        return cgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = cgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbrfs_$descriptor() {
        return dgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgbrfs_$handle() {
        return dgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgbrfs_$address() {
        return dgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x19) {
        var mh$ = dgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbrfs_$descriptor() {
        return sgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgbrfs_$handle() {
        return sgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgbrfs_$address() {
        return sgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x19) {
        var mh$ = sgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbrfs_$descriptor() {
        return zgbrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgbrfs_$handle() {
        return zgbrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgbrfs_$address() {
        return zgbrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbrfs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgbrfs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x19) {
        var mh$ = zgbrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbrfs_", trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x19);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbrfsx_$descriptor() {
        return cgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgbrfsx_$handle() {
        return cgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgbrfsx_$address() {
        return cgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const _Complex float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28) {
        var mh$ = cgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbrfsx_$descriptor() {
        return dgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgbrfsx_$handle() {
        return dgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgbrfsx_$address() {
        return dgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28) {
        var mh$ = dgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbrfsx_$descriptor() {
        return sgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgbrfsx_$handle() {
        return sgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgbrfsx_$address() {
        return sgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const float *AFB, const int *ldafb, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28) {
        var mh$ = sgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbrfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbrfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbrfsx_$descriptor() {
        return zgbrfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgbrfsx_$handle() {
        return zgbrfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgbrfsx_$address() {
        return zgbrfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbrfsx_(const char *trans, const char *equed, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const _Complex double *AFB, const int *ldafb, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgbrfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28) {
        var mh$ = zgbrfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbrfsx_", trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
            }
            mh$.invokeExact(trans, equed, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgbsv_$descriptor() {
        return cgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgbsv_$handle() {
        return cgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgbsv_$address() {
        return cgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgbsv_$descriptor() {
        return dgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgbsv_$handle() {
        return dgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgbsv_$address() {
        return dgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgbsv_$descriptor() {
        return sgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgbsv_$handle() {
        return sgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgbsv_$address() {
        return sgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgbsv_$descriptor() {
        return zgbsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgbsv_$handle() {
        return zgbsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgbsv_$address() {
        return zgbsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsv_(const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgbsv_(MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgbsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsv_", n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbsvx_$descriptor() {
        return cgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgbsvx_$handle() {
        return cgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgbsvx_$address() {
        return cgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = cgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbsvx_$descriptor() {
        return dgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgbsvx_$handle() {
        return dgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgbsvx_$address() {
        return dgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbsvx_$descriptor() {
        return sgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgbsvx_$handle() {
        return sgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgbsvx_$address() {
        return sgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbsvx_$descriptor() {
        return zgbsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgbsvx_$handle() {
        return zgbsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgbsvx_$address() {
        return zgbsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsvx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgbsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zgbsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsvx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgbsvxx_$descriptor() {
        return cgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgbsvxx_$handle() {
        return cgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgbsvxx_$address() {
        return cgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex float *AB, const int *ldab, _Complex float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = cgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgbsvxx_$descriptor() {
        return dgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgbsvxx_$handle() {
        return dgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgbsvxx_$address() {
        return dgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, double *AB, const int *ldab, double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = dgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgbsvxx_$descriptor() {
        return sgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgbsvxx_$handle() {
        return sgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgbsvxx_$address() {
        return sgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, float *AB, const int *ldab, float *AFB, const int *ldafb, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = sgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbsvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbsvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgbsvxx_$descriptor() {
        return zgbsvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgbsvxx_$handle() {
        return zgbsvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgbsvxx_$address() {
        return zgbsvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbsvxx_(const char *fact, const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, _Complex double *AB, const int *ldab, _Complex double *AFB, const int *ldafb, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgbsvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment AFB, MemorySegment ldafb, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x29, long x30, long x31) {
        var mh$ = zgbsvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbsvxx_", fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
            }
            mh$.invokeExact(fact, trans, n, kl, ku, nrhs, AB, ldab, AFB, ldafb, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x29, x30, x31);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgbtrf_$descriptor() {
        return cgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgbtrf_$handle() {
        return cgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgbtrf_$address() {
        return cgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void cgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgbtrf_$descriptor() {
        return dgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgbtrf_$handle() {
        return dgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgbtrf_$address() {
        return dgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbtrf_(const int *m, const int *n, const int *kl, const int *ku, double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void dgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgbtrf_$descriptor() {
        return sgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgbtrf_$handle() {
        return sgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgbtrf_$address() {
        return sgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbtrf_(const int *m, const int *n, const int *kl, const int *ku, float *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void sgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbtrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgbtrf_$descriptor() {
        return zgbtrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgbtrf_$handle() {
        return zgbtrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgbtrf_$address() {
        return zgbtrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbtrf_(const int *m, const int *n, const int *kl, const int *ku, _Complex double *AB, const int *ldab, int *ipiv, int *info)
     * }
     */
    public static void zgbtrf_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgbtrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrf_", m, n, kl, ku, AB, ldab, ipiv, info);
            }
            mh$.invokeExact(m, n, kl, ku, AB, ldab, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgbtrs_$descriptor() {
        return cgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgbtrs_$handle() {
        return cgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgbtrs_$address() {
        return cgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex float *AB, const int *ldab, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = cgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgbtrs_$descriptor() {
        return dgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgbtrs_$handle() {
        return dgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgbtrs_$address() {
        return dgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const double *AB, const int *ldab, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = dgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgbtrs_$descriptor() {
        return sgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgbtrs_$handle() {
        return sgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgbtrs_$address() {
        return sgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const float *AB, const int *ldab, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = sgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgbtrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgbtrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgbtrs_$descriptor() {
        return zgbtrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgbtrs_$handle() {
        return zgbtrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgbtrs_$address() {
        return zgbtrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgbtrs_(const char *trans, const int *n, const int *kl, const int *ku, const int *nrhs, const _Complex double *AB, const int *ldab, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgbtrs_(MemorySegment trans, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment nrhs, MemorySegment AB, MemorySegment ldab, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = zgbtrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgbtrs_", trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, kl, ku, nrhs, AB, ldab, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgebak_$descriptor() {
        return cgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgebak_$handle() {
        return cgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgebak_$address() {
        return cgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void cgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = cgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgebak_$descriptor() {
        return dgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgebak_$handle() {
        return dgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgebak_$address() {
        return dgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void dgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = dgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgebak_$descriptor() {
        return sgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgebak_$handle() {
        return sgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgebak_$address() {
        return sgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *scale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void sgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = sgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgebak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgebak_$descriptor() {
        return zgebak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgebak_$handle() {
        return zgebak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgebak_$address() {
        return zgebak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *scale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void zgebak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x10, long x11) {
        var mh$ = zgebak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebak_", job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, scale, m, V, ldv, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgebal_$descriptor() {
        return cgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MethodHandle cgebal_$handle() {
        return cgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MemorySegment cgebal_$address() {
        return cgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebal_(const char *job, const int *n, _Complex float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static void cgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = cgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgebal_$descriptor() {
        return dgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MethodHandle dgebal_$handle() {
        return dgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MemorySegment dgebal_$address() {
        return dgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebal_(const char *job, const int *n, double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static void dgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = dgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgebal_$descriptor() {
        return sgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MethodHandle sgebal_$handle() {
        return sgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static MemorySegment sgebal_$address() {
        return sgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebal_(const char *job, const int *n, float *A, const int *lda, int *ilo, int *ihi, float *scale, int *info, size_t)
     * }
     */
    public static void sgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = sgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgebal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgebal_$descriptor() {
        return zgebal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MethodHandle zgebal_$handle() {
        return zgebal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static MemorySegment zgebal_$address() {
        return zgebal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebal_(const char *job, const int *n, _Complex double *A, const int *lda, int *ilo, int *ihi, double *scale, int *info, size_t)
     * }
     */
    public static void zgebal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment info, long x8) {
        var mh$ = zgebal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebal_", job, n, A, lda, ilo, ihi, scale, info, x8);
            }
            mh$.invokeExact(job, n, A, lda, ilo, ihi, scale, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgebrd_$descriptor() {
        return cgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgebrd_$handle() {
        return cgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgebrd_$address() {
        return cgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgebrd_(const int *m, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tauq, _Complex float *taup, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgebrd_$descriptor() {
        return dgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgebrd_$handle() {
        return dgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgebrd_$address() {
        return dgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgebrd_(const int *m, const int *n, double *A, const int *lda, double *D, double *E, double *tauq, double *taup, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgebrd_$descriptor() {
        return sgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgebrd_$handle() {
        return sgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgebrd_$address() {
        return sgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgebrd_(const int *m, const int *n, float *A, const int *lda, float *D, float *E, float *tauq, float *taup, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgebrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgebrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgebrd_$descriptor() {
        return zgebrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgebrd_$handle() {
        return zgebrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgebrd_$address() {
        return zgebrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgebrd_(const int *m, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tauq, _Complex double *taup, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgebrd_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tauq, MemorySegment taup, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgebrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgebrd_", m, n, A, lda, D, E, tauq, taup, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, D, E, tauq, taup, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgecon_$descriptor() {
        return cgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgecon_$handle() {
        return cgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgecon_$address() {
        return cgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgecon_(const char *norm, const int *n, const _Complex float *A, const int *lda, const float *anorm, float *rcond, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = cgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgecon_", norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgecon_$descriptor() {
        return dgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgecon_$handle() {
        return dgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgecon_$address() {
        return dgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgecon_(const char *norm, const int *n, const double *A, const int *lda, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = dgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgecon_", norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgecon_$descriptor() {
        return sgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgecon_$handle() {
        return sgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgecon_$address() {
        return sgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgecon_(const char *norm, const int *n, const float *A, const int *lda, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x9) {
        var mh$ = sgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgecon_", norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, iwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgecon_$descriptor() {
        return zgecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgecon_$handle() {
        return zgecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgecon_$address() {
        return zgecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgecon_(const char *norm, const int *n, const _Complex double *A, const int *lda, const double *anorm, double *rcond, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgecon_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment rwork, MemorySegment info, long x9) {
        var mh$ = zgecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgecon_", norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
            }
            mh$.invokeExact(norm, n, A, lda, anorm, rcond, work, rwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgeequ_$descriptor() {
        return cgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgeequ_$handle() {
        return cgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgeequ_$address() {
        return cgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeequ_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgeequ_$descriptor() {
        return dgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgeequ_$handle() {
        return dgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgeequ_$address() {
        return dgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeequ_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgeequ_$descriptor() {
        return sgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgeequ_$handle() {
        return sgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgeequ_$address() {
        return sgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeequ_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequ_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeequ_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgeequ_$descriptor() {
        return zgeequ_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgeequ_$handle() {
        return zgeequ_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgeequ_$address() {
        return zgeequ_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeequ_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgeequ_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgeequ_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequ_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor cgeequb_$descriptor() {
        return cgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle cgeequb_$handle() {
        return cgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment cgeequb_$address() {
        return cgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeequb_(const int *m, const int *n, const _Complex float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void cgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = cgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor dgeequb_$descriptor() {
        return dgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle dgeequb_$handle() {
        return dgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment dgeequb_$address() {
        return dgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeequb_(const int *m, const int *n, const double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void dgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = dgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static FunctionDescriptor sgeequb_$descriptor() {
        return sgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MethodHandle sgeequb_$handle() {
        return sgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static MemorySegment sgeequb_$address() {
        return sgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeequb_(const int *m, const int *n, const float *A, const int *lda, float *R, float *C, float *rowcnd, float *colcnd, float *amax, int *info)
     * }
     */
    public static void sgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = sgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static FunctionDescriptor zgeequb_$descriptor() {
        return zgeequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MethodHandle zgeequb_$handle() {
        return zgeequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static MemorySegment zgeequb_$address() {
        return zgeequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeequb_(const int *m, const int *n, const _Complex double *A, const int *lda, double *R, double *C, double *rowcnd, double *colcnd, double *amax, int *info)
     * }
     */
    public static void zgeequb_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment R, MemorySegment C, MemorySegment rowcnd, MemorySegment colcnd, MemorySegment amax, MemorySegment info) {
        var mh$ = zgeequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeequb_", m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
            }
            mh$.invokeExact(m, n, A, lda, R, C, rowcnd, colcnd, amax, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgees_$descriptor() {
        return cgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgees_$handle() {
        return cgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgees_$address() {
        return cgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgees_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void cgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = cgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgees_", jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgees_$descriptor() {
        return dgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgees_$handle() {
        return dgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgees_$address() {
        return dgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgees_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void dgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = dgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgees_", jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgees_$descriptor() {
        return sgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgees_$handle() {
        return sgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgees_$address() {
        return sgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgees_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void sgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = sgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgees_", jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, WR, WI, VS, ldvs, work, lwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgees_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgees_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgees_$descriptor() {
        return zgees_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgees_$handle() {
        return zgees_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgees_$address() {
        return zgees_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgees_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t)
     * }
     */
    public static void zgees_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x15, long x16) {
        var mh$ = zgees_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgees_", jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
            }
            mh$.invokeExact(jobvs, sort, select, n, A, lda, sdim, W, VS, ldvs, work, lwork, rwork, BWORK, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeesx_$descriptor() {
        return cgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgeesx_$handle() {
        return cgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgeesx_$address() {
        return cgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeesx_(const char *jobvs, const char *sort, LAPACK_C_SELECT1 select, const char *sense, const int *n, _Complex float *A, const int *lda, int *sdim, _Complex float *W, _Complex float *VS, const int *ldvs, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = cgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeesx_$descriptor() {
        return dgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgeesx_$handle() {
        return dgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgeesx_$address() {
        return dgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeesx_(const char *jobvs, const char *sort, LAPACK_D_SELECT2 select, const char *sense, const int *n, double *A, const int *lda, int *sdim, double *WR, double *WI, double *VS, const int *ldvs, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeesx_$descriptor() {
        return sgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgeesx_$handle() {
        return sgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgeesx_$address() {
        return sgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeesx_(const char *jobvs, const char *sort, LAPACK_S_SELECT2 select, const char *sense, const int *n, float *A, const int *lda, int *sdim, float *WR, float *WI, float *VS, const int *ldvs, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment WR, MemorySegment WI, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = sgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, WR, WI, VS, ldvs, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeesx_$descriptor() {
        return zgeesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgeesx_$handle() {
        return zgeesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgeesx_$address() {
        return zgeesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeesx_(const char *jobvs, const char *sort, LAPACK_Z_SELECT1 select, const char *sense, const int *n, _Complex double *A, const int *lda, int *sdim, _Complex double *W, _Complex double *VS, const int *ldvs, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgeesx_(MemorySegment jobvs, MemorySegment sort, MemorySegment select, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment sdim, MemorySegment W, MemorySegment VS, MemorySegment ldvs, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x18, long x19, long x20) {
        var mh$ = zgeesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeesx_", jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
            }
            mh$.invokeExact(jobvs, sort, select, sense, n, A, lda, sdim, W, VS, ldvs, rconde, rcondv, work, lwork, rwork, BWORK, info, x18, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeev_$descriptor() {
        return cgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgeev_$handle() {
        return cgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgeev_$address() {
        return cgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeev_", jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeev_$descriptor() {
        return dgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgeev_$handle() {
        return dgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgeev_$address() {
        return dgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeev_", jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeev_$descriptor() {
        return sgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgeev_$handle() {
        return sgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgeev_$address() {
        return sgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeev_", jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeev_$descriptor() {
        return zgeev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgeev_$handle() {
        return zgeev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgeev_$address() {
        return zgeev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgeev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgeev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeev_", jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, W, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgeevx_$descriptor() {
        return cgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgeevx_$handle() {
        return cgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgeevx_$address() {
        return cgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24, long x25) {
        var mh$ = cgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgeevx_$descriptor() {
        return dgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgeevx_$handle() {
        return dgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgeevx_$address() {
        return dgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *WR, double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25, long x26) {
        var mh$ = dgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgeevx_$descriptor() {
        return sgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgeevx_$handle() {
        return sgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgeevx_$address() {
        return sgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *WR, float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *scale, float *abnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25, long x26) {
        var mh$ = sgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, WR, WI, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, iwork, info, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgeevx_$descriptor() {
        return zgeevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgeevx_$handle() {
        return zgeevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgeevx_$address() {
        return zgeevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *scale, double *abnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgeevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment scale, MemorySegment abnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24, long x25) {
        var mh$ = zgeevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeevx_", balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, W, VL, ldvl, VR, ldvr, ilo, ihi, scale, abnrm, rconde, rcondv, work, lwork, rwork, info, x22, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgehrd_$descriptor() {
        return cgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgehrd_$handle() {
        return cgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgehrd_$address() {
        return cgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgehrd_(const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgehrd_$descriptor() {
        return dgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgehrd_$handle() {
        return dgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgehrd_$address() {
        return dgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgehrd_(const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgehrd_$descriptor() {
        return sgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgehrd_$handle() {
        return sgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgehrd_$address() {
        return sgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgehrd_(const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgehrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgehrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgehrd_$descriptor() {
        return zgehrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgehrd_$handle() {
        return zgehrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgehrd_$address() {
        return zgehrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgehrd_(const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgehrd_(MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgehrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgehrd_", n, ilo, ihi, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(n, ilo, ihi, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgejsv_$descriptor() {
        return cgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgejsv_$handle() {
        return cgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgejsv_$address() {
        return cgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = cgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgejsv_$descriptor() {
        return dgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgejsv_$handle() {
        return dgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgejsv_$address() {
        return dgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, double *A, const int *lda, double *SVA, double *U, const int *ldu, double *V, const int *ldv, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x19, long x20, long x21, long x22, long x23, long x24) {
        var mh$ = dgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgejsv_$descriptor() {
        return sgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgejsv_$handle() {
        return sgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgejsv_$address() {
        return sgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, float *A, const int *lda, float *SVA, float *U, const int *ldu, float *V, const int *ldv, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x19, long x20, long x21, long x22, long x23, long x24) {
        var mh$ = sgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, work, lwork, iwork, info, x19, x20, x21, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgejsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgejsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgejsv_$descriptor() {
        return zgejsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgejsv_$handle() {
        return zgejsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgejsv_$address() {
        return zgejsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgejsv_(const char *joba, const char *jobu, const char *jobv, const char *jobr, const char *jobt, const char *jobp, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *iwork, int *info, size_t, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgejsv_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment jobr, MemorySegment jobt, MemorySegment jobp, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = zgejsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgejsv_", joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobu, jobv, jobr, jobt, jobp, m, n, A, lda, SVA, U, ldu, V, ldv, cwork, lwork, rwork, lrwork, iwork, info, x21, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelq_$descriptor() {
        return cgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgelq_$handle() {
        return cgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgelq_$address() {
        return cgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelq_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelq_$descriptor() {
        return dgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelq_$handle() {
        return dgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelq_$address() {
        return dgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelq_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelq_$descriptor() {
        return sgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelq_$handle() {
        return sgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelq_$address() {
        return sgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelq_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelq_$descriptor() {
        return zgelq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgelq_$handle() {
        return zgelq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgelq_$address() {
        return zgelq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelq_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgelq_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgelq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelq_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgelq2_$descriptor() {
        return cgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgelq2_$handle() {
        return cgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgelq2_$address() {
        return cgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgelq2_$descriptor() {
        return dgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgelq2_$handle() {
        return dgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgelq2_$address() {
        return dgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgelq2_$descriptor() {
        return sgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgelq2_$handle() {
        return sgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgelq2_$address() {
        return sgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgelq2_$descriptor() {
        return zgelq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgelq2_$handle() {
        return zgelq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgelq2_$address() {
        return zgelq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgelq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgelq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelqf_$descriptor() {
        return cgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgelqf_$handle() {
        return cgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgelqf_$address() {
        return cgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelqf_$descriptor() {
        return dgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelqf_$handle() {
        return dgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelqf_$address() {
        return dgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelqf_$descriptor() {
        return sgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelqf_$handle() {
        return sgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelqf_$address() {
        return sgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelqf_$descriptor() {
        return zgelqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgelqf_$handle() {
        return zgelqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgelqf_$address() {
        return zgelqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgelqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgelqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgels_$descriptor() {
        return cgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgels_$handle() {
        return cgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgels_$address() {
        return cgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = cgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgels_$descriptor() {
        return dgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgels_$handle() {
        return dgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgels_$address() {
        return dgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgels_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgels_$descriptor() {
        return sgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgels_$handle() {
        return sgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgels_$address() {
        return sgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgels_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = sgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgels_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgels_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgels_$descriptor() {
        return zgels_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgels_$handle() {
        return zgels_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgels_$address() {
        return zgels_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgels_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zgels_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zgels_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgels_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelsd_$descriptor() {
        return cgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle cgelsd_$handle() {
        return cgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment cgelsd_$address() {
        return cgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelsd_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info)
     * }
     */
    public static void cgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = cgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelsd_$descriptor() {
        return dgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle dgelsd_$handle() {
        return dgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment dgelsd_$address() {
        return dgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelsd_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static void dgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = dgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelsd_$descriptor() {
        return sgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle sgelsd_$handle() {
        return sgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment sgelsd_$address() {
        return sgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelsd_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *iwork, int *info)
     * }
     */
    public static void sgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = sgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelsd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelsd_$descriptor() {
        return zgelsd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static MethodHandle zgelsd_$handle() {
        return zgelsd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static MemorySegment zgelsd_$address() {
        return zgelsd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelsd_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info)
     * }
     */
    public static void zgelsd_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info) {
        var mh$ = zgelsd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsd_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, iwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelss_$descriptor() {
        return cgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgelss_$handle() {
        return cgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgelss_$address() {
        return cgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelss_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *S, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelss_$descriptor() {
        return dgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelss_$handle() {
        return dgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelss_$address() {
        return dgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelss_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *S, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelss_$descriptor() {
        return sgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelss_$handle() {
        return sgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelss_$address() {
        return sgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelss_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *S, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelss_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelss_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelss_$descriptor() {
        return zgelss_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgelss_$handle() {
        return zgelss_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgelss_$address() {
        return zgelss_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelss_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *S, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgelss_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment S, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgelss_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelss_", m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, S, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgelsy_$descriptor() {
        return cgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgelsy_$handle() {
        return cgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgelsy_$address() {
        return cgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgelsy_(const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgelsy_$descriptor() {
        return dgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgelsy_$handle() {
        return dgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgelsy_$address() {
        return dgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgelsy_(const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgelsy_$descriptor() {
        return sgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgelsy_$handle() {
        return sgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgelsy_$address() {
        return sgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgelsy_(const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, int *JPVT, const float *rcond, int *rank, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgelsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgelsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgelsy_$descriptor() {
        return zgelsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgelsy_$handle() {
        return zgelsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgelsy_$address() {
        return zgelsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgelsy_(const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *JPVT, const double *rcond, int *rank, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgelsy_(MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment JPVT, MemorySegment rcond, MemorySegment rank, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgelsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgelsy_", m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, nrhs, A, lda, B, ldb, JPVT, rcond, rank, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemlq_$descriptor() {
        return cgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemlq_$handle() {
        return cgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemlq_$address() {
        return cgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemlq_$descriptor() {
        return dgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemlq_$handle() {
        return dgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemlq_$address() {
        return dgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemlq_$descriptor() {
        return sgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemlq_$handle() {
        return sgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemlq_$address() {
        return sgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemlq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgemlq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemlq_$descriptor() {
        return zgemlq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemlq_$handle() {
        return zgemlq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemlq_$address() {
        return zgemlq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemlq_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgemlq_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgemlq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemlq_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemqr_$descriptor() {
        return cgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemqr_$handle() {
        return cgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemqr_$address() {
        return cgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex float *A, const int *lda, const _Complex float *T, const int *tsize, _Complex float *C, const int *ldc, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = cgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemqr_$descriptor() {
        return dgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemqr_$handle() {
        return dgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemqr_$address() {
        return dgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const double *A, const int *lda, const double *T, const int *tsize, double *C, const int *ldc, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemqr_$descriptor() {
        return sgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemqr_$handle() {
        return sgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemqr_$address() {
        return sgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const float *A, const int *lda, const float *T, const int *tsize, float *C, const int *ldc, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgemqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemqr_$descriptor() {
        return zgemqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemqr_$handle() {
        return zgemqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemqr_$address() {
        return zgemqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemqr_(const char *side, const char *trans, const int *m, const int *n, const int *k, const _Complex double *A, const int *lda, const _Complex double *T, const int *tsize, _Complex double *C, const int *ldc, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgemqr_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = zgemqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemqr_", side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, A, lda, T, tsize, C, ldc, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgemqrt_$descriptor() {
        return cgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgemqrt_$handle() {
        return cgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgemqrt_$address() {
        return cgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex float *V, const int *ldv, const _Complex float *T, const int *ldt, _Complex float *C, const int *ldc, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void cgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = cgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgemqrt_$descriptor() {
        return dgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgemqrt_$handle() {
        return dgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgemqrt_$address() {
        return dgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const double *V, const int *ldv, const double *T, const int *ldt, double *C, const int *ldc, double *work, int *info, size_t, size_t)
     * }
     */
    public static void dgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = dgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgemqrt_$descriptor() {
        return sgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgemqrt_$handle() {
        return sgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgemqrt_$address() {
        return sgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const float *V, const int *ldv, const float *T, const int *ldt, float *C, const int *ldc, float *work, int *info, size_t, size_t)
     * }
     */
    public static void sgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = sgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgemqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgemqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgemqrt_$descriptor() {
        return zgemqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgemqrt_$handle() {
        return zgemqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgemqrt_$address() {
        return zgemqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgemqrt_(const char *side, const char *trans, const int *m, const int *n, const int *k, const int *nb, const _Complex double *V, const int *ldv, const _Complex double *T, const int *ldt, _Complex double *C, const int *ldc, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void zgemqrt_(MemorySegment side, MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment k, MemorySegment nb, MemorySegment V, MemorySegment ldv, MemorySegment T, MemorySegment ldt, MemorySegment C, MemorySegment ldc, MemorySegment work, MemorySegment info, long x14, long x15) {
        var mh$ = zgemqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgemqrt_", side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
            }
            mh$.invokeExact(side, trans, m, n, k, nb, V, ldv, T, ldt, C, ldc, work, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeql2_$descriptor() {
        return cgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeql2_$handle() {
        return cgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeql2_$address() {
        return cgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeql2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeql2_$descriptor() {
        return dgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeql2_$handle() {
        return dgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeql2_$address() {
        return dgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeql2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeql2_$descriptor() {
        return sgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeql2_$handle() {
        return sgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeql2_$address() {
        return sgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeql2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeql2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeql2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeql2_$descriptor() {
        return zgeql2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeql2_$handle() {
        return zgeql2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeql2_$address() {
        return zgeql2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeql2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgeql2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgeql2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeql2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqlf_$descriptor() {
        return cgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqlf_$handle() {
        return cgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqlf_$address() {
        return cgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqlf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqlf_$descriptor() {
        return dgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqlf_$handle() {
        return dgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqlf_$address() {
        return dgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqlf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqlf_$descriptor() {
        return sgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqlf_$handle() {
        return sgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqlf_$address() {
        return sgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqlf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqlf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqlf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqlf_$descriptor() {
        return zgeqlf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqlf_$handle() {
        return zgeqlf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqlf_$address() {
        return zgeqlf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqlf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqlf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqlf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqlf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqpf_$descriptor() {
        return sgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqpf_$handle() {
        return sgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqpf_$address() {
        return sgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqpf_(int *m, int *n, float *a, int *lda, int *jpvt, float *tau, float *work, int *info)
     * }
     */
    public static void sgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqpf_", m, n, a, lda, jpvt, tau, work, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqpf_$descriptor() {
        return dgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqpf_$handle() {
        return dgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqpf_$address() {
        return dgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqpf_(int *m, int *n, double *a, int *lda, int *jpvt, double *tau, double *work, int *info)
     * }
     */
    public static void dgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqpf_", m, n, a, lda, jpvt, tau, work, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqpf_$descriptor() {
        return cgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgeqpf_$handle() {
        return cgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgeqpf_$address() {
        return cgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqpf_(int *m, int *n, _Complex float *a, int *lda, int *jpvt, _Complex float *tau, _Complex float *work, float *rwork, int *info)
     * }
     */
    public static void cgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqpf_", m, n, a, lda, jpvt, tau, work, rwork, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqpf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqpf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqpf_$descriptor() {
        return zgeqpf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgeqpf_$handle() {
        return zgeqpf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgeqpf_$address() {
        return zgeqpf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqpf_(int *m, int *n, _Complex double *a, int *lda, int *jpvt, _Complex double *tau, _Complex double *work, double *rwork, int *info)
     * }
     */
    public static void zgeqpf_(MemorySegment m, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment jpvt, MemorySegment tau, MemorySegment work, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgeqpf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqpf_", m, n, a, lda, jpvt, tau, work, rwork, info);
            }
            mh$.invokeExact(m, n, a, lda, jpvt, tau, work, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqp3_$descriptor() {
        return cgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MethodHandle cgeqp3_$handle() {
        return cgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static MemorySegment cgeqp3_$address() {
        return cgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqp3_(const int *m, const int *n, _Complex float *A, const int *lda, int *JPVT, _Complex float *tau, _Complex float *work, const int *lwork, float *rwork, int *info)
     * }
     */
    public static void cgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = cgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqp3_$descriptor() {
        return dgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqp3_$handle() {
        return dgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqp3_$address() {
        return dgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqp3_(const int *m, const int *n, double *A, const int *lda, int *JPVT, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqp3_$descriptor() {
        return sgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqp3_$handle() {
        return sgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqp3_$address() {
        return sgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqp3_(const int *m, const int *n, float *A, const int *lda, int *JPVT, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqp3_$descriptor() {
        return zgeqp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MethodHandle zgeqp3_$handle() {
        return zgeqp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static MemorySegment zgeqp3_$address() {
        return zgeqp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqp3_(const int *m, const int *n, _Complex double *A, const int *lda, int *JPVT, _Complex double *tau, _Complex double *work, const int *lwork, double *rwork, int *info)
     * }
     */
    public static void zgeqp3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment JPVT, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info) {
        var mh$ = zgeqp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqp3_", m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
            }
            mh$.invokeExact(m, n, A, lda, JPVT, tau, work, lwork, rwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqr_$descriptor() {
        return cgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqr_$handle() {
        return cgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqr_$address() {
        return cgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqr_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *tsize, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqr_$descriptor() {
        return dgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqr_$handle() {
        return dgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqr_$address() {
        return dgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqr_(const int *m, const int *n, double *A, const int *lda, double *T, const int *tsize, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqr_$descriptor() {
        return sgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqr_$handle() {
        return sgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqr_$address() {
        return sgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqr_(const int *m, const int *n, float *A, const int *lda, float *T, const int *tsize, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqr_$descriptor() {
        return zgeqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqr_$handle() {
        return zgeqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqr_$address() {
        return zgeqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqr_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *tsize, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqr_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment tsize, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqr_", m, n, A, lda, T, tsize, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, T, tsize, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeqr2_$descriptor() {
        return cgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeqr2_$handle() {
        return cgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeqr2_$address() {
        return cgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqr2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqr2_$descriptor() {
        return dgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqr2_$handle() {
        return dgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqr2_$address() {
        return dgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqr2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqr2_$descriptor() {
        return sgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqr2_$handle() {
        return sgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqr2_$address() {
        return sgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqr2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqr2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqr2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeqr2_$descriptor() {
        return zgeqr2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeqr2_$handle() {
        return zgeqr2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeqr2_$address() {
        return zgeqr2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqr2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgeqr2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgeqr2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqr2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrf_$descriptor() {
        return cgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqrf_$handle() {
        return cgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqrf_$address() {
        return cgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrf_$descriptor() {
        return dgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqrf_$handle() {
        return dgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqrf_$address() {
        return dgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrf_$descriptor() {
        return sgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqrf_$handle() {
        return sgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqrf_$address() {
        return sgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrf_$descriptor() {
        return zgeqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqrf_$handle() {
        return zgeqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqrf_$address() {
        return zgeqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrfp_$descriptor() {
        return cgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgeqrfp_$handle() {
        return cgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgeqrfp_$address() {
        return cgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrfp_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrfp_$descriptor() {
        return dgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgeqrfp_$handle() {
        return dgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgeqrfp_$address() {
        return dgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrfp_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrfp_$descriptor() {
        return sgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgeqrfp_$handle() {
        return sgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgeqrfp_$address() {
        return sgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrfp_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrfp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqrfp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrfp_$descriptor() {
        return zgeqrfp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgeqrfp_$handle() {
        return zgeqrfp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgeqrfp_$address() {
        return zgeqrfp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrfp_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgeqrfp_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgeqrfp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrfp_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt_$descriptor() {
        return cgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgeqrt_$handle() {
        return cgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgeqrt_$address() {
        return cgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt_(const int *m, const int *n, const int *nb, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, int *info)
     * }
     */
    public static void cgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = cgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt_$descriptor() {
        return dgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MethodHandle dgeqrt_$handle() {
        return dgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static MemorySegment dgeqrt_$address() {
        return dgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt_(const int *m, const int *n, const int *nb, double *A, const int *lda, double *T, const int *ldt, double *work, int *info)
     * }
     */
    public static void dgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = dgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt_$descriptor() {
        return sgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MethodHandle sgeqrt_$handle() {
        return sgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static MemorySegment sgeqrt_$address() {
        return sgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt_(const int *m, const int *n, const int *nb, float *A, const int *lda, float *T, const int *ldt, float *work, int *info)
     * }
     */
    public static void sgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = sgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt_$descriptor() {
        return zgeqrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgeqrt_$handle() {
        return zgeqrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgeqrt_$address() {
        return zgeqrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt_(const int *m, const int *n, const int *nb, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, int *info)
     * }
     */
    public static void zgeqrt_(MemorySegment m, MemorySegment n, MemorySegment nb, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment info) {
        var mh$ = zgeqrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt_", m, n, nb, A, lda, T, ldt, work, info);
            }
            mh$.invokeExact(m, n, nb, A, lda, T, ldt, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt2_$descriptor() {
        return cgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle cgeqrt2_$handle() {
        return cgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment cgeqrt2_$address() {
        return cgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void cgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = cgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt2_$descriptor() {
        return dgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dgeqrt2_$handle() {
        return dgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dgeqrt2_$address() {
        return dgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt2_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static void dgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt2_$descriptor() {
        return sgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle sgeqrt2_$handle() {
        return sgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment sgeqrt2_$address() {
        return sgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt2_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static void sgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = sgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqrt2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt2_$descriptor() {
        return zgeqrt2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle zgeqrt2_$handle() {
        return zgeqrt2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment zgeqrt2_$address() {
        return zgeqrt2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void zgeqrt2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = zgeqrt2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt2_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor cgeqrt3_$descriptor() {
        return cgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle cgeqrt3_$handle() {
        return cgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment cgeqrt3_$address() {
        return cgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgeqrt3_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, int *info)
     * }
     */
    public static void cgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = cgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor dgeqrt3_$descriptor() {
        return dgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle dgeqrt3_$handle() {
        return dgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment dgeqrt3_$address() {
        return dgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgeqrt3_(const int *m, const int *n, double *A, const int *lda, double *T, const int *ldt, int *info)
     * }
     */
    public static void dgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = dgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor sgeqrt3_$descriptor() {
        return sgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle sgeqrt3_$handle() {
        return sgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment sgeqrt3_$address() {
        return sgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgeqrt3_(const int *m, const int *n, float *A, const int *lda, float *T, const int *ldt, int *info)
     * }
     */
    public static void sgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = sgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgeqrt3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgeqrt3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static FunctionDescriptor zgeqrt3_$descriptor() {
        return zgeqrt3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MethodHandle zgeqrt3_$handle() {
        return zgeqrt3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static MemorySegment zgeqrt3_$address() {
        return zgeqrt3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgeqrt3_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, int *info)
     * }
     */
    public static void zgeqrt3_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment info) {
        var mh$ = zgeqrt3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgeqrt3_", m, n, A, lda, T, ldt, info);
            }
            mh$.invokeExact(m, n, A, lda, T, ldt, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgerfs_$descriptor() {
        return cgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgerfs_$handle() {
        return cgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgerfs_$address() {
        return cgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgerfs_$descriptor() {
        return dgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgerfs_$handle() {
        return dgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgerfs_$address() {
        return dgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerfs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = dgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgerfs_$descriptor() {
        return sgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgerfs_$handle() {
        return sgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgerfs_$address() {
        return sgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerfs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x17) {
        var mh$ = sgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgerfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgerfs_$descriptor() {
        return zgerfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgerfs_$handle() {
        return zgerfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgerfs_$address() {
        return zgerfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgerfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zgerfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerfs_", trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgerfsx_$descriptor() {
        return cgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgerfsx_$handle() {
        return cgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgerfsx_$address() {
        return cgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26) {
        var mh$ = cgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgerfsx_$descriptor() {
        return dgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgerfsx_$handle() {
        return dgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgerfsx_$address() {
        return dgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const double *A, const int *lda, const double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26) {
        var mh$ = dgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgerfsx_$descriptor() {
        return sgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgerfsx_$handle() {
        return sgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgerfsx_$address() {
        return sgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const float *A, const int *lda, const float *AF, const int *ldaf, const int *ipiv, const float *R, const float *C, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x25, long x26) {
        var mh$ = sgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgerfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgerfsx_$descriptor() {
        return zgerfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgerfsx_$handle() {
        return zgerfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgerfsx_$address() {
        return zgerfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerfsx_(const char *trans, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *R, const double *C, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgerfsx_(MemorySegment trans, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x25, long x26) {
        var mh$ = zgerfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerfsx_", trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
            }
            mh$.invokeExact(trans, equed, n, nrhs, A, lda, AF, ldaf, ipiv, R, C, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor cgerq2_$descriptor() {
        return cgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle cgerq2_$handle() {
        return cgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment cgerq2_$address() {
        return cgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerq2_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, int *info)
     * }
     */
    public static void cgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = cgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dgerq2_$descriptor() {
        return dgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MethodHandle dgerq2_$handle() {
        return dgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static MemorySegment dgerq2_$address() {
        return dgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerq2_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, int *info)
     * }
     */
    public static void dgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = dgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static FunctionDescriptor sgerq2_$descriptor() {
        return sgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MethodHandle sgerq2_$handle() {
        return sgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static MemorySegment sgerq2_$address() {
        return sgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerq2_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, int *info)
     * }
     */
    public static void sgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = sgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerq2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgerq2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zgerq2_$descriptor() {
        return zgerq2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zgerq2_$handle() {
        return zgerq2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zgerq2_$address() {
        return zgerq2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerq2_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, int *info)
     * }
     */
    public static void zgerq2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment info) {
        var mh$ = zgerq2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerq2_", m, n, A, lda, tau, work, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgerqf_$descriptor() {
        return cgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgerqf_$handle() {
        return cgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgerqf_$address() {
        return cgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgerqf_(const int *m, const int *n, _Complex float *A, const int *lda, _Complex float *tau, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgerqf_$descriptor() {
        return dgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgerqf_$handle() {
        return dgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgerqf_$address() {
        return dgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgerqf_(const int *m, const int *n, double *A, const int *lda, double *tau, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgerqf_$descriptor() {
        return sgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgerqf_$handle() {
        return sgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgerqf_$address() {
        return sgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgerqf_(const int *m, const int *n, float *A, const int *lda, float *tau, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgerqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgerqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgerqf_$descriptor() {
        return zgerqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgerqf_$handle() {
        return zgerqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgerqf_$address() {
        return zgerqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgerqf_(const int *m, const int *n, _Complex double *A, const int *lda, _Complex double *tau, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgerqf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgerqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgerqf_", m, n, A, lda, tau, work, lwork, info);
            }
            mh$.invokeExact(m, n, A, lda, tau, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgesdd_$descriptor() {
        return cgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgesdd_$handle() {
        return cgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgesdd_$address() {
        return cgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesdd_(const char *jobz, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static void cgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = cgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgesdd_$descriptor() {
        return dgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgesdd_$handle() {
        return dgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgesdd_$address() {
        return dgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesdd_(const char *jobz, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void dgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = dgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgesdd_$descriptor() {
        return sgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgesdd_$handle() {
        return sgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgesdd_$address() {
        return sgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesdd_(const char *jobz, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t)
     * }
     */
    public static void sgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x14) {
        var mh$ = sgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesdd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesdd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgesdd_$descriptor() {
        return zgesdd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgesdd_$handle() {
        return zgesdd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgesdd_$address() {
        return zgesdd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesdd_(const char *jobz, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t)
     * }
     */
    public static void zgesdd_(MemorySegment jobz, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x15) {
        var mh$ = zgesdd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesdd_", jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
            }
            mh$.invokeExact(jobz, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgesv_$descriptor() {
        return cgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgesv_$handle() {
        return cgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgesv_$address() {
        return cgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesv_(const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgesv_$descriptor() {
        return dgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgesv_$handle() {
        return dgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgesv_$address() {
        return dgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgesv_$descriptor() {
        return sgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgesv_$handle() {
        return sgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgesv_$address() {
        return sgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesv_(const int *n, const int *nrhs, float *A, const int *lda, int *ipiv, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgesv_$descriptor() {
        return zgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgesv_$handle() {
        return zgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgesv_$address() {
        return zgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesv_", n, nrhs, A, lda, ipiv, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dsgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dsgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static FunctionDescriptor dsgesv_$descriptor() {
        return dsgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static MethodHandle dsgesv_$handle() {
        return dsgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static MemorySegment dsgesv_$address() {
        return dsgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dsgesv_(const int *n, const int *nrhs, double *A, const int *lda, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *work, float *swork, int *iter, int *info)
     * }
     */
    public static void dsgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment iter, MemorySegment info) {
        var mh$ = dsgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dsgesv_", n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, iter, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, iter, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zcgesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zcgesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static FunctionDescriptor zcgesv_$descriptor() {
        return zcgesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static MethodHandle zcgesv_$handle() {
        return zcgesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static MemorySegment zcgesv_$address() {
        return zcgesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zcgesv_(const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, _Complex double *work, _Complex float *swork, double *rwork, int *iter, int *info)
     * }
     */
    public static void zcgesv_(MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment swork, MemorySegment rwork, MemorySegment iter, MemorySegment info) {
        var mh$ = zcgesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zcgesv_", n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, rwork, iter, info);
            }
            mh$.invokeExact(n, nrhs, A, lda, ipiv, B, ldb, X, ldx, work, swork, rwork, iter, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvd_$descriptor() {
        return cgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvd_$handle() {
        return cgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvd_$address() {
        return cgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = cgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvd_$descriptor() {
        return dgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvd_$handle() {
        return dgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvd_$address() {
        return dgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvd_$descriptor() {
        return sgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvd_$handle() {
        return sgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvd_$address() {
        return sgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = sgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvd_$descriptor() {
        return zgesvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvd_$handle() {
        return zgesvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvd_$address() {
        return zgesvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvd_(const char *jobu, const char *jobvt, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgesvd_(MemorySegment jobu, MemorySegment jobvt, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = zgesvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvd_", jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobu, jobvt, m, n, A, lda, S, U, ldu, VT, ldvt, work, lwork, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvdq_$descriptor() {
        return cgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvdq_$handle() {
        return cgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvdq_$address() {
        return cgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *S, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex float *cwork, int *lcwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment cwork, MemorySegment lcwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = cgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvdq_$descriptor() {
        return dgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvdq_$handle() {
        return dgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvdq_$address() {
        return dgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *S, double *U, const int *ldu, double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, double *work, int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = dgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvdq_$descriptor() {
        return sgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvdq_$handle() {
        return sgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvdq_$address() {
        return sgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *S, float *U, const int *ldu, float *V, const int *ldv, int *numrank, int *iwork, const int *liwork, float *work, int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = sgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, work, lwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvdq_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvdq_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvdq_$descriptor() {
        return zgesvdq_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvdq_$handle() {
        return zgesvdq_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvdq_$address() {
        return zgesvdq_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvdq_(const char *joba, const char *jobp, const char *jobr, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *S, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, int *numrank, int *iwork, const int *liwork, _Complex double *cwork, int *lcwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zgesvdq_(MemorySegment joba, MemorySegment jobp, MemorySegment jobr, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment numrank, MemorySegment iwork, MemorySegment liwork, MemorySegment cwork, MemorySegment lcwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x22, long x23, long x24, long x25, long x26) {
        var mh$ = zgesvdq_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvdq_", joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
            }
            mh$.invokeExact(joba, jobp, jobr, jobu, jobv, m, n, A, lda, S, U, ldu, V, ldv, numrank, iwork, liwork, cwork, lcwork, rwork, lrwork, info, x22, x23, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvdx_$descriptor() {
        return cgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvdx_$handle() {
        return cgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvdx_$address() {
        return cgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, _Complex float *U, const int *ldu, _Complex float *VT, const int *ldvt, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = cgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvdx_$descriptor() {
        return dgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvdx_$handle() {
        return dgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvdx_$address() {
        return dgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, double *U, const int *ldu, double *VT, const int *ldvt, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvdx_$descriptor() {
        return sgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvdx_$handle() {
        return sgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvdx_$address() {
        return sgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, int *ns, float *S, float *U, const int *ldu, float *VT, const int *ldvt, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, iwork, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvdx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvdx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvdx_$descriptor() {
        return zgesvdx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvdx_$handle() {
        return zgesvdx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvdx_$address() {
        return zgesvdx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvdx_(const char *jobu, const char *jobvt, const char *range, const int *m, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, int *ns, double *S, _Complex double *U, const int *ldu, _Complex double *VT, const int *ldvt, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvdx_(MemorySegment jobu, MemorySegment jobvt, MemorySegment range, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment ns, MemorySegment S, MemorySegment U, MemorySegment ldu, MemorySegment VT, MemorySegment ldvt, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = zgesvdx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvdx_", jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(jobu, jobvt, range, m, n, A, lda, vl, vu, il, iu, ns, S, U, ldu, VT, ldvt, work, lwork, rwork, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvj_$descriptor() {
        return cgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvj_$handle() {
        return cgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvj_$address() {
        return cgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex float *A, const int *lda, float *SVA, const int *mv, _Complex float *V, const int *ldv, _Complex float *cwork, const int *lwork, float *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = cgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvj_$descriptor() {
        return dgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvj_$handle() {
        return dgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvj_$address() {
        return dgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, double *A, const int *lda, double *SVA, const int *mv, double *V, const int *ldv, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = dgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvj_$descriptor() {
        return sgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvj_$handle() {
        return sgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvj_$address() {
        return sgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, float *A, const int *lda, float *SVA, const int *mv, float *V, const int *ldv, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15, long x16) {
        var mh$ = sgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, work, lwork, info, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvj_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvj_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvj_$descriptor() {
        return zgesvj_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvj_$handle() {
        return zgesvj_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvj_$address() {
        return zgesvj_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvj_(const char *joba, const char *jobu, const char *jobv, const int *m, const int *n, _Complex double *A, const int *lda, double *SVA, const int *mv, _Complex double *V, const int *ldv, _Complex double *cwork, const int *lwork, double *rwork, const int *lrwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvj_(MemorySegment joba, MemorySegment jobu, MemorySegment jobv, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SVA, MemorySegment mv, MemorySegment V, MemorySegment ldv, MemorySegment cwork, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment info, long x16, long x17, long x18) {
        var mh$ = zgesvj_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvj_", joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
            }
            mh$.invokeExact(joba, jobu, jobv, m, n, A, lda, SVA, mv, V, ldv, cwork, lwork, rwork, lrwork, info, x16, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvx_$descriptor() {
        return cgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvx_$handle() {
        return cgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvx_$address() {
        return cgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = cgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvx_$descriptor() {
        return dgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvx_$handle() {
        return dgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvx_$address() {
        return dgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = dgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvx_$descriptor() {
        return sgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvx_$handle() {
        return sgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvx_$address() {
        return sgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = sgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvx_$descriptor() {
        return zgesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvx_$handle() {
        return zgesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvx_$address() {
        return zgesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23, long x24) {
        var mh$ = zgesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23, x24);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgesvxx_$descriptor() {
        return cgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgesvxx_$handle() {
        return cgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgesvxx_$address() {
        return cgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = cgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgesvxx_$descriptor() {
        return dgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgesvxx_$handle() {
        return dgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgesvxx_$address() {
        return dgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, double *A, const int *lda, double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = dgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgesvxx_$descriptor() {
        return sgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgesvxx_$handle() {
        return sgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgesvxx_$address() {
        return sgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, float *A, const int *lda, float *AF, const int *ldaf, int *ipiv, char *equed, float *R, float *C, float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment iwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = sgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, iwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgesvxx_$descriptor() {
        return zgesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgesvxx_$handle() {
        return zgesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgesvxx_$address() {
        return zgesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgesvxx_(const char *fact, const char *trans, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *R, double *C, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgesvxx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment R, MemorySegment C, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x27, long x28, long x29) {
        var mh$ = zgesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgesvxx_", fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
            }
            mh$.invokeExact(fact, trans, n, nrhs, A, lda, AF, ldaf, ipiv, equed, R, C, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetf2_$descriptor() {
        return cgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetf2_$handle() {
        return cgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetf2_$address() {
        return cgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetf2_$descriptor() {
        return dgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetf2_$handle() {
        return dgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetf2_$address() {
        return dgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetf2_$descriptor() {
        return sgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetf2_$handle() {
        return sgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetf2_$address() {
        return sgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetf2_$descriptor() {
        return zgetf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetf2_$handle() {
        return zgetf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetf2_$address() {
        return zgetf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetrf_$descriptor() {
        return cgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetrf_$handle() {
        return cgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetrf_$address() {
        return cgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrf_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetrf_$descriptor() {
        return dgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetrf_$handle() {
        return dgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetrf_$address() {
        return dgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetrf_$descriptor() {
        return sgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetrf_$handle() {
        return sgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetrf_$address() {
        return sgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetrf_$descriptor() {
        return zgetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetrf_$handle() {
        return zgetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetrf_$address() {
        return zgetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrf_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetrf_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgetrf2_$descriptor() {
        return cgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgetrf2_$handle() {
        return cgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgetrf2_$address() {
        return cgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrf2_(const int *m, const int *n, _Complex float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void cgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgetrf2_$descriptor() {
        return dgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgetrf2_$handle() {
        return dgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgetrf2_$address() {
        return dgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrf2_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void dgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgetrf2_$descriptor() {
        return sgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgetrf2_$handle() {
        return sgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgetrf2_$address() {
        return sgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrf2_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void sgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrf2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetrf2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgetrf2_$descriptor() {
        return zgetrf2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgetrf2_$handle() {
        return zgetrf2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgetrf2_$address() {
        return zgetrf2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrf2_(const int *m, const int *n, _Complex double *A, const int *lda, int *ipiv, int *info)
     * }
     */
    public static void zgetrf2_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgetrf2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrf2_", m, n, A, lda, ipiv, info);
            }
            mh$.invokeExact(m, n, A, lda, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgetri_$descriptor() {
        return cgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgetri_$handle() {
        return cgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgetri_$address() {
        return cgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetri_(const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgetri_$descriptor() {
        return dgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgetri_$handle() {
        return dgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgetri_$address() {
        return dgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetri_(const int *n, double *A, const int *lda, const int *ipiv, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgetri_$descriptor() {
        return sgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgetri_$handle() {
        return sgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgetri_$address() {
        return sgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetri_(const int *n, float *A, const int *lda, const int *ipiv, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgetri_$descriptor() {
        return zgetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgetri_$handle() {
        return zgetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgetri_$address() {
        return zgetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetri_(const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgetri_(MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetri_", n, A, lda, ipiv, work, lwork, info);
            }
            mh$.invokeExact(n, A, lda, ipiv, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgetrs_$descriptor() {
        return cgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgetrs_$handle() {
        return cgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgetrs_$address() {
        return cgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = cgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgetrs_$descriptor() {
        return dgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgetrs_$handle() {
        return dgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgetrs_$address() {
        return dgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetrs_(const char *trans, const int *n, const int *nrhs, const double *A, const int *lda, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = dgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgetrs_$descriptor() {
        return sgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgetrs_$handle() {
        return sgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgetrs_$address() {
        return sgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetrs_(const char *trans, const int *n, const int *nrhs, const float *A, const int *lda, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = sgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgetrs_$descriptor() {
        return zgetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgetrs_$handle() {
        return zgetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgetrs_$address() {
        return zgetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgetrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zgetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetrs_", trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(trans, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgetsls_$descriptor() {
        return cgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgetsls_$handle() {
        return cgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgetsls_$address() {
        return cgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void cgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = cgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgetsls_$descriptor() {
        return dgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgetsls_$handle() {
        return dgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgetsls_$address() {
        return dgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, double *A, const int *lda, double *B, const int *ldb, double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void dgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = dgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgetsls_$descriptor() {
        return sgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgetsls_$handle() {
        return sgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgetsls_$address() {
        return sgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, float *A, const int *lda, float *B, const int *ldb, float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void sgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = sgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetsls_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetsls_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgetsls_$descriptor() {
        return zgetsls_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgetsls_$handle() {
        return zgetsls_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgetsls_$address() {
        return zgetsls_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetsls_(const char *trans, const int *m, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zgetsls_(MemorySegment trans, MemorySegment m, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zgetsls_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetsls_", trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(trans, m, n, nrhs, A, lda, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgetsqrhrt_$descriptor() {
        return cgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgetsqrhrt_$handle() {
        return cgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgetsqrhrt_$address() {
        return cgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex float *A, const int *lda, _Complex float *T, const int *ldt, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgetsqrhrt_$descriptor() {
        return dgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgetsqrhrt_$handle() {
        return dgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgetsqrhrt_$address() {
        return dgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, double *A, const int *lda, double *T, const int *ldt, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgetsqrhrt_$descriptor() {
        return sgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgetsqrhrt_$handle() {
        return sgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgetsqrhrt_$address() {
        return sgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, float *A, const int *lda, float *T, const int *ldt, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgetsqrhrt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgetsqrhrt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgetsqrhrt_$descriptor() {
        return zgetsqrhrt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgetsqrhrt_$handle() {
        return zgetsqrhrt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgetsqrhrt_$address() {
        return zgetsqrhrt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgetsqrhrt_(const int *m, const int *n, const int *mb1, const int *nb1, const int *nb2, _Complex double *A, const int *lda, _Complex double *T, const int *ldt, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgetsqrhrt_(MemorySegment m, MemorySegment n, MemorySegment mb1, MemorySegment nb1, MemorySegment nb2, MemorySegment A, MemorySegment lda, MemorySegment T, MemorySegment ldt, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgetsqrhrt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgetsqrhrt_", m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
            }
            mh$.invokeExact(m, n, mb1, nb1, nb2, A, lda, T, ldt, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggbak_$descriptor() {
        return cggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggbak_$handle() {
        return cggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggbak_$address() {
        return cggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, _Complex float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void cggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = cggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggbak_$descriptor() {
        return dggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggbak_$handle() {
        return dggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggbak_$address() {
        return dggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void dggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = dggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggbak_$descriptor() {
        return sggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggbak_$handle() {
        return sggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggbak_$address() {
        return sggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const float *lscale, const float *rscale, const int *m, float *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void sggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = sggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbak_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggbak_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggbak_$descriptor() {
        return zggbak_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggbak_$handle() {
        return zggbak_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggbak_$address() {
        return zggbak_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggbak_(const char *job, const char *side, const int *n, const int *ilo, const int *ihi, const double *lscale, const double *rscale, const int *m, _Complex double *V, const int *ldv, int *info, size_t, size_t)
     * }
     */
    public static void zggbak_(MemorySegment job, MemorySegment side, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment m, MemorySegment V, MemorySegment ldv, MemorySegment info, long x11, long x12) {
        var mh$ = zggbak_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbak_", job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
            }
            mh$.invokeExact(job, side, n, ilo, ihi, lscale, rscale, m, V, ldv, info, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cggbal_$descriptor() {
        return cggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cggbal_$handle() {
        return cggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cggbal_$address() {
        return cggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggbal_(const char *job, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static void cggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = cggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dggbal_$descriptor() {
        return dggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle dggbal_$handle() {
        return dggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment dggbal_$address() {
        return dggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggbal_(const char *job, const int *n, double *A, const int *lda, double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static void dggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = dggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sggbal_$descriptor() {
        return sggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MethodHandle sggbal_$handle() {
        return sggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static MemorySegment sggbal_$address() {
        return sggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggbal_(const char *job, const int *n, float *A, const int *lda, float *B, const int *ldb, int *ilo, int *ihi, float *lscale, float *rscale, float *work, int *info, size_t)
     * }
     */
    public static void sggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = sggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggbal_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggbal_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zggbal_$descriptor() {
        return zggbal_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zggbal_$handle() {
        return zggbal_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zggbal_$address() {
        return zggbal_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggbal_(const char *job, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *ilo, int *ihi, double *lscale, double *rscale, double *work, int *info, size_t)
     * }
     */
    public static void zggbal_(MemorySegment job, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment work, MemorySegment info, long x12) {
        var mh$ = zggbal_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggbal_", job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
            }
            mh$.invokeExact(job, n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgges_$descriptor() {
        return cgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgges_$handle() {
        return cgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgges_$address() {
        return cgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgges_$descriptor() {
        return dgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgges_$handle() {
        return dgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgges_$address() {
        return dgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgges_$descriptor() {
        return sgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgges_$handle() {
        return sgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgges_$address() {
        return sgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgges_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgges_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgges_$descriptor() {
        return zgges_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgges_$handle() {
        return zgges_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgges_$address() {
        return zgges_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgges_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgges_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zgges_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgges_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgges3_$descriptor() {
        return cgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cgges3_$handle() {
        return cgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cgges3_$address() {
        return cgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, _Complex float *work, const int *lwork, float *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgges3_$descriptor() {
        return dgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dgges3_$handle() {
        return dgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dgges3_$address() {
        return dgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = dgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgges3_$descriptor() {
        return sgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sgges3_$handle() {
        return sgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sgges3_$address() {
        return sgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *work, const int *lwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = sgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgges3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgges3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgges3_$descriptor() {
        return zgges3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zgges3_$handle() {
        return zgges3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zgges3_$address() {
        return zgges3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgges3_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, _Complex double *work, const int *lwork, double *rwork, int *BWORK, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zgges3_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment BWORK, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zgges3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgges3_", jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, work, lwork, rwork, BWORK, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggesx_$descriptor() {
        return cggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggesx_$handle() {
        return cggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggesx_$address() {
        return cggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_C_SELECT2 selctg, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, int *sdim, _Complex float *alpha, _Complex float *beta, _Complex float *VSL, const int *ldvsl, _Complex float *VSR, const int *ldvsr, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = cggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggesx_$descriptor() {
        return dggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggesx_$handle() {
        return dggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggesx_$address() {
        return dggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_D_SELECT3 selctg, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, int *sdim, double *alphar, double *alphai, double *beta, double *VSL, const int *ldvsl, double *VSR, const int *ldvsr, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = dggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggesx_$descriptor() {
        return sggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggesx_$handle() {
        return sggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggesx_$address() {
        return sggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_S_SELECT3 selctg, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, int *sdim, float *alphar, float *alphai, float *beta, float *VSL, const int *ldvsl, float *VSR, const int *ldvsr, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = sggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alphar, alphai, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggesx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggesx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggesx_$descriptor() {
        return zggesx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggesx_$handle() {
        return zggesx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggesx_$address() {
        return zggesx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggesx_(const char *jobvsl, const char *jobvsr, const char *sort, LAPACK_Z_SELECT2 selctg, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, int *sdim, _Complex double *alpha, _Complex double *beta, _Complex double *VSL, const int *ldvsl, _Complex double *VSR, const int *ldvsr, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, const int *liwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zggesx_(MemorySegment jobvsl, MemorySegment jobvsr, MemorySegment sort, MemorySegment selctg, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment sdim, MemorySegment alpha, MemorySegment beta, MemorySegment VSL, MemorySegment ldvsl, MemorySegment VSR, MemorySegment ldvsr, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment liwork, MemorySegment BWORK, MemorySegment info, long x26, long x27, long x28, long x29) {
        var mh$ = zggesx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggesx_", jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
            }
            mh$.invokeExact(jobvsl, jobvsr, sort, selctg, sense, n, A, lda, B, ldb, sdim, alpha, beta, VSL, ldvsl, VSR, ldvsr, rconde, rcondv, work, lwork, rwork, iwork, liwork, BWORK, info, x26, x27, x28, x29);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggev_$descriptor() {
        return cggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggev_$handle() {
        return cggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggev_$address() {
        return cggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggev_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggev_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggev_$descriptor() {
        return dggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggev_$handle() {
        return dggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggev_$address() {
        return dggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggev_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = dggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggev_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggev_$descriptor() {
        return sggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggev_$handle() {
        return sggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggev_$address() {
        return sggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggev_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = sggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggev_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggev_$descriptor() {
        return zggev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggev_$handle() {
        return zggev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggev_$address() {
        return zggev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggev_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zggev_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zggev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggev_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggev3_$descriptor() {
        return cggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cggev3_$handle() {
        return cggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cggev3_$address() {
        return cggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = cggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggev3_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggev3_$descriptor() {
        return dggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dggev3_$handle() {
        return dggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dggev3_$address() {
        return dggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggev3_(const char *jobvl, const char *jobvr, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = dggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggev3_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggev3_$descriptor() {
        return sggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sggev3_$handle() {
        return sggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sggev3_$address() {
        return sggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggev3_(const char *jobvl, const char *jobvr, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment info, long x17, long x18) {
        var mh$ = sggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggev3_", jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, work, lwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggev3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggev3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggev3_$descriptor() {
        return zggev3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zggev3_$handle() {
        return zggev3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zggev3_$address() {
        return zggev3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggev3_(const char *jobvl, const char *jobvr, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zggev3_(MemorySegment jobvl, MemorySegment jobvr, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zggev3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggev3_", jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
            }
            mh$.invokeExact(jobvl, jobvr, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, work, lwork, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggevx_$descriptor() {
        return cggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggevx_$handle() {
        return cggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggevx_$address() {
        return cggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *alpha, _Complex float *beta, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void cggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = cggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggevx_$descriptor() {
        return dggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggevx_$handle() {
        return dggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggevx_$address() {
        return dggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, double *A, const int *lda, double *B, const int *ldb, double *alphar, double *alphai, double *beta, double *VL, const int *ldvl, double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, double *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void dggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = dggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggevx_$descriptor() {
        return sggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggevx_$handle() {
        return sggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggevx_$address() {
        return sggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, float *A, const int *lda, float *B, const int *ldb, float *alphar, float *alphai, float *beta, float *VL, const int *ldvl, float *VR, const int *ldvr, int *ilo, int *ihi, float *lscale, float *rscale, float *abnrm, float *bbnrm, float *rconde, float *rcondv, float *work, const int *lwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void sggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = sggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alphar, alphai, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggevx_$descriptor() {
        return zggevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggevx_$handle() {
        return zggevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggevx_$address() {
        return zggevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *alpha, _Complex double *beta, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, int *ilo, int *ihi, double *lscale, double *rscale, double *abnrm, double *bbnrm, double *rconde, double *rcondv, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *BWORK, int *info, size_t, size_t, size_t, size_t)
     * }
     */
    public static void zggevx_(MemorySegment balanc, MemorySegment jobvl, MemorySegment jobvr, MemorySegment sense, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment ilo, MemorySegment ihi, MemorySegment lscale, MemorySegment rscale, MemorySegment abnrm, MemorySegment bbnrm, MemorySegment rconde, MemorySegment rcondv, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment BWORK, MemorySegment info, long x29, long x30, long x31, long x32) {
        var mh$ = zggevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggevx_", balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
            }
            mh$.invokeExact(balanc, jobvl, jobvr, sense, n, A, lda, B, ldb, alpha, beta, VL, ldvl, VR, ldvr, ilo, ihi, lscale, rscale, abnrm, bbnrm, rconde, rcondv, work, lwork, rwork, iwork, BWORK, info, x29, x30, x31, x32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggglm_$descriptor() {
        return cggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggglm_$handle() {
        return cggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggglm_$address() {
        return cggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggglm_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *D, _Complex float *X, _Complex float *Y, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggglm_$descriptor() {
        return dggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggglm_$handle() {
        return dggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggglm_$address() {
        return dggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggglm_(const int *n, const int *m, const int *p, double *A, const int *lda, double *B, const int *ldb, double *D, double *X, double *Y, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggglm_$descriptor() {
        return sggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggglm_$handle() {
        return sggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggglm_$address() {
        return sggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggglm_(const int *n, const int *m, const int *p, float *A, const int *lda, float *B, const int *ldb, float *D, float *X, float *Y, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggglm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggglm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggglm_$descriptor() {
        return zggglm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggglm_$handle() {
        return zggglm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggglm_$address() {
        return zggglm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggglm_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *D, _Complex double *X, _Complex double *Y, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggglm_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment D, MemorySegment X, MemorySegment Y, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggglm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggglm_", n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, B, ldb, D, X, Y, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgghd3_$descriptor() {
        return cgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgghd3_$handle() {
        return cgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgghd3_$address() {
        return cgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void cgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = cgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgghd3_$descriptor() {
        return dgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgghd3_$handle() {
        return dgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgghd3_$address() {
        return dgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = dgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgghd3_$descriptor() {
        return sgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgghd3_$handle() {
        return sgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgghd3_$address() {
        return sgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void sgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = sgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgghd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgghd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgghd3_$descriptor() {
        return zgghd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgghd3_$handle() {
        return zgghd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgghd3_$address() {
        return zgghd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgghd3_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zgghd3_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x16, long x17) {
        var mh$ = zgghd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgghd3_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, work, lwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgghrd_$descriptor() {
        return cgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgghrd_$handle() {
        return cgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgghrd_$address() {
        return cgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void cgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = cgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgghrd_$descriptor() {
        return dgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgghrd_$handle() {
        return dgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgghrd_$address() {
        return dgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *A, const int *lda, double *B, const int *ldb, double *Q, const int *ldq, double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void dgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = dgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgghrd_$descriptor() {
        return sgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgghrd_$handle() {
        return sgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgghrd_$address() {
        return sgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *A, const int *lda, float *B, const int *ldb, float *Q, const int *ldq, float *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void sgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = sgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgghrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgghrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgghrd_$descriptor() {
        return zgghrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgghrd_$handle() {
        return zgghrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgghrd_$address() {
        return zgghrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgghrd_(const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, int *info, size_t, size_t)
     * }
     */
    public static void zgghrd_(MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment info, long x14, long x15) {
        var mh$ = zgghrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgghrd_", compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
            }
            mh$.invokeExact(compq, compz, n, ilo, ihi, A, lda, B, ldb, Q, ldq, Z, ldz, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cgglse_$descriptor() {
        return cgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cgglse_$handle() {
        return cgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cgglse_$address() {
        return cgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgglse_(const int *m, const int *n, const int *p, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, _Complex float *C, _Complex float *D, _Complex float *X, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dgglse_$descriptor() {
        return dgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dgglse_$handle() {
        return dgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dgglse_$address() {
        return dgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgglse_(const int *m, const int *n, const int *p, double *A, const int *lda, double *B, const int *ldb, double *C, double *D, double *X, double *work, const int *lwork, int *info)
     * }
     */
    public static void dgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sgglse_$descriptor() {
        return sgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sgglse_$handle() {
        return sgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sgglse_$address() {
        return sgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgglse_(const int *m, const int *n, const int *p, float *A, const int *lda, float *B, const int *ldb, float *C, float *D, float *X, float *work, const int *lwork, int *info)
     * }
     */
    public static void sgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgglse_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgglse_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zgglse_$descriptor() {
        return zgglse_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zgglse_$handle() {
        return zgglse_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zgglse_$address() {
        return zgglse_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgglse_(const int *m, const int *n, const int *p, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, _Complex double *C, _Complex double *D, _Complex double *X, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zgglse_(MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment D, MemorySegment X, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zgglse_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgglse_", m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
            }
            mh$.invokeExact(m, n, p, A, lda, B, ldb, C, D, X, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggqrf_$descriptor() {
        return cggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggqrf_$handle() {
        return cggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggqrf_$address() {
        return cggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggqrf_(const int *n, const int *m, const int *p, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggqrf_$descriptor() {
        return dggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggqrf_$handle() {
        return dggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggqrf_$address() {
        return dggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggqrf_(const int *n, const int *m, const int *p, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggqrf_$descriptor() {
        return sggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggqrf_$handle() {
        return sggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggqrf_$address() {
        return sggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggqrf_(const int *n, const int *m, const int *p, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggqrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggqrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggqrf_$descriptor() {
        return zggqrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggqrf_$handle() {
        return zggqrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggqrf_$address() {
        return zggqrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggqrf_(const int *n, const int *m, const int *p, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggqrf_(MemorySegment n, MemorySegment m, MemorySegment p, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggqrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggqrf_", n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(n, m, p, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor cggrqf_$descriptor() {
        return cggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle cggrqf_$handle() {
        return cggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment cggrqf_$address() {
        return cggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggrqf_(const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *taua, _Complex float *B, const int *ldb, _Complex float *taub, _Complex float *work, const int *lwork, int *info)
     * }
     */
    public static void cggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = cggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor dggrqf_$descriptor() {
        return dggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle dggrqf_$handle() {
        return dggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment dggrqf_$address() {
        return dggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggrqf_(const int *m, const int *p, const int *n, double *A, const int *lda, double *taua, double *B, const int *ldb, double *taub, double *work, const int *lwork, int *info)
     * }
     */
    public static void dggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = dggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor sggrqf_$descriptor() {
        return sggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle sggrqf_$handle() {
        return sggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment sggrqf_$address() {
        return sggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggrqf_(const int *m, const int *p, const int *n, float *A, const int *lda, float *taua, float *B, const int *ldb, float *taub, float *work, const int *lwork, int *info)
     * }
     */
    public static void sggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = sggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggrqf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggrqf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static FunctionDescriptor zggrqf_$descriptor() {
        return zggrqf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MethodHandle zggrqf_$handle() {
        return zggrqf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static MemorySegment zggrqf_$address() {
        return zggrqf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggrqf_(const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *taua, _Complex double *B, const int *ldb, _Complex double *taub, _Complex double *work, const int *lwork, int *info)
     * }
     */
    public static void zggrqf_(MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment taua, MemorySegment B, MemorySegment ldb, MemorySegment taub, MemorySegment work, MemorySegment lwork, MemorySegment info) {
        var mh$ = zggrqf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggrqf_", m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
            }
            mh$.invokeExact(m, p, n, A, lda, taua, B, ldb, taub, work, lwork, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvd_$descriptor() {
        return cggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvd_$handle() {
        return cggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvd_$address() {
        return cggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *alpha, float *beta, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, _Complex float *work, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int cggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = cggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvd_$descriptor() {
        return sggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvd_$handle() {
        return sggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvd_$address() {
        return sggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *a, const int *lda, float *b, const int *ldb, float *alpha, float *beta, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, float *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int sggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = sggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvd_$descriptor() {
        return dggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvd_$handle() {
        return dggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvd_$address() {
        return dggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *a, const int *lda, double *b, const int *ldb, double *alpha, double *beta, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, double *work, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int dggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment iwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = dggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, iwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggsvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvd_$descriptor() {
        return zggsvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvd_$handle() {
        return zggsvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvd_$address() {
        return zggsvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvd_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *alpha, double *beta, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, _Complex double *work, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static int zggsvd_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zggsvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvd_", jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, a, lda, b, ldb, alpha, beta, u, ldu, v, ldv, q, ldq, work, rwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvd3_$descriptor() {
        return cggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvd3_$handle() {
        return cggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvd3_$address() {
        return cggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *alpha, float *beta, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvd3_$descriptor() {
        return dggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvd3_$handle() {
        return dggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvd3_$address() {
        return dggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, double *A, const int *lda, double *B, const int *ldb, double *alpha, double *beta, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, double *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvd3_$descriptor() {
        return sggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvd3_$handle() {
        return sggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvd3_$address() {
        return sggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, float *A, const int *lda, float *B, const int *ldb, float *alpha, float *beta, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, float *work, const int *lwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment iwork, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, iwork, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvd3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggsvd3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvd3_$descriptor() {
        return zggsvd3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvd3_$handle() {
        return zggsvd3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvd3_$address() {
        return zggsvd3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggsvd3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *n, const int *p, int *k, int *l, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *alpha, double *beta, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zggsvd3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment n, MemorySegment p, MemorySegment k, MemorySegment l, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment alpha, MemorySegment beta, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zggsvd3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvd3_", jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, n, p, k, l, A, lda, B, ldb, alpha, beta, U, ldu, V, ldv, Q, ldq, work, lwork, rwork, iwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvp_$descriptor() {
        return sggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvp_$handle() {
        return sggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvp_$address() {
        return sggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *a, const int *lda, float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, float *u, const int *ldu, float *v, const int *ldv, float *q, const int *ldq, int *iwork, float *tau, float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int sggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = sggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvp_$descriptor() {
        return dggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvp_$handle() {
        return dggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvp_$address() {
        return dggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *a, const int *lda, double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, double *u, const int *ldu, double *v, const int *ldv, double *q, const int *ldq, int *iwork, double *tau, double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int dggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = dggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, tau, work, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvp_$descriptor() {
        return cggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvp_$handle() {
        return cggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvp_$address() {
        return cggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *a, const int *lda, _Complex float *b, const int *ldb, float *tola, float *tolb, int *k, int *l, _Complex float *u, const int *ldu, _Complex float *v, const int *ldv, _Complex float *q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int cggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = cggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_INT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggsvp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvp_$descriptor() {
        return zggsvp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvp_$handle() {
        return zggsvp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvp_$address() {
        return zggsvp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int zggsvp_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *a, const int *lda, _Complex double *b, const int *ldb, double *tola, double *tolb, int *k, int *l, _Complex double *u, const int *ldu, _Complex double *v, const int *ldv, _Complex double *q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, int *info, size_t, size_t, size_t)
     * }
     */
    public static int zggsvp_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment a, MemorySegment lda, MemorySegment b, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment u, MemorySegment ldu, MemorySegment v, MemorySegment ldv, MemorySegment q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = zggsvp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvp_", jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
            }
            return (int)mh$.invokeExact(jobu, jobv, jobq, m, p, n, a, lda, b, ldb, tola, tolb, k, l, u, ldu, v, ldv, q, ldq, iwork, rwork, tau, work, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cggsvp3_$descriptor() {
        return cggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cggsvp3_$handle() {
        return cggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cggsvp3_$address() {
        return cggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, _Complex float *U, const int *ldu, _Complex float *V, const int *ldv, _Complex float *Q, const int *ldq, int *iwork, float *rwork, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = cggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dggsvp3_$descriptor() {
        return dggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dggsvp3_$handle() {
        return dggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dggsvp3_$address() {
        return dggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, double *A, const int *lda, double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, double *U, const int *ldu, double *V, const int *ldv, double *Q, const int *ldq, int *iwork, double *tau, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = dggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sggsvp3_$descriptor() {
        return sggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle sggsvp3_$handle() {
        return sggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment sggsvp3_$address() {
        return sggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, float *A, const int *lda, float *B, const int *ldb, const float *tola, const float *tolb, int *k, int *l, float *U, const int *ldu, float *V, const int *ldv, float *Q, const int *ldq, int *iwork, float *tau, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void sggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x25, long x26, long x27) {
        var mh$ = sggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, tau, work, lwork, info, x25, x26, x27);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zggsvp3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zggsvp3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zggsvp3_$descriptor() {
        return zggsvp3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zggsvp3_$handle() {
        return zggsvp3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zggsvp3_$address() {
        return zggsvp3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zggsvp3_(const char *jobu, const char *jobv, const char *jobq, const int *m, const int *p, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *tola, const double *tolb, int *k, int *l, _Complex double *U, const int *ldu, _Complex double *V, const int *ldv, _Complex double *Q, const int *ldq, int *iwork, double *rwork, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zggsvp3_(MemorySegment jobu, MemorySegment jobv, MemorySegment jobq, MemorySegment m, MemorySegment p, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment tola, MemorySegment tolb, MemorySegment k, MemorySegment l, MemorySegment U, MemorySegment ldu, MemorySegment V, MemorySegment ldv, MemorySegment Q, MemorySegment ldq, MemorySegment iwork, MemorySegment rwork, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zggsvp3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zggsvp3_", jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
            }
            mh$.invokeExact(jobu, jobv, jobq, m, p, n, A, lda, B, ldb, tola, tolb, k, l, U, ldu, V, ldv, Q, ldq, iwork, rwork, tau, work, lwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgtcon_$descriptor() {
        return cgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cgtcon_$handle() {
        return cgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cgtcon_$address() {
        return cgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtcon_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x11) {
        var mh$ = cgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgtcon_$descriptor() {
        return dgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgtcon_$handle() {
        return dgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgtcon_$address() {
        return dgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtcon_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, const double *anorm, double *rcond, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = dgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgtcon_$descriptor() {
        return sgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgtcon_$handle() {
        return sgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgtcon_$address() {
        return sgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtcon_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, const float *anorm, float *rcond, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment iwork, MemorySegment info, long x12) {
        var mh$ = sgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, iwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgtcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgtcon_$descriptor() {
        return zgtcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zgtcon_$handle() {
        return zgtcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zgtcon_$address() {
        return zgtcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtcon_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zgtcon_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x11) {
        var mh$ = zgtcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtcon_", norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
            }
            mh$.invokeExact(norm, n, DL, D, DU, DU2, ipiv, anorm, rcond, work, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgtrfs_$descriptor() {
        return cgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cgtrfs_$handle() {
        return cgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cgtrfs_$address() {
        return cgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DLF, const _Complex float *DF, const _Complex float *DUF, const _Complex float *DU2, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20) {
        var mh$ = cgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgtrfs_$descriptor() {
        return dgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle dgtrfs_$handle() {
        return dgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment dgtrfs_$address() {
        return dgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtrfs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DLF, const double *DF, const double *DUF, const double *DU2, const int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *ferr, double *berr, double *work, int *iwork, int *info, size_t)
     * }
     */
    public static void dgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20) {
        var mh$ = dgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgtrfs_$descriptor() {
        return sgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MethodHandle sgtrfs_$handle() {
        return sgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static MemorySegment sgtrfs_$address() {
        return sgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtrfs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DLF, const float *DF, const float *DUF, const float *DU2, const int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *ferr, float *berr, float *work, int *iwork, int *info, size_t)
     * }
     */
    public static void sgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x20) {
        var mh$ = sgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, iwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtrfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgtrfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgtrfs_$descriptor() {
        return zgtrfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zgtrfs_$handle() {
        return zgtrfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zgtrfs_$address() {
        return zgtrfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtrfs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DLF, const _Complex double *DF, const _Complex double *DUF, const _Complex double *DU2, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zgtrfs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x20) {
        var mh$ = zgtrfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtrfs_", trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor cgtsv_$descriptor() {
        return cgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle cgtsv_$handle() {
        return cgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment cgtsv_$address() {
        return cgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtsv_(const int *n, const int *nrhs, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *B, const int *ldb, int *info)
     * }
     */
    public static void cgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = cgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor dgtsv_$descriptor() {
        return dgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle dgtsv_$handle() {
        return dgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment dgtsv_$address() {
        return dgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtsv_(const int *n, const int *nrhs, double *DL, double *D, double *DU, double *B, const int *ldb, int *info)
     * }
     */
    public static void dgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = dgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor sgtsv_$descriptor() {
        return sgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle sgtsv_$handle() {
        return sgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment sgtsv_$address() {
        return sgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtsv_(const int *n, const int *nrhs, float *DL, float *D, float *DU, float *B, const int *ldb, int *info)
     * }
     */
    public static void sgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = sgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgtsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static FunctionDescriptor zgtsv_$descriptor() {
        return zgtsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MethodHandle zgtsv_$handle() {
        return zgtsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static MemorySegment zgtsv_$address() {
        return zgtsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtsv_(const int *n, const int *nrhs, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *B, const int *ldb, int *info)
     * }
     */
    public static void zgtsv_(MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment B, MemorySegment ldb, MemorySegment info) {
        var mh$ = zgtsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsv_", n, nrhs, DL, D, DU, B, ldb, info);
            }
            mh$.invokeExact(n, nrhs, DL, D, DU, B, ldb, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cgtsvx_$descriptor() {
        return cgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cgtsvx_$handle() {
        return cgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cgtsvx_$address() {
        return cgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, _Complex float *DLF, _Complex float *DF, _Complex float *DUF, _Complex float *DU2, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23) {
        var mh$ = cgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dgtsvx_$descriptor() {
        return dgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dgtsvx_$handle() {
        return dgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dgtsvx_$address() {
        return dgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, double *DLF, double *DF, double *DUF, double *DU2, int *ipiv, const double *B, const int *ldb, double *X, const int *ldx, double *rcond, double *ferr, double *berr, double *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void dgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23) {
        var mh$ = dgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor sgtsvx_$descriptor() {
        return sgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle sgtsvx_$handle() {
        return sgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment sgtsvx_$address() {
        return sgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, float *DLF, float *DF, float *DUF, float *DU2, int *ipiv, const float *B, const int *ldb, float *X, const int *ldx, float *rcond, float *ferr, float *berr, float *work, int *iwork, int *info, size_t, size_t)
     * }
     */
    public static void sgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment iwork, MemorySegment info, long x22, long x23) {
        var mh$ = sgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, iwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgtsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgtsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zgtsvx_$descriptor() {
        return zgtsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zgtsvx_$handle() {
        return zgtsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zgtsvx_$address() {
        return zgtsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgtsvx_(const char *fact, const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, _Complex double *DLF, _Complex double *DF, _Complex double *DUF, _Complex double *DU2, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zgtsvx_(MemorySegment fact, MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DLF, MemorySegment DF, MemorySegment DUF, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x22, long x23) {
        var mh$ = zgtsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgtsvx_", fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
            }
            mh$.invokeExact(fact, trans, n, nrhs, DL, D, DU, DLF, DF, DUF, DU2, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor cgttrf_$descriptor() {
        return cgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle cgttrf_$handle() {
        return cgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment cgttrf_$address() {
        return cgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgttrf_(const int *n, _Complex float *DL, _Complex float *D, _Complex float *DU, _Complex float *DU2, int *ipiv, int *info)
     * }
     */
    public static void cgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = cgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor dgttrf_$descriptor() {
        return dgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle dgttrf_$handle() {
        return dgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment dgttrf_$address() {
        return dgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgttrf_(const int *n, double *DL, double *D, double *DU, double *DU2, int *ipiv, int *info)
     * }
     */
    public static void dgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = dgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor sgttrf_$descriptor() {
        return sgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle sgttrf_$handle() {
        return sgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment sgttrf_$address() {
        return sgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgttrf_(const int *n, float *DL, float *D, float *DU, float *DU2, int *ipiv, int *info)
     * }
     */
    public static void sgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = sgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgttrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static FunctionDescriptor zgttrf_$descriptor() {
        return zgttrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static MethodHandle zgttrf_$handle() {
        return zgttrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static MemorySegment zgttrf_$address() {
        return zgttrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgttrf_(const int *n, _Complex double *DL, _Complex double *D, _Complex double *DU, _Complex double *DU2, int *ipiv, int *info)
     * }
     */
    public static void zgttrf_(MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment info) {
        var mh$ = zgttrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrf_", n, DL, D, DU, DU2, ipiv, info);
            }
            mh$.invokeExact(n, DL, D, DU, DU2, ipiv, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cgttrs_$descriptor() {
        return cgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle cgttrs_$handle() {
        return cgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment cgttrs_$address() {
        return cgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, const _Complex float *DU2, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void cgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = cgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor dgttrs_$descriptor() {
        return dgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle dgttrs_$handle() {
        return dgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment dgttrs_$address() {
        return dgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dgttrs_(const char *trans, const int *n, const int *nrhs, const double *DL, const double *D, const double *DU, const double *DU2, const int *ipiv, double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void dgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = dgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("sgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor sgttrs_$descriptor() {
        return sgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle sgttrs_$handle() {
        return sgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment sgttrs_$address() {
        return sgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sgttrs_(const char *trans, const int *n, const int *nrhs, const float *DL, const float *D, const float *DU, const float *DU2, const int *ipiv, float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void sgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = sgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zgttrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zgttrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zgttrs_$descriptor() {
        return zgttrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zgttrs_$handle() {
        return zgttrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zgttrs_$address() {
        return zgttrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zgttrs_(const char *trans, const int *n, const int *nrhs, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, const _Complex double *DU2, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zgttrs_(MemorySegment trans, MemorySegment n, MemorySegment nrhs, MemorySegment DL, MemorySegment D, MemorySegment DU, MemorySegment DU2, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x11) {
        var mh$ = zgttrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zgttrs_", trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
            }
            mh$.invokeExact(trans, n, nrhs, DL, D, DU, DU2, ipiv, B, ldb, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbev_$descriptor() {
        return chbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbev_$handle() {
        return chbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbev_$address() {
        return chbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = chbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbev_$descriptor() {
        return zhbev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbev_$handle() {
        return zhbev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbev_$address() {
        return zhbev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbev_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = zhbev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbev_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbev_2stage_$descriptor() {
        return chbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbev_2stage_$handle() {
        return chbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbev_2stage_$address() {
        return chbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbev_2stage_$descriptor() {
        return zhbev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbev_2stage_$handle() {
        return zhbev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbev_2stage_$address() {
        return zhbev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbev_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhbev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbev_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevd_$descriptor() {
        return chbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbevd_$handle() {
        return chbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbevd_$address() {
        return chbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevd_$descriptor() {
        return zhbevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevd_$handle() {
        return zhbevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevd_$address() {
        return zhbevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevd_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhbevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevd_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevd_2stage_$descriptor() {
        return chbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbevd_2stage_$handle() {
        return chbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbevd_2stage_$address() {
        return chbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevd_2stage_$descriptor() {
        return zhbevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevd_2stage_$handle() {
        return zhbevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevd_2stage_$address() {
        return zhbevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevd_2stage_(const char *jobz, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhbevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevd_2stage_", jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(jobz, uplo, n, kd, AB, ldab, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevx_$descriptor() {
        return chbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbevx_$handle() {
        return chbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbevx_$address() {
        return chbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = chbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevx_$descriptor() {
        return zhbevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevx_$handle() {
        return zhbevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevx_$address() {
        return zhbevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zhbevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevx_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbevx_2stage_$descriptor() {
        return chbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbevx_2stage_$handle() {
        return chbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbevx_2stage_$address() {
        return chbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = chbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbevx_2stage_$descriptor() {
        return zhbevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbevx_2stage_$handle() {
        return zhbevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbevx_2stage_$address() {
        return zhbevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zhbevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbevx_2stage_", jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(jobz, range, uplo, n, kd, AB, ldab, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgst_$descriptor() {
        return chbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgst_$handle() {
        return chbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgst_$address() {
        return chbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, const _Complex float *BB, const int *ldbb, _Complex float *X, const int *ldx, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = chbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgst_$descriptor() {
        return zhbgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgst_$handle() {
        return zhbgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgst_$address() {
        return zhbgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgst_(const char *vect, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, const _Complex double *BB, const int *ldbb, _Complex double *X, const int *ldx, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgst_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment X, MemorySegment ldx, MemorySegment work, MemorySegment rwork, MemorySegment info, long x14, long x15) {
        var mh$ = zhbgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgst_", vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
            }
            mh$.invokeExact(vect, uplo, n, ka, kb, AB, ldab, BB, ldbb, X, ldx, work, rwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgv_$descriptor() {
        return chbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgv_$handle() {
        return chbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgv_$address() {
        return chbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = chbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgv_$descriptor() {
        return zhbgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgv_$handle() {
        return zhbgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgv_$address() {
        return zhbgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgv_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgv_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15, long x16) {
        var mh$ = zhbgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgv_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, rwork, info, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgvd_$descriptor() {
        return chbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbgvd_$handle() {
        return chbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbgvd_$address() {
        return chbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x19, long x20) {
        var mh$ = chbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgvd_$descriptor() {
        return zhbgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgvd_$handle() {
        return zhbgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgvd_$address() {
        return zhbgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgvd_(const char *jobz, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhbgvd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x19, long x20) {
        var mh$ = zhbgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvd_", jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
            }
            mh$.invokeExact(jobz, uplo, n, ka, kb, AB, ldab, BB, ldbb, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x19, x20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbgvx_$descriptor() {
        return chbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chbgvx_$handle() {
        return chbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chbgvx_$address() {
        return chbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex float *AB, const int *ldab, _Complex float *BB, const int *ldbb, _Complex float *Q, const int *ldq, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = chbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbgvx_$descriptor() {
        return zhbgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhbgvx_$handle() {
        return zhbgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhbgvx_$address() {
        return zhbgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbgvx_(const char *jobz, const char *range, const char *uplo, const int *n, const int *ka, const int *kb, _Complex double *AB, const int *ldab, _Complex double *BB, const int *ldbb, _Complex double *Q, const int *ldq, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhbgvx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment ka, MemorySegment kb, MemorySegment AB, MemorySegment ldab, MemorySegment BB, MemorySegment ldbb, MemorySegment Q, MemorySegment ldq, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zhbgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbgvx_", jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
            }
            mh$.invokeExact(jobz, range, uplo, n, ka, kb, AB, ldab, BB, ldbb, Q, ldq, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chbtrd_$descriptor() {
        return chbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chbtrd_$handle() {
        return chbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chbtrd_$address() {
        return chbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex float *AB, const int *ldab, float *D, float *E, _Complex float *Q, const int *ldq, _Complex float *work, int *info, size_t, size_t)
     * }
     */
    public static void chbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = chbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhbtrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhbtrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhbtrd_$descriptor() {
        return zhbtrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhbtrd_$handle() {
        return zhbtrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhbtrd_$address() {
        return zhbtrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhbtrd_(const char *vect, const char *uplo, const int *n, const int *kd, _Complex double *AB, const int *ldab, double *D, double *E, _Complex double *Q, const int *ldq, _Complex double *work, int *info, size_t, size_t)
     * }
     */
    public static void zhbtrd_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment kd, MemorySegment AB, MemorySegment ldab, MemorySegment D, MemorySegment E, MemorySegment Q, MemorySegment ldq, MemorySegment work, MemorySegment info, long x12, long x13) {
        var mh$ = zhbtrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhbtrd_", vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
            }
            mh$.invokeExact(vect, uplo, n, kd, AB, ldab, D, E, Q, ldq, work, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("checon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor checon_$descriptor() {
        return checon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle checon_$handle() {
        return checon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment checon_$address() {
        return checon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void checon_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void checon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = checon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhecon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhecon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhecon_$descriptor() {
        return zhecon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhecon_$handle() {
        return zhecon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhecon_$address() {
        return zhecon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhecon_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhecon_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zhecon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhecon_", uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, anorm, rcond, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("checon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor checon_3_$descriptor() {
        return checon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle checon_3_$handle() {
        return checon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment checon_3_$address() {
        return checon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void checon_3_(const char *uplo, const int *n, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void checon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = checon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhecon_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhecon_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhecon_3_$descriptor() {
        return zhecon_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhecon_3_$handle() {
        return zhecon_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhecon_3_$address() {
        return zhecon_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhecon_3_(const char *uplo, const int *n, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhecon_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zhecon_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhecon_3_", uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, anorm, rcond, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cheequb_$descriptor() {
        return cheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle cheequb_$handle() {
        return cheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment cheequb_$address() {
        return cheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheequb_(const char *uplo, const int *n, const _Complex float *A, const int *lda, float *S, float *scond, float *amax, _Complex float *work, int *info, size_t)
     * }
     */
    public static void cheequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = cheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheequb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheequb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zheequb_$descriptor() {
        return zheequb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zheequb_$handle() {
        return zheequb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zheequb_$address() {
        return zheequb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheequb_(const char *uplo, const int *n, const _Complex double *A, const int *lda, double *S, double *scond, double *amax, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zheequb_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment S, MemorySegment scond, MemorySegment amax, MemorySegment work, MemorySegment info, long x9) {
        var mh$ = zheequb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheequb_", uplo, n, A, lda, S, scond, amax, work, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, S, scond, amax, work, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheev_$descriptor() {
        return cheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheev_$handle() {
        return cheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheev_$address() {
        return cheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheev_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cheev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = cheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheev_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheev_$descriptor() {
        return zheev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheev_$handle() {
        return zheev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheev_$address() {
        return zheev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheev_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zheev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zheev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheev_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheev_2stage_$descriptor() {
        return cheev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheev_2stage_$handle() {
        return cheev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheev_2stage_$address() {
        return cheev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cheev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = cheev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheev_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheev_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheev_2stage_$descriptor() {
        return zheev_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheev_2stage_$handle() {
        return zheev_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheev_2stage_$address() {
        return zheev_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheev_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zheev_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zheev_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheev_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevd_$descriptor() {
        return cheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheevd_$handle() {
        return cheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheevd_$address() {
        return cheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevd_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cheevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = cheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevd_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevd_$descriptor() {
        return zheevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheevd_$handle() {
        return zheevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheevd_$address() {
        return zheevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevd_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zheevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = zheevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevd_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevd_2stage_$descriptor() {
        return cheevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cheevd_2stage_$handle() {
        return cheevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cheevd_2stage_$address() {
        return cheevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void cheevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = cheevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevd_2stage_$descriptor() {
        return zheevd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zheevd_2stage_$handle() {
        return zheevd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zheevd_2stage_$address() {
        return zheevd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevd_2stage_(const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zheevd_2stage_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x13, long x14) {
        var mh$ = zheevd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevd_2stage_", jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
            }
            mh$.invokeExact(jobz, uplo, n, A, lda, W, work, lwork, rwork, lrwork, iwork, liwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevr_$descriptor() {
        return cheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevr_$handle() {
        return cheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevr_$address() {
        return cheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevr_$descriptor() {
        return zheevr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevr_$handle() {
        return zheevr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevr_$address() {
        return zheevr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevr_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevr_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zheevr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevr_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevr_2stage_$descriptor() {
        return cheevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevr_2stage_$handle() {
        return cheevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevr_2stage_$address() {
        return cheevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, int *ISUPPZ, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = cheevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevr_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevr_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevr_2stage_$descriptor() {
        return zheevr_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevr_2stage_$handle() {
        return zheevr_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevr_2stage_$address() {
        return zheevr_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevr_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, int *ISUPPZ, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevr_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment ISUPPZ, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x23, long x24, long x25) {
        var mh$ = zheevr_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevr_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, ISUPPZ, work, lwork, rwork, lrwork, iwork, liwork, info, x23, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevx_$descriptor() {
        return cheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevx_$handle() {
        return cheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevx_$address() {
        return cheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevx_$descriptor() {
        return zheevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevx_$handle() {
        return zheevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevx_$address() {
        return zheevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zheevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevx_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cheevx_2stage_$descriptor() {
        return cheevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle cheevx_2stage_$handle() {
        return cheevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment cheevx_2stage_$address() {
        return cheevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void cheevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = cheevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheevx_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheevx_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zheevx_2stage_$descriptor() {
        return zheevx_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zheevx_2stage_$handle() {
        return zheevx_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zheevx_2stage_$address() {
        return zheevx_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheevx_2stage_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zheevx_2stage_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zheevx_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheevx_2stage_", jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(jobz, range, uplo, n, A, lda, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chegst_$descriptor() {
        return chegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chegst_$handle() {
        return chegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chegst_$address() {
        return chegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegst_(const int *itype, const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chegst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhegst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhegst_$descriptor() {
        return zhegst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhegst_$handle() {
        return zhegst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhegst_$address() {
        return zhegst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegst_(const int *itype, const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhegst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhegst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegst_", itype, uplo, n, A, lda, B, ldb, info, x8);
            }
            mh$.invokeExact(itype, uplo, n, A, lda, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegv_$descriptor() {
        return chegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegv_$handle() {
        return chegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegv_$address() {
        return chegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chegv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhegv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegv_$descriptor() {
        return zhegv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegv_$handle() {
        return zhegv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegv_$address() {
        return zhegv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhegv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegv_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chegv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegv_2stage_$descriptor() {
        return chegv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegv_2stage_$handle() {
        return chegv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegv_2stage_$address() {
        return chegv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chegv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = chegv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegv_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhegv_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegv_2stage_$descriptor() {
        return zhegv_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegv_2stage_$handle() {
        return zhegv_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegv_2stage_$address() {
        return zhegv_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegv_2stage_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegv_2stage_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhegv_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegv_2stage_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegvd_$descriptor() {
        return chegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chegvd_$handle() {
        return chegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chegvd_$address() {
        return chegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, float *W, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chegvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhegvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegvd_$descriptor() {
        return zhegvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhegvd_$handle() {
        return zhegvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhegvd_$address() {
        return zhegvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, double *W, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhegvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment W, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhegvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvd_", itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, A, lda, B, ldb, W, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chegvx_$descriptor() {
        return chegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chegvx_$handle() {
        return chegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chegvx_$address() {
        return chegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *B, const int *ldb, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chegvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = chegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chegvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhegvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhegvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhegvx_$descriptor() {
        return zhegvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhegvx_$handle() {
        return zhegvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhegvx_$address() {
        return zhegvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhegvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *B, const int *ldb, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhegvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x24, long x25, long x26) {
        var mh$ = zhegvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhegvx_", itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, A, lda, B, ldb, vl, vu, il, iu, abstol, m, W, Z, ldz, work, lwork, rwork, iwork, IFAIL, info, x24, x25, x26);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor cherfs_$descriptor() {
        return cherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle cherfs_$handle() {
        return cherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment cherfs_$address() {
        return cherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void cherfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = cherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zherfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zherfs_$descriptor() {
        return zherfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zherfs_$handle() {
        return zherfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zherfs_$address() {
        return zherfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zherfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zherfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17) {
        var mh$ = zherfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherfs_", uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cherfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cherfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor cherfsx_$descriptor() {
        return cherfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle cherfsx_$handle() {
        return cherfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment cherfsx_$address() {
        return cherfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *AF, const int *ldaf, const int *ipiv, const float *S, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void cherfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = cherfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cherfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zherfsx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zherfsx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zherfsx_$descriptor() {
        return zherfsx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zherfsx_$handle() {
        return zherfsx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zherfsx_$address() {
        return zherfsx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zherfsx_(const char *uplo, const char *equed, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *AF, const int *ldaf, const int *ipiv, const double *S, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zherfsx_(MemorySegment uplo, MemorySegment equed, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x24, long x25) {
        var mh$ = zherfsx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zherfsx_", uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
            }
            mh$.invokeExact(uplo, equed, n, nrhs, A, lda, AF, ldaf, ipiv, S, B, ldb, X, ldx, rcond, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x24, x25);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_$descriptor() {
        return chesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_$handle() {
        return chesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_$address() {
        return chesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_$descriptor() {
        return zhesv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_$handle() {
        return zhesv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_$address() {
        return zhesv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_aa_$descriptor() {
        return chesv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_aa_$handle() {
        return chesv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_aa_$address() {
        return chesv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesv_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_aa_$descriptor() {
        return zhesv_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_aa_$handle() {
        return zhesv_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_aa_$address() {
        return zhesv_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_aa_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_aa_2stage_$descriptor() {
        return chesv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_aa_2stage_$handle() {
        return chesv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_aa_2stage_$address() {
        return chesv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = chesv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesv_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_aa_2stage_$descriptor() {
        return zhesv_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_aa_2stage_$handle() {
        return zhesv_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_aa_2stage_$address() {
        return zhesv_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_aa_2stage_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14) {
        var mh$ = zhesv_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, work, lwork, info, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_rk_$descriptor() {
        return chesv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_rk_$handle() {
        return chesv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_rk_$address() {
        return chesv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = chesv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesv_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_rk_$descriptor() {
        return zhesv_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_rk_$handle() {
        return zhesv_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_rk_$address() {
        return zhesv_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_rk_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_rk_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x12) {
        var mh$ = zhesv_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_rk_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, work, lwork, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chesv_rook_$descriptor() {
        return chesv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chesv_rook_$handle() {
        return chesv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chesv_rook_$address() {
        return chesv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chesv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chesv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesv_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesv_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhesv_rook_$descriptor() {
        return zhesv_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhesv_rook_$handle() {
        return zhesv_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhesv_rook_$address() {
        return zhesv_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesv_rook_(const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhesv_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhesv_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesv_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chesvx_$descriptor() {
        return chesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chesvx_$handle() {
        return chesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chesvx_$address() {
        return chesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chesvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = chesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhesvx_$descriptor() {
        return zhesvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhesvx_$handle() {
        return zhesvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhesvx_$address() {
        return zhesvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhesvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21) {
        var mh$ = zhesvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesvx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, lwork, rwork, info, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chesvxx_$descriptor() {
        return chesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chesvxx_$handle() {
        return chesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chesvxx_$address() {
        return chesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex float *A, const int *lda, _Complex float *AF, const int *ldaf, int *ipiv, char *equed, float *S, _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *rpvgrw, float *berr, const int *n_err_bnds, float *err_bnds_norm, float *err_bnds_comp, const int *nparams, float *params, _Complex float *work, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chesvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = chesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chesvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhesvxx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhesvxx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhesvxx_$descriptor() {
        return zhesvxx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhesvxx_$handle() {
        return zhesvxx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhesvxx_$address() {
        return zhesvxx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhesvxx_(const char *fact, const char *uplo, const int *n, const int *nrhs, _Complex double *A, const int *lda, _Complex double *AF, const int *ldaf, int *ipiv, char *equed, double *S, _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *rpvgrw, double *berr, const int *n_err_bnds, double *err_bnds_norm, double *err_bnds_comp, const int *nparams, double *params, _Complex double *work, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhesvxx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment AF, MemorySegment ldaf, MemorySegment ipiv, MemorySegment equed, MemorySegment S, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment rpvgrw, MemorySegment berr, MemorySegment n_err_bnds, MemorySegment err_bnds_norm, MemorySegment err_bnds_comp, MemorySegment nparams, MemorySegment params, MemorySegment work, MemorySegment rwork, MemorySegment info, long x26, long x27, long x28) {
        var mh$ = zhesvxx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhesvxx_", fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, A, lda, AF, ldaf, ipiv, equed, S, B, ldb, X, ldx, rcond, rpvgrw, berr, n_err_bnds, err_bnds_norm, err_bnds_comp, nparams, params, work, rwork, info, x26, x27, x28);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cheswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("cheswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor cheswapr_$descriptor() {
        return cheswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle cheswapr_$handle() {
        return cheswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment cheswapr_$address() {
        return cheswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void cheswapr_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void cheswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = cheswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cheswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zheswapr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zheswapr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static FunctionDescriptor zheswapr_$descriptor() {
        return zheswapr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MethodHandle zheswapr_$handle() {
        return zheswapr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static MemorySegment zheswapr_$address() {
        return zheswapr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zheswapr_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *i1, const int *i2, size_t)
     * }
     */
    public static void zheswapr_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment i1, MemorySegment i2, long x6) {
        var mh$ = zheswapr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zheswapr_", uplo, n, A, lda, i1, i2, x6);
            }
            mh$.invokeExact(uplo, n, A, lda, i1, i2, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrd_$descriptor() {
        return chetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrd_$handle() {
        return chetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrd_$address() {
        return chetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrd_(const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = chetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrd_$descriptor() {
        return zhetrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrd_$handle() {
        return zhetrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrd_$address() {
        return zhetrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrd_(const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrd_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment work, MemorySegment lwork, MemorySegment info, long x10) {
        var mh$ = zhetrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrd_", uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
            }
            mh$.invokeExact(uplo, n, A, lda, D, E, tau, work, lwork, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chetrd_2stage_$descriptor() {
        return chetrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chetrd_2stage_$handle() {
        return chetrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chetrd_2stage_$address() {
        return chetrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex float *A, const int *lda, float *D, float *E, _Complex float *tau, _Complex float *HOUS2, const int *lhous2, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void chetrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = chetrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrd_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrd_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhetrd_2stage_$descriptor() {
        return zhetrd_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhetrd_2stage_$handle() {
        return zhetrd_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhetrd_2stage_$address() {
        return zhetrd_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrd_2stage_(const char *vect, const char *uplo, const int *n, _Complex double *A, const int *lda, double *D, double *E, _Complex double *tau, _Complex double *HOUS2, const int *lhous2, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zhetrd_2stage_(MemorySegment vect, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment HOUS2, MemorySegment lhous2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhetrd_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrd_2stage_", vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(vect, uplo, n, A, lda, D, E, tau, HOUS2, lhous2, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_$descriptor() {
        return chetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_$handle() {
        return chetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_$address() {
        return chetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_$descriptor() {
        return zhetrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_$handle() {
        return zhetrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_$address() {
        return zhetrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_aa_$descriptor() {
        return chetrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_aa_$handle() {
        return chetrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_aa_$address() {
        return chetrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_aa_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrf_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_aa_$descriptor() {
        return zhetrf_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_aa_$handle() {
        return zhetrf_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_aa_$address() {
        return zhetrf_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_aa_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_aa_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_aa_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_aa_2stage_$descriptor() {
        return chetrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_aa_2stage_$handle() {
        return chetrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_aa_2stage_$address() {
        return chetrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_aa_2stage_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chetrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrf_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_aa_2stage_$descriptor() {
        return zhetrf_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_aa_2stage_$handle() {
        return zhetrf_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_aa_2stage_$address() {
        return zhetrf_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_aa_2stage_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, int *ipiv, int *ipiv2, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhetrf_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_aa_2stage_", uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, A, lda, TB, ltb, ipiv, ipiv2, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_rk_$descriptor() {
        return chetrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_rk_$handle() {
        return chetrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_rk_$address() {
        return chetrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_rk_(const char *uplo, const int *n, _Complex float *A, const int *lda, _Complex float *E, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = chetrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_rk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrf_rk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_rk_$descriptor() {
        return zhetrf_rk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_rk_$handle() {
        return zhetrf_rk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_rk_$address() {
        return zhetrf_rk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_rk_(const char *uplo, const int *n, _Complex double *A, const int *lda, _Complex double *E, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_rk_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zhetrf_rk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_rk_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrf_rook_$descriptor() {
        return chetrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrf_rook_$handle() {
        return chetrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrf_rook_$address() {
        return chetrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrf_rook_(const char *uplo, const int *n, _Complex float *A, const int *lda, int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrf_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrf_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrf_rook_$descriptor() {
        return zhetrf_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrf_rook_$handle() {
        return zhetrf_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrf_rook_$address() {
        return zhetrf_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrf_rook_(const char *uplo, const int *n, _Complex double *A, const int *lda, int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrf_rook_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetrf_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrf_rook_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri_$descriptor() {
        return chetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chetri_$handle() {
        return chetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chetri_$address() {
        return chetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chetri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = chetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri_$descriptor() {
        return zhetri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri_$handle() {
        return zhetri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri_$address() {
        return zhetri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhetri_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x7) {
        var mh$ = zhetri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri_", uplo, n, A, lda, ipiv, work, info, x7);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri2_$descriptor() {
        return chetri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetri2_$handle() {
        return chetri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetri2_$address() {
        return chetri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri2_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = chetri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetri2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri2_$descriptor() {
        return zhetri2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri2_$handle() {
        return zhetri2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri2_$address() {
        return zhetri2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri2_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetri2_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x8) {
        var mh$ = zhetri2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri2_", uplo, n, A, lda, ipiv, work, lwork, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, lwork, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri2x_$descriptor() {
        return chetri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle chetri2x_$handle() {
        return chetri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment chetri2x_$address() {
        return chetri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri2x_(const char *uplo, const int *n, _Complex float *A, const int *lda, const int *ipiv, _Complex float *work, const int *nb, int *info, size_t)
     * }
     */
    public static void chetri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = chetri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri2x_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetri2x_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri2x_$descriptor() {
        return zhetri2x_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri2x_$handle() {
        return zhetri2x_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri2x_$address() {
        return zhetri2x_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri2x_(const char *uplo, const int *n, _Complex double *A, const int *lda, const int *ipiv, _Complex double *work, const int *nb, int *info, size_t)
     * }
     */
    public static void zhetri2x_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment work, MemorySegment nb, MemorySegment info, long x8) {
        var mh$ = zhetri2x_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri2x_", uplo, n, A, lda, ipiv, work, nb, info, x8);
            }
            mh$.invokeExact(uplo, n, A, lda, ipiv, work, nb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetri_3_$descriptor() {
        return chetri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetri_3_$handle() {
        return chetri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetri_3_$address() {
        return chetri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetri_3_(const char *uplo, const int *n, _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = chetri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetri_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetri_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetri_3_$descriptor() {
        return zhetri_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetri_3_$handle() {
        return zhetri_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetri_3_$address() {
        return zhetri_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetri_3_(const char *uplo, const int *n, _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetri_3_(MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment work, MemorySegment lwork, MemorySegment info, long x9) {
        var mh$ = zhetri_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetri_3_", uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
            }
            mh$.invokeExact(uplo, n, A, lda, E, ipiv, work, lwork, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_$descriptor() {
        return chetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_$handle() {
        return chetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_$address() {
        return chetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = chetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_$descriptor() {
        return zhetrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_$handle() {
        return zhetrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_$address() {
        return zhetrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zhetrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs2_$descriptor() {
        return chetrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs2_$handle() {
        return chetrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs2_$address() {
        return chetrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chetrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = chetrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs2_$descriptor() {
        return zhetrs2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs2_$handle() {
        return zhetrs2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs2_$address() {
        return zhetrs2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs2_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhetrs2_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment info, long x10) {
        var mh$ = zhetrs2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs2_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_3_$descriptor() {
        return chetrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_3_$handle() {
        return chetrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_3_$address() {
        return chetrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const _Complex float *E, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = chetrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_3_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs_3_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_3_$descriptor() {
        return zhetrs_3_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_3_$handle() {
        return zhetrs_3_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_3_$address() {
        return zhetrs_3_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_3_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const _Complex double *E, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_3_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment E, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x10) {
        var mh$ = zhetrs_3_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_3_", uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, E, ipiv, B, ldb, info, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_aa_$descriptor() {
        return chetrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_aa_$handle() {
        return chetrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_aa_$address() {
        return chetrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, _Complex float *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void chetrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = chetrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_aa_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs_aa_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_aa_$descriptor() {
        return zhetrs_aa_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_aa_$handle() {
        return zhetrs_aa_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_aa_$address() {
        return zhetrs_aa_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_aa_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, _Complex double *work, const int *lwork, int *info, size_t)
     * }
     */
    public static void zhetrs_aa_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment work, MemorySegment lwork, MemorySegment info, long x11) {
        var mh$ = zhetrs_aa_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_aa_", uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, work, lwork, info, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_aa_2stage_$descriptor() {
        return chetrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_aa_2stage_$handle() {
        return chetrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_aa_2stage_$address() {
        return chetrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, _Complex float *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = chetrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_aa_2stage_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs_aa_2stage_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_aa_2stage_$descriptor() {
        return zhetrs_aa_2stage_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_aa_2stage_$handle() {
        return zhetrs_aa_2stage_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_aa_2stage_$address() {
        return zhetrs_aa_2stage_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_aa_2stage_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, _Complex double *TB, const int *ltb, const int *ipiv, const int *ipiv2, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_aa_2stage_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment TB, MemorySegment ltb, MemorySegment ipiv, MemorySegment ipiv2, MemorySegment B, MemorySegment ldb, MemorySegment info, long x12) {
        var mh$ = zhetrs_aa_2stage_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_aa_2stage_", uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, TB, ltb, ipiv, ipiv2, B, ldb, info, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chetrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chetrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chetrs_rook_$descriptor() {
        return chetrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chetrs_rook_$handle() {
        return chetrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chetrs_rook_$address() {
        return chetrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex float *A, const int *lda, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chetrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = chetrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chetrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhetrs_rook_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhetrs_rook_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhetrs_rook_$descriptor() {
        return zhetrs_rook_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhetrs_rook_$handle() {
        return zhetrs_rook_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhetrs_rook_$address() {
        return zhetrs_rook_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhetrs_rook_(const char *uplo, const int *n, const int *nrhs, const _Complex double *A, const int *lda, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhetrs_rook_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment A, MemorySegment lda, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x9) {
        var mh$ = zhetrs_rook_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhetrs_rook_", uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
            }
            mh$.invokeExact(uplo, n, nrhs, A, lda, ipiv, B, ldb, info, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chfrk_$descriptor() {
        return chfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chfrk_$handle() {
        return chfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chfrk_$address() {
        return chfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const float *alpha, const _Complex float *A, const int *lda, const float *beta, _Complex float *C, size_t, size_t, size_t)
     * }
     */
    public static void chfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = chfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhfrk_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhfrk_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhfrk_$descriptor() {
        return zhfrk_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhfrk_$handle() {
        return zhfrk_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhfrk_$address() {
        return zhfrk_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhfrk_(const char *transr, const char *uplo, const char *trans, const int *n, const int *k, const double *alpha, const _Complex double *A, const int *lda, const double *beta, _Complex double *C, size_t, size_t, size_t)
     * }
     */
    public static void zhfrk_(MemorySegment transr, MemorySegment uplo, MemorySegment trans, MemorySegment n, MemorySegment k, MemorySegment alpha, MemorySegment A, MemorySegment lda, MemorySegment beta, MemorySegment C, long x10, long x11, long x12) {
        var mh$ = zhfrk_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhfrk_", transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
            }
            mh$.invokeExact(transr, uplo, trans, n, k, alpha, A, lda, beta, C, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chgeqz_$descriptor() {
        return chgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chgeqz_$handle() {
        return chgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chgeqz_$address() {
        return chgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *T, const int *ldt, _Complex float *alpha, _Complex float *beta, _Complex float *Q, const int *ldq, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = chgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhgeqz_$descriptor() {
        return dhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dhgeqz_$handle() {
        return dhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dhgeqz_$address() {
        return dhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *T, const int *ldt, double *alphar, double *alphai, double *beta, double *Q, const int *ldq, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dhgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = dhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("shgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shgeqz_$descriptor() {
        return shgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle shgeqz_$handle() {
        return shgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment shgeqz_$address() {
        return shgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *T, const int *ldt, float *alphar, float *alphai, float *beta, float *Q, const int *ldq, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void shgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alphar, MemorySegment alphai, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = shgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alphar, alphai, beta, Q, ldq, Z, ldz, work, lwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhgeqz_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhgeqz_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhgeqz_$descriptor() {
        return zhgeqz_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhgeqz_$handle() {
        return zhgeqz_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhgeqz_$address() {
        return zhgeqz_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhgeqz_(const char *job, const char *compq, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *T, const int *ldt, _Complex double *alpha, _Complex double *beta, _Complex double *Q, const int *ldq, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhgeqz_(MemorySegment job, MemorySegment compq, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment T, MemorySegment ldt, MemorySegment alpha, MemorySegment beta, MemorySegment Q, MemorySegment ldq, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment info, long x20, long x21, long x22) {
        var mh$ = zhgeqz_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhgeqz_", job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
            }
            mh$.invokeExact(job, compq, compz, n, ilo, ihi, H, ldh, T, ldt, alpha, beta, Q, ldq, Z, ldz, work, lwork, rwork, info, x20, x21, x22);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpcon_$descriptor() {
        return chpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chpcon_$handle() {
        return chpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chpcon_$address() {
        return chpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpcon_(const char *uplo, const int *n, const _Complex float *AP, const int *ipiv, const float *anorm, float *rcond, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chpcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = chpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpcon_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpcon_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpcon_$descriptor() {
        return zhpcon_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhpcon_$handle() {
        return zhpcon_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhpcon_$address() {
        return zhpcon_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpcon_(const char *uplo, const int *n, const _Complex double *AP, const int *ipiv, const double *anorm, double *rcond, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhpcon_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment anorm, MemorySegment rcond, MemorySegment work, MemorySegment info, long x8) {
        var mh$ = zhpcon_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpcon_", uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, anorm, rcond, work, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpev_$descriptor() {
        return chpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpev_$handle() {
        return chpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpev_$address() {
        return chpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpev_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = chpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpev_", jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpev_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpev_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpev_$descriptor() {
        return zhpev_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpev_$handle() {
        return zhpev_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpev_$address() {
        return zhpev_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpev_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpev_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x10, long x11) {
        var mh$ = zhpev_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpev_", jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, rwork, info, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpevd_$descriptor() {
        return chpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpevd_$handle() {
        return chpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpevd_$address() {
        return chpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpevd_(const char *jobz, const char *uplo, const int *n, _Complex float *AP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chpevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = chpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpevd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpevd_$descriptor() {
        return zhpevd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpevd_$handle() {
        return zhpevd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpevd_$address() {
        return zhpevd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpevd_(const char *jobz, const char *uplo, const int *n, _Complex double *AP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpevd_(MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x14, long x15) {
        var mh$ = zhpevd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevd_", jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
            }
            mh$.invokeExact(jobz, uplo, n, AP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpevx_$descriptor() {
        return chpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chpevx_$handle() {
        return chpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chpevx_$address() {
        return chpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chpevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = chpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpevx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpevx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpevx_$descriptor() {
        return zhpevx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhpevx_$handle() {
        return zhpevx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhpevx_$address() {
        return zhpevx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpevx_(const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhpevx_(MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = zhpevx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpevx_", jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
            }
            mh$.invokeExact(jobz, range, uplo, n, AP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpgst_$descriptor() {
        return chpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static MethodHandle chpgst_$handle() {
        return chpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static MemorySegment chpgst_$address() {
        return chpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgst_(const int *itype, const char *uplo, const int *n, _Complex float *AP, const _Complex float *BP, int *info, size_t)
     * }
     */
    public static void chpgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = chpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpgst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpgst_$descriptor() {
        return zhpgst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static MethodHandle zhpgst_$handle() {
        return zhpgst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static MemorySegment zhpgst_$address() {
        return zhpgst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgst_(const int *itype, const char *uplo, const int *n, _Complex double *AP, const _Complex double *BP, int *info, size_t)
     * }
     */
    public static void zhpgst_(MemorySegment itype, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment info, long x6) {
        var mh$ = zhpgst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgst_", itype, uplo, n, AP, BP, info, x6);
            }
            mh$.invokeExact(itype, uplo, n, AP, BP, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgv_$descriptor() {
        return chpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpgv_$handle() {
        return chpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpgv_$address() {
        return chpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = chpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgv_$descriptor() {
        return zhpgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgv_$handle() {
        return zhpgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgv_$address() {
        return zhpgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgv_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpgv_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment info, long x12, long x13) {
        var mh$ = zhpgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgv_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, rwork, info, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgvd_$descriptor() {
        return chpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpgvd_$handle() {
        return chpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpgvd_$address() {
        return chpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, float *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void chpgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = chpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpgvd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgvd_$descriptor() {
        return zhpgvd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgvd_$handle() {
        return zhpgvd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgvd_$address() {
        return zhpgvd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgvd_(const int *itype, const char *jobz, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, double *rwork, const int *lrwork, int *iwork, const int *liwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpgvd_(MemorySegment itype, MemorySegment jobz, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment rwork, MemorySegment lrwork, MemorySegment iwork, MemorySegment liwork, MemorySegment info, long x16, long x17) {
        var mh$ = zhpgvd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvd_", itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
            }
            mh$.invokeExact(itype, jobz, uplo, n, AP, BP, W, Z, ldz, work, lwork, rwork, lrwork, iwork, liwork, info, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpgvx_$descriptor() {
        return chpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chpgvx_$handle() {
        return chpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chpgvx_$address() {
        return chpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex float *AP, _Complex float *BP, const float *vl, const float *vu, const int *il, const int *iu, const float *abstol, int *m, float *W, _Complex float *Z, const int *ldz, _Complex float *work, float *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chpgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = chpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpgvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpgvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpgvx_$descriptor() {
        return zhpgvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhpgvx_$handle() {
        return zhpgvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhpgvx_$address() {
        return zhpgvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpgvx_(const int *itype, const char *jobz, const char *range, const char *uplo, const int *n, _Complex double *AP, _Complex double *BP, const double *vl, const double *vu, const int *il, const int *iu, const double *abstol, int *m, double *W, _Complex double *Z, const int *ldz, _Complex double *work, double *rwork, int *iwork, int *IFAIL, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhpgvx_(MemorySegment itype, MemorySegment jobz, MemorySegment range, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment BP, MemorySegment vl, MemorySegment vu, MemorySegment il, MemorySegment iu, MemorySegment abstol, MemorySegment m, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment rwork, MemorySegment iwork, MemorySegment IFAIL, MemorySegment info, long x21, long x22, long x23) {
        var mh$ = zhpgvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpgvx_", itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
            }
            mh$.invokeExact(itype, jobz, range, uplo, n, AP, BP, vl, vu, il, iu, abstol, m, W, Z, ldz, work, rwork, iwork, IFAIL, info, x21, x22, x23);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chprfs_$descriptor() {
        return chprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle chprfs_$handle() {
        return chprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment chprfs_$address() {
        return chprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const _Complex float *AFP, const int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t)
     * }
     */
    public static void chprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = chprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhprfs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhprfs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhprfs_$descriptor() {
        return zhprfs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MethodHandle zhprfs_$handle() {
        return zhprfs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static MemorySegment zhprfs_$address() {
        return zhprfs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhprfs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const _Complex double *AFP, const int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t)
     * }
     */
    public static void zhprfs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x15) {
        var mh$ = zhprfs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhprfs_", uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, ferr, berr, work, rwork, info, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chpsv_$descriptor() {
        return chpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chpsv_$handle() {
        return chpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chpsv_$address() {
        return chpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpsv_(const char *uplo, const int *n, const int *nrhs, _Complex float *AP, int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chpsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpsv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhpsv_$descriptor() {
        return zhpsv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhpsv_$handle() {
        return zhpsv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhpsv_$address() {
        return zhpsv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpsv_(const char *uplo, const int *n, const int *nrhs, _Complex double *AP, int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhpsv_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhpsv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsv_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chpsvx_$descriptor() {
        return chpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chpsvx_$handle() {
        return chpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chpsvx_$address() {
        return chpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, _Complex float *AFP, int *ipiv, const _Complex float *B, const int *ldb, _Complex float *X, const int *ldx, float *rcond, float *ferr, float *berr, _Complex float *work, float *rwork, int *info, size_t, size_t)
     * }
     */
    public static void chpsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = chpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chpsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhpsvx_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhpsvx_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhpsvx_$descriptor() {
        return zhpsvx_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhpsvx_$handle() {
        return zhpsvx_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhpsvx_$address() {
        return zhpsvx_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhpsvx_(const char *fact, const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, _Complex double *AFP, int *ipiv, const _Complex double *B, const int *ldb, _Complex double *X, const int *ldx, double *rcond, double *ferr, double *berr, _Complex double *work, double *rwork, int *info, size_t, size_t)
     * }
     */
    public static void zhpsvx_(MemorySegment fact, MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment AFP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment X, MemorySegment ldx, MemorySegment rcond, MemorySegment ferr, MemorySegment berr, MemorySegment work, MemorySegment rwork, MemorySegment info, long x17, long x18) {
        var mh$ = zhpsvx_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhpsvx_", fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
            }
            mh$.invokeExact(fact, uplo, n, nrhs, AP, AFP, ipiv, B, ldb, X, ldx, rcond, ferr, berr, work, rwork, info, x17, x18);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrd_$descriptor() {
        return chptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static MethodHandle chptrd_$handle() {
        return chptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static MemorySegment chptrd_$address() {
        return chptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrd_(const char *uplo, const int *n, _Complex float *AP, float *D, float *E, _Complex float *tau, int *info, size_t)
     * }
     */
    public static void chptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = chptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrd_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhptrd_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrd_$descriptor() {
        return zhptrd_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrd_$handle() {
        return zhptrd_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrd_$address() {
        return zhptrd_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrd_(const char *uplo, const int *n, _Complex double *AP, double *D, double *E, _Complex double *tau, int *info, size_t)
     * }
     */
    public static void zhptrd_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment D, MemorySegment E, MemorySegment tau, MemorySegment info, long x7) {
        var mh$ = zhptrd_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrd_", uplo, n, AP, D, E, tau, info, x7);
            }
            mh$.invokeExact(uplo, n, AP, D, E, tau, info, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrf_$descriptor() {
        return chptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle chptrf_$handle() {
        return chptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment chptrf_$address() {
        return chptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrf_(const char *uplo, const int *n, _Complex float *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void chptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = chptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrf_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhptrf_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrf_$descriptor() {
        return zhptrf_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrf_$handle() {
        return zhptrf_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrf_$address() {
        return zhptrf_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrf_(const char *uplo, const int *n, _Complex double *AP, int *ipiv, int *info, size_t)
     * }
     */
    public static void zhptrf_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment info, long x5) {
        var mh$ = zhptrf_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrf_", uplo, n, AP, ipiv, info, x5);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, info, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptri_$descriptor() {
        return chptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MethodHandle chptri_$handle() {
        return chptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static MemorySegment chptri_$address() {
        return chptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptri_(const char *uplo, const int *n, _Complex float *AP, const int *ipiv, _Complex float *work, int *info, size_t)
     * }
     */
    public static void chptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = chptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptri_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhptri_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptri_$descriptor() {
        return zhptri_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MethodHandle zhptri_$handle() {
        return zhptri_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static MemorySegment zhptri_$address() {
        return zhptri_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptri_(const char *uplo, const int *n, _Complex double *AP, const int *ipiv, _Complex double *work, int *info, size_t)
     * }
     */
    public static void zhptri_(MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment ipiv, MemorySegment work, MemorySegment info, long x6) {
        var mh$ = zhptri_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptri_", uplo, n, AP, ipiv, work, info, x6);
            }
            mh$.invokeExact(uplo, n, AP, ipiv, work, info, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor chptrs_$descriptor() {
        return chptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle chptrs_$handle() {
        return chptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment chptrs_$address() {
        return chptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex float *AP, const int *ipiv, _Complex float *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void chptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = chptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhptrs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhptrs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static FunctionDescriptor zhptrs_$descriptor() {
        return zhptrs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MethodHandle zhptrs_$handle() {
        return zhptrs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static MemorySegment zhptrs_$address() {
        return zhptrs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhptrs_(const char *uplo, const int *n, const int *nrhs, const _Complex double *AP, const int *ipiv, _Complex double *B, const int *ldb, int *info, size_t)
     * }
     */
    public static void zhptrs_(MemorySegment uplo, MemorySegment n, MemorySegment nrhs, MemorySegment AP, MemorySegment ipiv, MemorySegment B, MemorySegment ldb, MemorySegment info, long x8) {
        var mh$ = zhptrs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhptrs_", uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
            }
            mh$.invokeExact(uplo, n, nrhs, AP, ipiv, B, ldb, info, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chsein_$descriptor() {
        return chsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle chsein_$handle() {
        return chsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment chsein_$address() {
        return chsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex float *H, const int *ldh, _Complex float *W, _Complex float *VL, const int *ldvl, _Complex float *VR, const int *ldvr, const int *mm, int *m, _Complex float *work, float *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void chsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = chsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chsein_", side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhsein_$descriptor() {
        return dhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle dhsein_$handle() {
        return dhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment dhsein_$address() {
        return dhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const double *H, const int *ldh, double *WR, const double *WI, double *VL, const int *ldvl, double *VR, const int *ldvr, const int *mm, int *m, double *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void dhsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = dhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhsein_", side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("shsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shsein_$descriptor() {
        return shsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle shsein_$handle() {
        return shsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment shsein_$address() {
        return shsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shsein_(const char *side, const char *eigsrc, const char *initv, int *select, const int *n, const float *H, const int *ldh, float *WR, const float *WI, float *VL, const int *ldvl, float *VR, const int *ldvr, const int *mm, int *m, float *work, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void shsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = shsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shsein_", side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, WR, WI, VL, ldvl, VR, ldvr, mm, m, work, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhsein_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhsein_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhsein_$descriptor() {
        return zhsein_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MethodHandle zhsein_$handle() {
        return zhsein_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static MemorySegment zhsein_$address() {
        return zhsein_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhsein_(const char *side, const char *eigsrc, const char *initv, const int *select, const int *n, const _Complex double *H, const int *ldh, _Complex double *W, _Complex double *VL, const int *ldvl, _Complex double *VR, const int *ldvr, const int *mm, int *m, _Complex double *work, double *rwork, int *IFAILL, int *IFAILR, int *info, size_t, size_t, size_t)
     * }
     */
    public static void zhsein_(MemorySegment side, MemorySegment eigsrc, MemorySegment initv, MemorySegment select, MemorySegment n, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment VL, MemorySegment ldvl, MemorySegment VR, MemorySegment ldvr, MemorySegment mm, MemorySegment m, MemorySegment work, MemorySegment rwork, MemorySegment IFAILL, MemorySegment IFAILR, MemorySegment info, long x19, long x20, long x21) {
        var mh$ = zhsein_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhsein_", side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
            }
            mh$.invokeExact(side, eigsrc, initv, select, n, H, ldh, W, VL, ldvl, VR, ldvr, mm, m, work, rwork, IFAILL, IFAILR, info, x19, x20, x21);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("chseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor chseqr_$descriptor() {
        return chseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle chseqr_$handle() {
        return chseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment chseqr_$address() {
        return chseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void chseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex float *H, const int *ldh, _Complex float *W, _Complex float *Z, const int *ldz, _Complex float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void chseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = chseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chseqr_", job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dhseqr_$descriptor() {
        return dhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle dhseqr_$handle() {
        return dhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment dhseqr_$address() {
        return dhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, double *H, const int *ldh, double *WR, double *WI, double *Z, const int *ldz, double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void dhseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = dhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dhseqr_", job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("shseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor shseqr_$descriptor() {
        return shseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle shseqr_$handle() {
        return shseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment shseqr_$address() {
        return shseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void shseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, float *H, const int *ldh, float *WR, float *WI, float *Z, const int *ldz, float *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void shseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment WR, MemorySegment WI, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x14, long x15) {
        var mh$ = shseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shseqr_", job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, WR, WI, Z, ldz, work, lwork, info, x14, x15);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zhseqr_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zhseqr_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zhseqr_$descriptor() {
        return zhseqr_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MethodHandle zhseqr_$handle() {
        return zhseqr_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static MemorySegment zhseqr_$address() {
        return zhseqr_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zhseqr_(const char *job, const char *compz, const int *n, const int *ilo, const int *ihi, _Complex double *H, const int *ldh, _Complex double *W, _Complex double *Z, const int *ldz, _Complex double *work, const int *lwork, int *info, size_t, size_t)
     * }
     */
    public static void zhseqr_(MemorySegment job, MemorySegment compz, MemorySegment n, MemorySegment ilo, MemorySegment ihi, MemorySegment H, MemorySegment ldh, MemorySegment W, MemorySegment Z, MemorySegment ldz, MemorySegment work, MemorySegment lwork, MemorySegment info, long x13, long x14) {
        var mh$ = zhseqr_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zhseqr_", job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
            }
            mh$.invokeExact(job, compz, n, ilo, ihi, H, ldh, W, Z, ldz, work, lwork, info, x13, x14);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static FunctionDescriptor clacgv_$descriptor() {
        return clacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static MethodHandle clacgv_$handle() {
        return clacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static MemorySegment clacgv_$address() {
        return clacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacgv_(const int *n, _Complex float *X, const int *incx)
     * }
     */
    public static void clacgv_(MemorySegment n, MemorySegment X, MemorySegment incx) {
        var mh$ = clacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacgv_", n, X, incx);
            }
            mh$.invokeExact(n, X, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacgv_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlacgv_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static FunctionDescriptor zlacgv_$descriptor() {
        return zlacgv_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static MethodHandle zlacgv_$handle() {
        return zlacgv_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static MemorySegment zlacgv_$address() {
        return zlacgv_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacgv_(const int *n, _Complex double *X, const int *incx)
     * }
     */
    public static void zlacgv_(MemorySegment n, MemorySegment X, MemorySegment incx) {
        var mh$ = zlacgv_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacgv_", n, X, incx);
            }
            mh$.invokeExact(n, X, incx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor clacn2_$descriptor() {
        return clacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle clacn2_$handle() {
        return clacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment clacn2_$address() {
        return clacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacn2_(const int *n, _Complex float *V, _Complex float *X, float *est, int *kase, int *ISAVE)
     * }
     */
    public static void clacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = clacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacn2_", n, V, X, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor dlacn2_$descriptor() {
        return dlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle dlacn2_$handle() {
        return dlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment dlacn2_$address() {
        return dlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlacn2_(const int *n, double *V, double *X, int *ISGN, double *est, int *kase, int *ISAVE)
     * }
     */
    public static void dlacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment ISGN, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = dlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacn2_", n, V, X, ISGN, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, ISGN, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor slacn2_$descriptor() {
        return slacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle slacn2_$handle() {
        return slacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment slacn2_$address() {
        return slacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slacn2_(const int *n, float *V, float *X, int *ISGN, float *est, int *kase, int *ISAVE)
     * }
     */
    public static void slacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment ISGN, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = slacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacn2_", n, V, X, ISGN, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, ISGN, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacn2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlacn2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static FunctionDescriptor zlacn2_$descriptor() {
        return zlacn2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MethodHandle zlacn2_$handle() {
        return zlacn2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static MemorySegment zlacn2_$address() {
        return zlacn2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacn2_(const int *n, _Complex double *V, _Complex double *X, double *est, int *kase, int *ISAVE)
     * }
     */
    public static void zlacn2_(MemorySegment n, MemorySegment V, MemorySegment X, MemorySegment est, MemorySegment kase, MemorySegment ISAVE) {
        var mh$ = zlacn2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacn2_", n, V, X, est, kase, ISAVE);
            }
            mh$.invokeExact(n, V, X, est, kase, ISAVE);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor clacp2_$descriptor() {
        return clacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle clacp2_$handle() {
        return clacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment clacp2_$address() {
        return clacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacp2_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static void clacp2_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = clacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacp2_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacp2_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlacp2_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor zlacp2_$descriptor() {
        return zlacp2_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle zlacp2_$handle() {
        return zlacp2_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment zlacp2_$address() {
        return zlacp2_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacp2_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static void zlacp2_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = zlacp2_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacp2_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor clacpy_$descriptor() {
        return clacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle clacpy_$handle() {
        return clacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment clacpy_$address() {
        return clacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacpy_(const char *uplo, const int *m, const int *n, const _Complex float *A, const int *lda, _Complex float *B, const int *ldb, size_t)
     * }
     */
    public static void clacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = clacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor dlacpy_$descriptor() {
        return dlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle dlacpy_$handle() {
        return dlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment dlacpy_$address() {
        return dlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlacpy_(const char *uplo, const int *m, const int *n, const double *A, const int *lda, double *B, const int *ldb, size_t)
     * }
     */
    public static void dlacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = dlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor slacpy_$descriptor() {
        return slacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle slacpy_$handle() {
        return slacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment slacpy_$address() {
        return slacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slacpy_(const char *uplo, const int *m, const int *n, const float *A, const int *lda, float *B, const int *ldb, size_t)
     * }
     */
    public static void slacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = slacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacpy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlacpy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static FunctionDescriptor zlacpy_$descriptor() {
        return zlacpy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MethodHandle zlacpy_$handle() {
        return zlacpy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static MemorySegment zlacpy_$address() {
        return zlacpy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacpy_(const char *uplo, const int *m, const int *n, const _Complex double *A, const int *lda, _Complex double *B, const int *ldb, size_t)
     * }
     */
    public static void zlacpy_(MemorySegment uplo, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, long x7) {
        var mh$ = zlacpy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacpy_", uplo, m, n, A, lda, B, ldb, x7);
            }
            mh$.invokeExact(uplo, m, n, A, lda, B, ldb, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static FunctionDescriptor clacrm_$descriptor() {
        return clacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MethodHandle clacrm_$handle() {
        return clacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static MemorySegment clacrm_$address() {
        return clacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clacrm_(const int *m, const int *n, const _Complex float *A, const int *lda, const float *B, const int *ldb, _Complex float *C, const int *ldc, float *rwork)
     * }
     */
    public static void clacrm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = clacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clacrm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlacrm_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlacrm_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static FunctionDescriptor zlacrm_$descriptor() {
        return zlacrm_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MethodHandle zlacrm_$handle() {
        return zlacrm_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static MemorySegment zlacrm_$address() {
        return zlacrm_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlacrm_(const int *m, const int *n, const _Complex double *A, const int *lda, const double *B, const int *ldb, _Complex double *C, const int *ldc, double *rwork)
     * }
     */
    public static void zlacrm_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment B, MemorySegment ldb, MemorySegment C, MemorySegment ldc, MemorySegment rwork) {
        var mh$ = zlacrm_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlacrm_", m, n, A, lda, B, ldb, C, ldc, rwork);
            }
            mh$.invokeExact(m, n, A, lda, B, ldb, C, ldc, rwork);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlag2c_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlag2c_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static FunctionDescriptor zlag2c_$descriptor() {
        return zlag2c_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static MethodHandle zlag2c_$handle() {
        return zlag2c_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static MemorySegment zlag2c_$address() {
        return zlag2c_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlag2c_(const int *m, const int *n, const _Complex double *A, const int *lda, _Complex float *SA, const int *ldsa, int *info)
     * }
     */
    public static void zlag2c_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SA, MemorySegment ldsa, MemorySegment info) {
        var mh$ = zlag2c_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlag2c_", m, n, A, lda, SA, ldsa, info);
            }
            mh$.invokeExact(m, n, A, lda, SA, ldsa, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slag2d_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slag2d_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static FunctionDescriptor slag2d_$descriptor() {
        return slag2d_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static MethodHandle slag2d_$handle() {
        return slag2d_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static MemorySegment slag2d_$address() {
        return slag2d_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slag2d_(const int *m, const int *n, const float *SA, const int *ldsa, double *A, const int *lda, int *info)
     * }
     */
    public static void slag2d_(MemorySegment m, MemorySegment n, MemorySegment SA, MemorySegment ldsa, MemorySegment A, MemorySegment lda, MemorySegment info) {
        var mh$ = slag2d_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slag2d_", m, n, SA, ldsa, A, lda, info);
            }
            mh$.invokeExact(m, n, SA, ldsa, A, lda, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlag2s_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlag2s_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static FunctionDescriptor dlag2s_$descriptor() {
        return dlag2s_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static MethodHandle dlag2s_$handle() {
        return dlag2s_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static MemorySegment dlag2s_$address() {
        return dlag2s_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlag2s_(const int *m, const int *n, const double *A, const int *lda, float *SA, const int *ldsa, int *info)
     * }
     */
    public static void dlag2s_(MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment SA, MemorySegment ldsa, MemorySegment info) {
        var mh$ = dlag2s_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlag2s_", m, n, A, lda, SA, ldsa, info);
            }
            mh$.invokeExact(m, n, A, lda, SA, ldsa, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clag2z_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clag2z_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static FunctionDescriptor clag2z_$descriptor() {
        return clag2z_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static MethodHandle clag2z_$handle() {
        return clag2z_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static MemorySegment clag2z_$address() {
        return clag2z_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clag2z_(const int *m, const int *n, const _Complex float *SA, const int *ldsa, _Complex double *A, const int *lda, int *info)
     * }
     */
    public static void clag2z_(MemorySegment m, MemorySegment n, MemorySegment SA, MemorySegment ldsa, MemorySegment A, MemorySegment lda, MemorySegment info) {
        var mh$ = clag2z_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clag2z_", m, n, SA, ldsa, A, lda, info);
            }
            mh$.invokeExact(m, n, SA, ldsa, A, lda, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor clagge_$descriptor() {
        return clagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle clagge_$handle() {
        return clagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment clagge_$address() {
        return clagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void clagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = clagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dlagge_$descriptor() {
        return dlagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MethodHandle dlagge_$handle() {
        return dlagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MemorySegment dlagge_$address() {
        return dlagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static void dlagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = dlagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static FunctionDescriptor slagge_$descriptor() {
        return slagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MethodHandle slagge_$handle() {
        return slagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MemorySegment slagge_$address() {
        return slagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slagge_(const int *m, const int *n, const int *kl, const int *ku, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static void slagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = slagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlagge_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlagge_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlagge_$descriptor() {
        return zlagge_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlagge_$handle() {
        return zlagge_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlagge_$address() {
        return zlagge_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlagge_(const int *m, const int *n, const int *kl, const int *ku, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlagge_(MemorySegment m, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlagge_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlagge_", m, n, kl, ku, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(m, n, kl, ku, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class claghe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("claghe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor claghe_$descriptor() {
        return claghe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle claghe_$handle() {
        return claghe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment claghe_$address() {
        return claghe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void claghe_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void claghe_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = claghe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("claghe_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlaghe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlaghe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlaghe_$descriptor() {
        return zlaghe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlaghe_$handle() {
        return zlaghe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlaghe_$address() {
        return zlaghe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlaghe_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlaghe_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlaghe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlaghe_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static FunctionDescriptor clagsy_$descriptor() {
        return clagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MethodHandle clagsy_$handle() {
        return clagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static MemorySegment clagsy_$address() {
        return clagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clagsy_(const int *n, const int *k, const float *D, _Complex float *A, const int *lda, int *iseed, _Complex float *work, int *info)
     * }
     */
    public static void clagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = clagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static FunctionDescriptor dlagsy_$descriptor() {
        return dlagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MethodHandle dlagsy_$handle() {
        return dlagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static MemorySegment dlagsy_$address() {
        return dlagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void dlagsy_(const int *n, const int *k, const double *D, double *A, const int *lda, int *iseed, double *work, int *info)
     * }
     */
    public static void dlagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = dlagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static FunctionDescriptor slagsy_$descriptor() {
        return slagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MethodHandle slagsy_$handle() {
        return slagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static MemorySegment slagsy_$address() {
        return slagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void slagsy_(const int *n, const int *k, const float *D, float *A, const int *lda, int *iseed, float *work, int *info)
     * }
     */
    public static void slagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = slagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlagsy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlagsy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static FunctionDescriptor zlagsy_$descriptor() {
        return zlagsy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MethodHandle zlagsy_$handle() {
        return zlagsy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static MemorySegment zlagsy_$address() {
        return zlagsy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void zlagsy_(const int *n, const int *k, const double *D, _Complex double *A, const int *lda, int *iseed, _Complex double *work, int *info)
     * }
     */
    public static void zlagsy_(MemorySegment n, MemorySegment k, MemorySegment D, MemorySegment A, MemorySegment lda, MemorySegment iseed, MemorySegment work, MemorySegment info) {
        var mh$ = zlagsy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlagsy_", n, k, D, A, lda, iseed, work, info);
            }
            mh$.invokeExact(n, k, D, A, lda, iseed, work, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static FunctionDescriptor dlamch_$descriptor() {
        return dlamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static MethodHandle dlamch_$handle() {
        return dlamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static MemorySegment dlamch_$address() {
        return dlamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlamch_(const char *cmach, size_t)
     * }
     */
    public static double dlamch_(MemorySegment cmach, long x1) {
        var mh$ = dlamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlamch_", cmach, x1);
            }
            return (double)mh$.invokeExact(cmach, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slamch_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slamch_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static FunctionDescriptor slamch_$descriptor() {
        return slamch_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static MethodHandle slamch_$handle() {
        return slamch_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static MemorySegment slamch_$address() {
        return slamch_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slamch_(const char *cmach, size_t)
     * }
     */
    public static float slamch_(MemorySegment cmach, long x1) {
        var mh$ = slamch_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slamch_", cmach, x1);
            }
            return (float)mh$.invokeExact(cmach, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clangb_$descriptor() {
        return clangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MethodHandle clangb_$handle() {
        return clangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MemorySegment clangb_$address() {
        return clangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static float clangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = clangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (float)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlangb_$descriptor() {
        return dlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MethodHandle dlangb_$handle() {
        return dlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MemorySegment dlangb_$address() {
        return dlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlangb_(const char *norm, const int *n, const int *kl, const int *ku, const double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static double dlangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = dlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (double)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slangb_$descriptor() {
        return slangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MethodHandle slangb_$handle() {
        return slangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static MemorySegment slangb_$address() {
        return slangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slangb_(const char *norm, const int *n, const int *kl, const int *ku, const float *AB, const int *ldab, float *work, size_t)
     * }
     */
    public static float slangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = slangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (float)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlangb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlangb_$descriptor() {
        return zlangb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MethodHandle zlangb_$handle() {
        return zlangb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static MemorySegment zlangb_$address() {
        return zlangb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlangb_(const char *norm, const int *n, const int *kl, const int *ku, const _Complex double *AB, const int *ldab, double *work, size_t)
     * }
     */
    public static double zlangb_(MemorySegment norm, MemorySegment n, MemorySegment kl, MemorySegment ku, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7) {
        var mh$ = zlangb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangb_", norm, n, kl, ku, AB, ldab, work, x7);
            }
            return (double)mh$.invokeExact(norm, n, kl, ku, AB, ldab, work, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clange_$descriptor() {
        return clange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle clange_$handle() {
        return clange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment clange_$address() {
        return clange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clange_(const char *norm, const int *m, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float clange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = clange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clange_", norm, m, n, A, lda, work, x6);
            }
            return (float)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlange_$descriptor() {
        return dlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle dlange_$handle() {
        return dlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment dlange_$address() {
        return dlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlange_(const char *norm, const int *m, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double dlange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = dlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlange_", norm, m, n, A, lda, work, x6);
            }
            return (double)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slange_$descriptor() {
        return slange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle slange_$handle() {
        return slange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment slange_$address() {
        return slange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slange_(const char *norm, const int *m, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float slange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = slange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slange_", norm, m, n, A, lda, work, x6);
            }
            return (float)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlange_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlange_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlange_$descriptor() {
        return zlange_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle zlange_$handle() {
        return zlange_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment zlange_$address() {
        return zlange_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlange_(const char *norm, const int *m, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double zlange_(MemorySegment norm, MemorySegment m, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6) {
        var mh$ = zlange_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlange_", norm, m, n, A, lda, work, x6);
            }
            return (double)mh$.invokeExact(norm, m, n, A, lda, work, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static FunctionDescriptor clangt_$descriptor() {
        return clangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static MethodHandle clangt_$handle() {
        return clangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static MemorySegment clangt_$address() {
        return clangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clangt_(const char *norm, const int *n, const _Complex float *DL, const _Complex float *D, const _Complex float *DU, size_t)
     * }
     */
    public static float clangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = clangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clangt_", norm, n, DL, D, DU, x5);
            }
            return (float)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static FunctionDescriptor dlangt_$descriptor() {
        return dlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static MethodHandle dlangt_$handle() {
        return dlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static MemorySegment dlangt_$address() {
        return dlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlangt_(const char *norm, const int *n, const double *DL, const double *D, const double *DU, size_t)
     * }
     */
    public static double dlangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = dlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlangt_", norm, n, DL, D, DU, x5);
            }
            return (double)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static FunctionDescriptor slangt_$descriptor() {
        return slangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static MethodHandle slangt_$handle() {
        return slangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static MemorySegment slangt_$address() {
        return slangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slangt_(const char *norm, const int *n, const float *DL, const float *D, const float *DU, size_t)
     * }
     */
    public static float slangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = slangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slangt_", norm, n, DL, D, DU, x5);
            }
            return (float)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlangt_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlangt_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static FunctionDescriptor zlangt_$descriptor() {
        return zlangt_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static MethodHandle zlangt_$handle() {
        return zlangt_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static MemorySegment zlangt_$address() {
        return zlangt_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlangt_(const char *norm, const int *n, const _Complex double *DL, const _Complex double *D, const _Complex double *DU, size_t)
     * }
     */
    public static double zlangt_(MemorySegment norm, MemorySegment n, MemorySegment DL, MemorySegment D, MemorySegment DU, long x5) {
        var mh$ = zlangt_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlangt_", norm, n, DL, D, DU, x5);
            }
            return (double)mh$.invokeExact(norm, n, DL, D, DU, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhb_$descriptor() {
        return clanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhb_$handle() {
        return clanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhb_$address() {
        return clanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float clanhb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = clanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlanhb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhb_$descriptor() {
        return zlanhb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhb_$handle() {
        return zlanhb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhb_$address() {
        return zlanhb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double zlanhb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = zlanhb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhe_$descriptor() {
        return clanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhe_$handle() {
        return clanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhe_$address() {
        return clanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhe_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float clanhe_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = clanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhe_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhe_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlanhe_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhe_$descriptor() {
        return zlanhe_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhe_$handle() {
        return zlanhe_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhe_$address() {
        return zlanhe_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhe_(const char *norm, const char *uplo, const int *n, const _Complex double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double zlanhe_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = zlanhe_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhe_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clanhp_$descriptor() {
        return clanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clanhp_$handle() {
        return clanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clanhp_$address() {
        return clanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static float clanhp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = clanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlanhp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlanhp_$descriptor() {
        return zlanhp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlanhp_$handle() {
        return zlanhp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlanhp_$address() {
        return zlanhp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static double zlanhp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = zlanhp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor clanhs_$descriptor() {
        return clanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle clanhs_$handle() {
        return clanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment clanhs_$address() {
        return clanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanhs_(const char *norm, const int *n, const _Complex float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float clanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = clanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanhs_", norm, n, A, lda, work, x5);
            }
            return (float)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor dlanhs_$descriptor() {
        return dlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle dlanhs_$handle() {
        return dlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment dlanhs_$address() {
        return dlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlanhs_(const char *norm, const int *n, const double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double dlanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = dlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanhs_", norm, n, A, lda, work, x5);
            }
            return (double)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static FunctionDescriptor slanhs_$descriptor() {
        return slanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MethodHandle slanhs_$handle() {
        return slanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static MemorySegment slanhs_$address() {
        return slanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slanhs_(const char *norm, const int *n, const float *A, const int *lda, float *work, size_t)
     * }
     */
    public static float slanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = slanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanhs_", norm, n, A, lda, work, x5);
            }
            return (float)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanhs_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlanhs_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static FunctionDescriptor zlanhs_$descriptor() {
        return zlanhs_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MethodHandle zlanhs_$handle() {
        return zlanhs_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static MemorySegment zlanhs_$address() {
        return zlanhs_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanhs_(const char *norm, const int *n, const _Complex double *A, const int *lda, double *work, size_t)
     * }
     */
    public static double zlanhs_(MemorySegment norm, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x5) {
        var mh$ = zlanhs_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanhs_", norm, n, A, lda, work, x5);
            }
            return (double)mh$.invokeExact(norm, n, A, lda, work, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static FunctionDescriptor clanht_$descriptor() {
        return clanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static MethodHandle clanht_$handle() {
        return clanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static MemorySegment clanht_$address() {
        return clanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clanht_(const char *norm, const int *n, const float *D, const _Complex float *E, size_t)
     * }
     */
    public static float clanht_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = clanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clanht_", norm, n, D, E, x4);
            }
            return (float)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlanht_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlanht_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static FunctionDescriptor zlanht_$descriptor() {
        return zlanht_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static MethodHandle zlanht_$handle() {
        return zlanht_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static MemorySegment zlanht_$address() {
        return zlanht_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlanht_(const char *norm, const int *n, const double *D, const _Complex double *E, size_t)
     * }
     */
    public static double zlanht_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = zlanht_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlanht_", norm, n, D, E, x4);
            }
            return (double)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansb_$descriptor() {
        return clansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansb_$handle() {
        return clansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansb_$address() {
        return clansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float clansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = clansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansb_$descriptor() {
        return dlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansb_$handle() {
        return dlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansb_$address() {
        return dlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansb_(const char *norm, const char *uplo, const int *n, const int *k, const double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double dlansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = dlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansb_$descriptor() {
        return slansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansb_$handle() {
        return slansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansb_$address() {
        return slansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansb_(const char *norm, const char *uplo, const int *n, const int *k, const float *AB, const int *ldab, float *work, size_t, size_t)
     * }
     */
    public static float slansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = slansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (float)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansb_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlansb_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansb_$descriptor() {
        return zlansb_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansb_$handle() {
        return zlansb_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansb_$address() {
        return zlansb_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansb_(const char *norm, const char *uplo, const int *n, const int *k, const _Complex double *AB, const int *ldab, double *work, size_t, size_t)
     * }
     */
    public static double zlansb_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment k, MemorySegment AB, MemorySegment ldab, MemorySegment work, long x7, long x8) {
        var mh$ = zlansb_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansb_", norm, uplo, n, k, AB, ldab, work, x7, x8);
            }
            return (double)mh$.invokeExact(norm, uplo, n, k, AB, ldab, work, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansp_$descriptor() {
        return clansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansp_$handle() {
        return clansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansp_$address() {
        return clansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansp_(const char *norm, const char *uplo, const int *n, const _Complex float *AP, float *work, size_t, size_t)
     * }
     */
    public static float clansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = clansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansp_$descriptor() {
        return dlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansp_$handle() {
        return dlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansp_$address() {
        return dlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansp_(const char *norm, const char *uplo, const int *n, const double *AP, double *work, size_t, size_t)
     * }
     */
    public static double dlansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = dlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor slansp_$descriptor() {
        return slansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle slansp_$handle() {
        return slansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment slansp_$address() {
        return slansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slansp_(const char *norm, const char *uplo, const int *n, const float *AP, float *work, size_t, size_t)
     * }
     */
    public static float slansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = slansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (float)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class zlansp_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("zlansp_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor zlansp_$descriptor() {
        return zlansp_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle zlansp_$handle() {
        return zlansp_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment zlansp_$address() {
        return zlansp_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double zlansp_(const char *norm, const char *uplo, const int *n, const _Complex double *AP, double *work, size_t, size_t)
     * }
     */
    public static double zlansp_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment AP, MemorySegment work, long x5, long x6) {
        var mh$ = zlansp_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("zlansp_", norm, uplo, n, AP, work, x5, x6);
            }
            return (double)mh$.invokeExact(norm, uplo, n, AP, work, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static FunctionDescriptor dlanst_$descriptor() {
        return dlanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static MethodHandle dlanst_$handle() {
        return dlanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static MemorySegment dlanst_$address() {
        return dlanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlanst_(const char *norm, const int *n, const double *D, const double *E, size_t)
     * }
     */
    public static double dlanst_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = dlanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlanst_", norm, n, D, E, x4);
            }
            return (double)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class slanst_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("slanst_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static FunctionDescriptor slanst_$descriptor() {
        return slanst_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static MethodHandle slanst_$handle() {
        return slanst_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static MemorySegment slanst_$address() {
        return slanst_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return slanst_(const char *norm, const int *n, const float *D, const float *E, size_t)
     * }
     */
    public static float slanst_(MemorySegment norm, MemorySegment n, MemorySegment D, MemorySegment E, long x4) {
        var mh$ = slanst_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("slanst_", norm, n, D, E, x4);
            }
            return (float)mh$.invokeExact(norm, n, D, E, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_FLOAT,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("clansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor clansy_$descriptor() {
        return clansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MethodHandle clansy_$handle() {
        return clansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static MemorySegment clansy_$address() {
        return clansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lapack_float_return clansy_(const char *norm, const char *uplo, const int *n, const _Complex float *A, const int *lda, float *work, size_t, size_t)
     * }
     */
    public static float clansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = clansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (float)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dlansy_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lapacke_h.C_DOUBLE,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_POINTER,
            lapacke_h.C_LONG,
            lapacke_h.C_LONG
        );

        public static final MemorySegment ADDR = lapacke_h.findOrThrow("dlansy_");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static FunctionDescriptor dlansy_$descriptor() {
        return dlansy_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MethodHandle dlansy_$handle() {
        return dlansy_.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static MemorySegment dlansy_$address() {
        return dlansy_.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double dlansy_(const char *norm, const char *uplo, const int *n, const double *A, const int *lda, double *work, size_t, size_t)
     * }
     */
    public static double dlansy_(MemorySegment norm, MemorySegment uplo, MemorySegment n, MemorySegment A, MemorySegment lda, MemorySegment work, long x6, long x7) {
        var mh$ = dlansy_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dlansy_", norm, uplo, n, A, lda, work, x6, x7);
            }
            return (double)mh$.invokeExact(norm, uplo, n, A, lda, work, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

